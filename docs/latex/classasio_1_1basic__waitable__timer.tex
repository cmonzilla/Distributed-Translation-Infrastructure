\hypertarget{classasio_1_1basic__waitable__timer}{}\section{asio\+:\+:basic\+\_\+waitable\+\_\+timer$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$ Class Template Reference}
\label{classasio_1_1basic__waitable__timer}\index{asio\+::basic\+\_\+waitable\+\_\+timer$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$@{asio\+::basic\+\_\+waitable\+\_\+timer$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$}}


Provides waitable timer functionality.  




{\ttfamily \#include $<$basic\+\_\+waitable\+\_\+timer.\+hpp$>$}

Inheritance diagram for asio\+:\+:basic\+\_\+waitable\+\_\+timer$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classasio_1_1basic__waitable__timer}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Clock \hyperlink{classasio_1_1basic__waitable__timer_a1b74d12daabb5d3791f7aa42a7bdbd11}{clock\+\_\+type}
\begin{DoxyCompactList}\small\item\em The clock type. \end{DoxyCompactList}\item 
typedef clock\+\_\+type\+::duration \hyperlink{classasio_1_1basic__waitable__timer_a3ab0ae5bdf928106cd6ea19fcd4f5d49}{duration}
\begin{DoxyCompactList}\small\item\em The duration type of the clock. \end{DoxyCompactList}\item 
typedef clock\+\_\+type\+::time\+\_\+point \hyperlink{classasio_1_1basic__waitable__timer_a6f5aadc1aba86956b544ce107cfb49b0}{time\+\_\+point}
\begin{DoxyCompactList}\small\item\em The time point type of the clock. \end{DoxyCompactList}\item 
typedef Wait\+Traits \hyperlink{classasio_1_1basic__waitable__timer_a8b15c2ab0b8daa7a932ac8bed5fe5540}{traits\+\_\+type}
\begin{DoxyCompactList}\small\item\em The wait traits type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classasio_1_1basic__waitable__timer_ac26429a677a85a41fd420879252772df}{basic\+\_\+waitable\+\_\+timer} (\hyperlink{classasio_1_1io__service}{asio\+::io\+\_\+service} \&\hyperlink{classasio_1_1io__service}{io\+\_\+service})
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\hyperlink{classasio_1_1basic__waitable__timer_a407740462725395ffb072104736b769f}{basic\+\_\+waitable\+\_\+timer} (\hyperlink{classasio_1_1io__service}{asio\+::io\+\_\+service} \&\hyperlink{classasio_1_1io__service}{io\+\_\+service}, const \hyperlink{classasio_1_1basic__waitable__timer_a6f5aadc1aba86956b544ce107cfb49b0}{time\+\_\+point} \&expiry\+\_\+time)
\begin{DoxyCompactList}\small\item\em Constructor to set a particular expiry time as an absolute time. \end{DoxyCompactList}\item 
\hyperlink{classasio_1_1basic__waitable__timer_ac3d4118b5f6ca81428fb3b78f4ec75ae}{basic\+\_\+waitable\+\_\+timer} (\hyperlink{classasio_1_1io__service}{asio\+::io\+\_\+service} \&\hyperlink{classasio_1_1io__service}{io\+\_\+service}, const \hyperlink{classasio_1_1basic__waitable__timer_a3ab0ae5bdf928106cd6ea19fcd4f5d49}{duration} \&expiry\+\_\+time)
\begin{DoxyCompactList}\small\item\em Constructor to set a particular expiry time relative to now. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_aaff6cc75a851b177f1c778c50a4e678a}{cancel} ()
\begin{DoxyCompactList}\small\item\em Cancel any asynchronous operations that are waiting on the timer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_ad599f3eecd4f649cf1241d6e4c383f18}{cancel} (\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code} \&ec)
\begin{DoxyCompactList}\small\item\em Cancel any asynchronous operations that are waiting on the timer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_a84451b4a16cbdd72fd77ed3ddc959524}{cancel\+\_\+one} ()
\begin{DoxyCompactList}\small\item\em Cancels one asynchronous operation that is waiting on the timer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_a5e05cbcbab1e177495c580cea18605bb}{cancel\+\_\+one} (\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code} \&ec)
\begin{DoxyCompactList}\small\item\em Cancels one asynchronous operation that is waiting on the timer. \end{DoxyCompactList}\item 
\hyperlink{classasio_1_1basic__waitable__timer_a6f5aadc1aba86956b544ce107cfb49b0}{time\+\_\+point} \hyperlink{classasio_1_1basic__waitable__timer_abcc5c7ae917d2e7f02f6b6506997dae4}{expires\+\_\+at} () const 
\begin{DoxyCompactList}\small\item\em Get the timer\textquotesingle{}s expiry time as an absolute time. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_a26157baae69f83f938497cb78ae27d81}{expires\+\_\+at} (const \hyperlink{classasio_1_1basic__waitable__timer_a6f5aadc1aba86956b544ce107cfb49b0}{time\+\_\+point} \&expiry\+\_\+time)
\begin{DoxyCompactList}\small\item\em Set the timer\textquotesingle{}s expiry time as an absolute time. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_a53ae8940d9ccaefc4016e54c044f19ba}{expires\+\_\+at} (const \hyperlink{classasio_1_1basic__waitable__timer_a6f5aadc1aba86956b544ce107cfb49b0}{time\+\_\+point} \&expiry\+\_\+time, \hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code} \&ec)
\begin{DoxyCompactList}\small\item\em Set the timer\textquotesingle{}s expiry time as an absolute time. \end{DoxyCompactList}\item 
\hyperlink{classasio_1_1basic__waitable__timer_a3ab0ae5bdf928106cd6ea19fcd4f5d49}{duration} \hyperlink{classasio_1_1basic__waitable__timer_afc1cfc8ac6584ae28d69f790a8fe0e73}{expires\+\_\+from\+\_\+now} () const 
\begin{DoxyCompactList}\small\item\em Get the timer\textquotesingle{}s expiry time relative to now. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_aba5cfeb6574f5a1c22444db45dd5fdb2}{expires\+\_\+from\+\_\+now} (const \hyperlink{classasio_1_1basic__waitable__timer_a3ab0ae5bdf928106cd6ea19fcd4f5d49}{duration} \&expiry\+\_\+time)
\begin{DoxyCompactList}\small\item\em Set the timer\textquotesingle{}s expiry time relative to now. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__waitable__timer_af456a9a924c173765a9e52bea96b7765}{expires\+\_\+from\+\_\+now} (const \hyperlink{classasio_1_1basic__waitable__timer_a3ab0ae5bdf928106cd6ea19fcd4f5d49}{duration} \&expiry\+\_\+time, \hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code} \&ec)
\begin{DoxyCompactList}\small\item\em Set the timer\textquotesingle{}s expiry time relative to now. \end{DoxyCompactList}\item 
void \hyperlink{classasio_1_1basic__waitable__timer_a2938c36fcd50c544ca290372785cf66e}{wait} ()
\begin{DoxyCompactList}\small\item\em Perform a blocking wait on the timer. \end{DoxyCompactList}\item 
void \hyperlink{classasio_1_1basic__waitable__timer_a6ec816ab7848e54beec480e2570e3e89}{wait} (\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code} \&ec)
\begin{DoxyCompactList}\small\item\em Perform a blocking wait on the timer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Wait\+Handler $>$ }\\\hyperlink{classasio_1_1basic__waitable__timer_a600bac1095794a65af9b5092c2ecacf8}{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E} (Wait\+Handler, void(\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code})) async\+\_\+wait(\hyperlink{group__async__read_ga6d72a97784dde9476c6d93b8904a4967}{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}(Wait\+Handler) handler)
\begin{DoxyCompactList}\small\item\em Start an asynchronous wait on the timer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Clock, typename Wait\+Traits = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$class asio\+::basic\+\_\+waitable\+\_\+timer$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$}

Provides waitable timer functionality. 

The \hyperlink{classasio_1_1basic__waitable__timer}{basic\+\_\+waitable\+\_\+timer} class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states\+: \char`\"{}expired\char`\"{} or \char`\"{}not expired\char`\"{}. If the \hyperlink{classasio_1_1basic__waitable__timer_a2938c36fcd50c544ca290372785cf66e}{wait()} or async\+\_\+wait() function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the asio\+::steady\+\_\+timer, asio\+::system\+\_\+timer or asio\+::high\+\_\+resolution\+\_\+timer typedefs.

\begin{DoxyNote}{Note}
This waitable timer functionality is for use with the C++11 standard library\textquotesingle{}s {\ttfamily $<$chrono$>$} facility, or with the Boost.\+Chrono library.
\end{DoxyNote}
\begin{DoxyParagraph}{Thread Safety}
{\itshape Distinct} {\itshape objects\+:} Safe.~\newline
{\itshape Shared} {\itshape objects\+:} Unsafe.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Examples}
Performing a blocking wait (C++11)\+: 
\begin{DoxyCode}
\textcolor{comment}{// Construct a timer without setting an expiry time.}
\hyperlink{namespacewebsocketpp_1_1lib_1_1asio_a156f3dad489fb17e3bc79d2009d2656f}{asio::steady\_timer} timer(io\_service);

\textcolor{comment}{// Set an expiry time relative to now.}
timer.expires\_from\_now(std::chrono::seconds(5));

\textcolor{comment}{// Wait for the timer to expire.}
timer.wait();
\end{DoxyCode}

\end{DoxyParagraph}
\begin{DoxyParagraph}{}
Performing an asynchronous wait (C++11)\+: 
\begin{DoxyCode}
\textcolor{keywordtype}{void} handler(\textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error)
\{
  \textcolor{keywordflow}{if} (!error)
  \{
    \textcolor{comment}{// Timer expired.}
  \}
\}

...

\textcolor{comment}{// Construct a timer with an absolute expiry time.}
asio::steady\_timer timer(io\_service,
    std::chrono::steady\_clock::now() + std::chrono::seconds(60));

\textcolor{comment}{// Start an asynchronous wait.}
timer.async\_wait(handler);
\end{DoxyCode}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Changing an active waitable timer\textquotesingle{}s expiry time}

\end{DoxyParagraph}
Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this\+: used\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} on\_some\_event()
\{
  \textcolor{keywordflow}{if} (my\_timer.expires\_from\_now(seconds(5)) > 0)
  \{
    \textcolor{comment}{// We managed to cancel the timer. Start new asynchronous wait.}
    my\_timer.async\_wait(on\_timeout);
  \}
  \textcolor{keywordflow}{else}
  \{
    \textcolor{comment}{// Too late, timer has already expired!}
  \}
\}

\textcolor{keywordtype}{void} on\_timeout(\textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& e)
\{
  \textcolor{keywordflow}{if} (e != \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio::error::operation\_aborted})
  \{
    \textcolor{comment}{// Timer was not cancelled, take necessary action.}
  \}
\}
\end{DoxyCode}


\begin{DoxyItemize}
\item The \hyperlink{classasio_1_1basic__waitable__timer_afc1cfc8ac6584ae28d69f790a8fe0e73}{asio\+::basic\+\_\+waitable\+\_\+timer\+::expires\+\_\+from\+\_\+now()} function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.\end{DoxyItemize}
\begin{DoxyItemize}
\item If a wait handler is cancelled, the \hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code} passed to it contains the value \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted}. \end{DoxyItemize}


Definition at line 126 of file basic\+\_\+waitable\+\_\+timer.\+hpp.



\subsection{Member Typedef Documentation}
\hypertarget{classasio_1_1basic__waitable__timer_a1b74d12daabb5d3791f7aa42a7bdbd11}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!clock\+\_\+type@{clock\+\_\+type}}
\index{clock\+\_\+type@{clock\+\_\+type}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{clock\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ typedef Clock {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::{\bf clock\+\_\+type}}\label{classasio_1_1basic__waitable__timer_a1b74d12daabb5d3791f7aa42a7bdbd11}


The clock type. 



Definition at line 131 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a3ab0ae5bdf928106cd6ea19fcd4f5d49}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!duration@{duration}}
\index{duration@{duration}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{duration}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ typedef clock\+\_\+type\+::duration {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::{\bf duration}}\label{classasio_1_1basic__waitable__timer_a3ab0ae5bdf928106cd6ea19fcd4f5d49}


The duration type of the clock. 



Definition at line 134 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a6f5aadc1aba86956b544ce107cfb49b0}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!time\+\_\+point@{time\+\_\+point}}
\index{time\+\_\+point@{time\+\_\+point}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{time\+\_\+point}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ typedef clock\+\_\+type\+::time\+\_\+point {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::{\bf time\+\_\+point}}\label{classasio_1_1basic__waitable__timer_a6f5aadc1aba86956b544ce107cfb49b0}


The time point type of the clock. 



Definition at line 137 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a8b15c2ab0b8daa7a932ac8bed5fe5540}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!traits\+\_\+type@{traits\+\_\+type}}
\index{traits\+\_\+type@{traits\+\_\+type}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{traits\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ typedef Wait\+Traits {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::{\bf traits\+\_\+type}}\label{classasio_1_1basic__waitable__timer_a8b15c2ab0b8daa7a932ac8bed5fe5540}


The wait traits type. 



Definition at line 140 of file basic\+\_\+waitable\+\_\+timer.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classasio_1_1basic__waitable__timer_ac26429a677a85a41fd420879252772df}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!basic\+\_\+waitable\+\_\+timer@{basic\+\_\+waitable\+\_\+timer}}
\index{basic\+\_\+waitable\+\_\+timer@{basic\+\_\+waitable\+\_\+timer}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{basic\+\_\+waitable\+\_\+timer(asio\+::io\+\_\+service \&io\+\_\+service)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::{\bf basic\+\_\+waitable\+\_\+timer} (
\begin{DoxyParamCaption}
\item[{{\bf asio\+::io\+\_\+service} \&}]{io\+\_\+service}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classasio_1_1basic__waitable__timer_ac26429a677a85a41fd420879252772df}


Constructor. 

This constructor creates a timer without setting an expiry time. The \hyperlink{classasio_1_1basic__waitable__timer_abcc5c7ae917d2e7f02f6b6506997dae4}{expires\+\_\+at()} or \hyperlink{classasio_1_1basic__waitable__timer_afc1cfc8ac6584ae28d69f790a8fe0e73}{expires\+\_\+from\+\_\+now()} functions must be called to set an expiry time before the timer can be waited on.


\begin{DoxyParams}{Parameters}
{\em \hyperlink{classasio_1_1io__service}{io\+\_\+service}} & The \hyperlink{classasio_1_1io__service}{io\+\_\+service} object that the timer will use to dispatch handlers for any asynchronous operations performed on the timer. \\
\hline
\end{DoxyParams}


Definition at line 151 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a407740462725395ffb072104736b769f}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!basic\+\_\+waitable\+\_\+timer@{basic\+\_\+waitable\+\_\+timer}}
\index{basic\+\_\+waitable\+\_\+timer@{basic\+\_\+waitable\+\_\+timer}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{basic\+\_\+waitable\+\_\+timer(asio\+::io\+\_\+service \&io\+\_\+service, const time\+\_\+point \&expiry\+\_\+time)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::{\bf basic\+\_\+waitable\+\_\+timer} (
\begin{DoxyParamCaption}
\item[{{\bf asio\+::io\+\_\+service} \&}]{io\+\_\+service, }
\item[{const {\bf time\+\_\+point} \&}]{expiry\+\_\+time}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a407740462725395ffb072104736b769f}


Constructor to set a particular expiry time as an absolute time. 

This constructor creates a timer and sets the expiry time.


\begin{DoxyParams}{Parameters}
{\em \hyperlink{classasio_1_1io__service}{io\+\_\+service}} & The \hyperlink{classasio_1_1io__service}{io\+\_\+service} object that the timer will use to dispatch handlers for any asynchronous operations performed on the timer.\\
\hline
{\em expiry\+\_\+time} & The expiry time to be used for the timer, expressed as an absolute time. \\
\hline
\end{DoxyParams}


Definition at line 166 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_ac3d4118b5f6ca81428fb3b78f4ec75ae}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!basic\+\_\+waitable\+\_\+timer@{basic\+\_\+waitable\+\_\+timer}}
\index{basic\+\_\+waitable\+\_\+timer@{basic\+\_\+waitable\+\_\+timer}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{basic\+\_\+waitable\+\_\+timer(asio\+::io\+\_\+service \&io\+\_\+service, const duration \&expiry\+\_\+time)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::{\bf basic\+\_\+waitable\+\_\+timer} (
\begin{DoxyParamCaption}
\item[{{\bf asio\+::io\+\_\+service} \&}]{io\+\_\+service, }
\item[{const {\bf duration} \&}]{expiry\+\_\+time}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_ac3d4118b5f6ca81428fb3b78f4ec75ae}


Constructor to set a particular expiry time relative to now. 

This constructor creates a timer and sets the expiry time.


\begin{DoxyParams}{Parameters}
{\em \hyperlink{classasio_1_1io__service}{io\+\_\+service}} & The \hyperlink{classasio_1_1io__service}{io\+\_\+service} object that the timer will use to dispatch handlers for any asynchronous operations performed on the timer.\\
\hline
{\em expiry\+\_\+time} & The expiry time to be used for the timer, relative to now. \\
\hline
\end{DoxyParams}


Definition at line 185 of file basic\+\_\+waitable\+\_\+timer.\+hpp.



\subsection{Member Function Documentation}
\hypertarget{classasio_1_1basic__waitable__timer_a600bac1095794a65af9b5092c2ecacf8}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}}
\index{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E(\+Wait\+Handler, void(asio\+::error\+\_\+code)) async\+\_\+wait(\+A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G(\+Wait\+Handler) handler)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ template$<$typename Wait\+Handler $>$ {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E (
\begin{DoxyParamCaption}
\item[{Wait\+Handler}]{, }
\item[{void({\bf asio\+::error\+\_\+code})}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a600bac1095794a65af9b5092c2ecacf8}


Start an asynchronous wait on the timer. 

This function may be used to initiate an asynchronous wait against the timer. It always returns immediately.

For each call to async\+\_\+wait(), the supplied handler will be called exactly once. The handler will be called when\+:

\begin{DoxyItemize}
\item The timer has expired.\end{DoxyItemize}
\begin{DoxyItemize}
\item The timer was cancelled, in which case the handler is passed the error code \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted}.\end{DoxyItemize}

\begin{DoxyParams}{Parameters}
{\em handler} & The handler to be called when the timer expires. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error \textcolor{comment}{// Result of operation.}
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}. \\
\hline
\end{DoxyParams}


Definition at line 502 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_aaff6cc75a851b177f1c778c50a4e678a}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!cancel@{cancel}}
\index{cancel@{cancel}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{cancel()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::cancel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_aaff6cc75a851b177f1c778c50a4e678a}


Cancel any asynchronous operations that are waiting on the timer. 

This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.

Cancelling the timer does not change the expiry time.

\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classasio_1_1system__error}{asio\+::system\+\_\+error}} & Thrown on failure.\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_aaff6cc75a851b177f1c778c50a4e678a}{cancel()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 216 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_ad599f3eecd4f649cf1241d6e4c383f18}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!cancel@{cancel}}
\index{cancel@{cancel}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{cancel(asio\+::error\+\_\+code \&ec)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::cancel (
\begin{DoxyParamCaption}
\item[{{\bf asio\+::error\+\_\+code} \&}]{ec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_ad599f3eecd4f649cf1241d6e4c383f18}


Cancel any asynchronous operations that are waiting on the timer. 

This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.

Cancelling the timer does not change the expiry time.


\begin{DoxyParams}{Parameters}
{\em ec} & Set to indicate what error occurred, if any.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_aaff6cc75a851b177f1c778c50a4e678a}{cancel()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 246 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a84451b4a16cbdd72fd77ed3ddc959524}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!cancel\+\_\+one@{cancel\+\_\+one}}
\index{cancel\+\_\+one@{cancel\+\_\+one}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{cancel\+\_\+one()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::cancel\+\_\+one (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a84451b4a16cbdd72fd77ed3ddc959524}


Cancels one asynchronous operation that is waiting on the timer. 

This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in F\+I\+F\+O order. The handler for the cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.

Cancelling the timer does not change the expiry time.

\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled. That is, either 0 or 1.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classasio_1_1system__error}{asio\+::system\+\_\+error}} & Thrown on failure.\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_a84451b4a16cbdd72fd77ed3ddc959524}{cancel\+\_\+one()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 275 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a5e05cbcbab1e177495c580cea18605bb}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!cancel\+\_\+one@{cancel\+\_\+one}}
\index{cancel\+\_\+one@{cancel\+\_\+one}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{cancel\+\_\+one(asio\+::error\+\_\+code \&ec)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::cancel\+\_\+one (
\begin{DoxyParamCaption}
\item[{{\bf asio\+::error\+\_\+code} \&}]{ec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a5e05cbcbab1e177495c580cea18605bb}


Cancels one asynchronous operation that is waiting on the timer. 

This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in F\+I\+F\+O order. The handler for the cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.

Cancelling the timer does not change the expiry time.


\begin{DoxyParams}{Parameters}
{\em ec} & Set to indicate what error occurred, if any.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled. That is, either 0 or 1.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_a84451b4a16cbdd72fd77ed3ddc959524}{cancel\+\_\+one()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 307 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_abcc5c7ae917d2e7f02f6b6506997dae4}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!expires\+\_\+at@{expires\+\_\+at}}
\index{expires\+\_\+at@{expires\+\_\+at}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{expires\+\_\+at() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ {\bf time\+\_\+point} {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::expires\+\_\+at (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_abcc5c7ae917d2e7f02f6b6506997dae4}


Get the timer\textquotesingle{}s expiry time as an absolute time. 

This function may be used to obtain the timer\textquotesingle{}s current expiry time. Whether the timer has expired or not does not affect this value. 

Definition at line 317 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a26157baae69f83f938497cb78ae27d81}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!expires\+\_\+at@{expires\+\_\+at}}
\index{expires\+\_\+at@{expires\+\_\+at}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{expires\+\_\+at(const time\+\_\+point \&expiry\+\_\+time)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::expires\+\_\+at (
\begin{DoxyParamCaption}
\item[{const {\bf time\+\_\+point} \&}]{expiry\+\_\+time}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a26157baae69f83f938497cb78ae27d81}


Set the timer\textquotesingle{}s expiry time as an absolute time. 

This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.


\begin{DoxyParams}{Parameters}
{\em expiry\+\_\+time} & The expiry time to be used for the timer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classasio_1_1system__error}{asio\+::system\+\_\+error}} & Thrown on failure.\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_abcc5c7ae917d2e7f02f6b6506997dae4}{expires\+\_\+at()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 344 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a53ae8940d9ccaefc4016e54c044f19ba}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!expires\+\_\+at@{expires\+\_\+at}}
\index{expires\+\_\+at@{expires\+\_\+at}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{expires\+\_\+at(const time\+\_\+point \&expiry\+\_\+time, asio\+::error\+\_\+code \&ec)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::expires\+\_\+at (
\begin{DoxyParamCaption}
\item[{const {\bf time\+\_\+point} \&}]{expiry\+\_\+time, }
\item[{{\bf asio\+::error\+\_\+code} \&}]{ec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a53ae8940d9ccaefc4016e54c044f19ba}


Set the timer\textquotesingle{}s expiry time as an absolute time. 

This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.


\begin{DoxyParams}{Parameters}
{\em expiry\+\_\+time} & The expiry time to be used for the timer.\\
\hline
{\em ec} & Set to indicate what error occurred, if any.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_abcc5c7ae917d2e7f02f6b6506997dae4}{expires\+\_\+at()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 375 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_afc1cfc8ac6584ae28d69f790a8fe0e73}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!expires\+\_\+from\+\_\+now@{expires\+\_\+from\+\_\+now}}
\index{expires\+\_\+from\+\_\+now@{expires\+\_\+from\+\_\+now}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{expires\+\_\+from\+\_\+now() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ {\bf duration} {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::expires\+\_\+from\+\_\+now (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_afc1cfc8ac6584ae28d69f790a8fe0e73}


Get the timer\textquotesingle{}s expiry time relative to now. 

This function may be used to obtain the timer\textquotesingle{}s current expiry time. Whether the timer has expired or not does not affect this value. 

Definition at line 386 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_aba5cfeb6574f5a1c22444db45dd5fdb2}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!expires\+\_\+from\+\_\+now@{expires\+\_\+from\+\_\+now}}
\index{expires\+\_\+from\+\_\+now@{expires\+\_\+from\+\_\+now}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{expires\+\_\+from\+\_\+now(const duration \&expiry\+\_\+time)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::expires\+\_\+from\+\_\+now (
\begin{DoxyParamCaption}
\item[{const {\bf duration} \&}]{expiry\+\_\+time}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_aba5cfeb6574f5a1c22444db45dd5fdb2}


Set the timer\textquotesingle{}s expiry time relative to now. 

This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.


\begin{DoxyParams}{Parameters}
{\em expiry\+\_\+time} & The expiry time to be used for the timer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classasio_1_1system__error}{asio\+::system\+\_\+error}} & Thrown on failure.\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_afc1cfc8ac6584ae28d69f790a8fe0e73}{expires\+\_\+from\+\_\+now()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 413 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_af456a9a924c173765a9e52bea96b7765}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!expires\+\_\+from\+\_\+now@{expires\+\_\+from\+\_\+now}}
\index{expires\+\_\+from\+\_\+now@{expires\+\_\+from\+\_\+now}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{expires\+\_\+from\+\_\+now(const duration \&expiry\+\_\+time, asio\+::error\+\_\+code \&ec)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::expires\+\_\+from\+\_\+now (
\begin{DoxyParamCaption}
\item[{const {\bf duration} \&}]{expiry\+\_\+time, }
\item[{{\bf asio\+::error\+\_\+code} \&}]{ec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_af456a9a924c173765a9e52bea96b7765}


Set the timer\textquotesingle{}s expiry time relative to now. 

This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the \hyperlink{namespaceasio_1_1error_a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b}{asio\+::error\+::operation\+\_\+aborted} error code.


\begin{DoxyParams}{Parameters}
{\em expiry\+\_\+time} & The expiry time to be used for the timer.\\
\hline
{\em ec} & Set to indicate what error occurred, if any.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of asynchronous operations that were cancelled.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If the timer has already expired when \hyperlink{classasio_1_1basic__waitable__timer_afc1cfc8ac6584ae28d69f790a8fe0e73}{expires\+\_\+from\+\_\+now()} is called, then the handlers for asynchronous wait operations will\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item have already been invoked; or\end{DoxyItemize}
\begin{DoxyItemize}
\item have been queued for invocation in the near future.\end{DoxyItemize}
These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 

Definition at line 444 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a2938c36fcd50c544ca290372785cf66e}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!wait@{wait}}
\index{wait@{wait}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{wait()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ void {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::wait (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a2938c36fcd50c544ca290372785cf66e}


Perform a blocking wait on the timer. 

This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classasio_1_1system__error}{asio\+::system\+\_\+error}} & Thrown on failure. \\
\hline
\end{DoxyExceptions}


Definition at line 458 of file basic\+\_\+waitable\+\_\+timer.\+hpp.

\hypertarget{classasio_1_1basic__waitable__timer_a6ec816ab7848e54beec480e2570e3e89}{}\index{asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}!wait@{wait}}
\index{wait@{wait}!asio\+::basic\+\_\+waitable\+\_\+timer@{asio\+::basic\+\_\+waitable\+\_\+timer}}
\subsubsection[{wait(asio\+::error\+\_\+code \&ec)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock , typename Wait\+Traits  = asio\+::wait\+\_\+traits$<$\+Clock$>$, typename Waitable\+Timer\+Service  = waitable\+\_\+timer\+\_\+service$<$\+Clock, Wait\+Traits$>$$>$ void {\bf asio\+::basic\+\_\+waitable\+\_\+timer}$<$ Clock, Wait\+Traits, Waitable\+Timer\+Service $>$\+::wait (
\begin{DoxyParamCaption}
\item[{{\bf asio\+::error\+\_\+code} \&}]{ec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__waitable__timer_a6ec816ab7848e54beec480e2570e3e89}


Perform a blocking wait on the timer. 

This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


\begin{DoxyParams}{Parameters}
{\em ec} & Set to indicate what error occurred, if any. \\
\hline
\end{DoxyParams}


Definition at line 472 of file basic\+\_\+waitable\+\_\+timer.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
ext/asio/\hyperlink{basic__waitable__timer_8hpp}{basic\+\_\+waitable\+\_\+timer.\+hpp}\end{DoxyCompactItemize}
