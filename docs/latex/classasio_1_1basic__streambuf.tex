\hypertarget{classasio_1_1basic__streambuf}{}\section{asio\+:\+:basic\+\_\+streambuf$<$ Allocator $>$ Class Template Reference}
\label{classasio_1_1basic__streambuf}\index{asio\+::basic\+\_\+streambuf$<$ Allocator $>$@{asio\+::basic\+\_\+streambuf$<$ Allocator $>$}}


Automatically resizable buffer class based on std\+::streambuf.  




{\ttfamily \#include $<$asio/basic\+\_\+streambuf.\+hpp$>$}

Inheritance diagram for asio\+:\+:basic\+\_\+streambuf$<$ Allocator $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classasio_1_1basic__streambuf}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classasio_1_1const__buffers__1}{asio\+::const\+\_\+buffers\+\_\+1} \hyperlink{classasio_1_1basic__streambuf_a6318f8e7cef616d25207918033f02bc9}{const\+\_\+buffers\+\_\+type}
\item 
typedef \hyperlink{classasio_1_1mutable__buffers__1}{asio\+::mutable\+\_\+buffers\+\_\+1} \hyperlink{classasio_1_1basic__streambuf_a4d2090a05e1d13270b4e30d848517272}{mutable\+\_\+buffers\+\_\+type}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classasio_1_1basic__streambuf_ae170fa1aa36003d7bf294b18d95559a8}{basic\+\_\+streambuf} (std\+::size\+\_\+t maximum\+\_\+size=(std\+::numeric\+\_\+limits$<$ std\+::size\+\_\+t $>$\+::max)(), const Allocator \&allocator=Allocator())
\begin{DoxyCompactList}\small\item\em Construct a \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} object. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__streambuf_a18183b8bfcb9a7cda8c467c80d578e69}{size} () const 
\begin{DoxyCompactList}\small\item\em Get the size of the input sequence. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__streambuf_aee4f81154657df05c5c01cc732fe8a3a}{max\+\_\+size} () const 
\begin{DoxyCompactList}\small\item\em Get the maximum size of the \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}. \end{DoxyCompactList}\item 
\hyperlink{classasio_1_1basic__streambuf_a6318f8e7cef616d25207918033f02bc9}{const\+\_\+buffers\+\_\+type} \hyperlink{classasio_1_1basic__streambuf_a0bcecbf99eb1d32613738a73db9de4c9}{data} () const 
\begin{DoxyCompactList}\small\item\em Get a list of buffers that represents the input sequence. \end{DoxyCompactList}\item 
\hyperlink{classasio_1_1basic__streambuf_a4d2090a05e1d13270b4e30d848517272}{mutable\+\_\+buffers\+\_\+type} \hyperlink{classasio_1_1basic__streambuf_a4f19d44bcf40de432f9e6984df959e73}{prepare} (std\+::size\+\_\+t n)
\item 
void \hyperlink{classasio_1_1basic__streambuf_a6d01805ae2a9382cbb81934111c8ea1c}{commit} (std\+::size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Move characters from the output sequence to the input sequence. \end{DoxyCompactList}\item 
void \hyperlink{classasio_1_1basic__streambuf_a83ca4bad37c9c96f72eda6c8ef133df4}{consume} (std\+::size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Remove characters from the input sequence. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
enum \{ \hyperlink{classasio_1_1basic__streambuf_a69fa699929e44c40b6194b8a4f600de0ad665b162cf9d1a1e82e74d40b3e8a329}{buffer\+\_\+delta} = 128
 \}
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
int\+\_\+type \hyperlink{classasio_1_1basic__streambuf_ab1d0caa8e5cd788d2d7588ff79b9fd5e}{underflow} ()
\begin{DoxyCompactList}\small\item\em Override std\+::streambuf behaviour. \end{DoxyCompactList}\item 
int\+\_\+type \hyperlink{classasio_1_1basic__streambuf_a8c66d95fc706065ca0c87e0d6959e72f}{overflow} (int\+\_\+type c)
\begin{DoxyCompactList}\small\item\em Override std\+::streambuf behaviour. \end{DoxyCompactList}\item 
void \hyperlink{classasio_1_1basic__streambuf_a76d97a93b5e468f95ebe343aff1b3aa8}{reserve} (std\+::size\+\_\+t n)
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
std\+::size\+\_\+t \hyperlink{classasio_1_1basic__streambuf_af169822c1317b8129f360cb23ddd2e15}{read\+\_\+size\+\_\+helper} (\hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} \&sb, std\+::size\+\_\+t \hyperlink{classasio_1_1basic__streambuf_aee4f81154657df05c5c01cc732fe8a3a}{max\+\_\+size})
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Allocator$>$class asio\+::basic\+\_\+streambuf$<$ Allocator $>$}

Automatically resizable buffer class based on std\+::streambuf. 

The {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} class is derived from {\ttfamily std\+::streambuf} to associate the streambuf\textquotesingle{}s input and output sequences with one or more character arrays. These character arrays are internal to the {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} object, but direct access to the array elements is provided to permit them to be used efficiently with I/\+O operations. Characters written to the output sequence of a {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} object are appended to the input sequence of the same object.

The {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} class\textquotesingle{}s public interface is intended to permit the following implementation strategies\+:

\begin{DoxyItemize}
\item A single contiguous character array, which is reallocated as necessary to accommodate changes in the size of the character sequence. This is the implementation approach currently used in Asio.\end{DoxyItemize}
\begin{DoxyItemize}
\item A sequence of one or more character arrays, where each array is of the same size. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.\end{DoxyItemize}
\begin{DoxyItemize}
\item A sequence of one or more character arrays of varying sizes. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.\end{DoxyItemize}
The constructor for \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} accepts a {\ttfamily size\+\_\+t} argument specifying the maximum of the sum of the sizes of the input sequence and output sequence. During the lifetime of the {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} object, the following invariant holds\+: 
\begin{DoxyCode}
\hyperlink{classasio_1_1basic__streambuf_a18183b8bfcb9a7cda8c467c80d578e69}{size}() <= \hyperlink{classasio_1_1basic__streambuf_aee4f81154657df05c5c01cc732fe8a3a}{max\_size}()
\end{DoxyCode}
 Any member function that would, if successful, cause the invariant to be violated shall throw an exception of class {\ttfamily std\+::length\+\_\+error}.

The constructor for {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} takes an Allocator argument. A copy of this argument is used for any memory allocation performed, by the constructor and by all member functions, during the lifetime of each {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} object.

\begin{DoxyParagraph}{Examples}
Writing directly from an streambuf to a socket\+: 
\begin{DoxyCode}
\hyperlink{classasio_1_1basic__streambuf}{asio::streambuf} \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b};
std::ostream os(&b);
os << \textcolor{stringliteral}{"Hello, World!\(\backslash\)n"};

\textcolor{comment}{// try sending some data in input sequence}
\textcolor{keywordtype}{size\_t} n = sock.send(b.\hyperlink{classasio_1_1basic__streambuf_a0bcecbf99eb1d32613738a73db9de4c9}{data}());

b.\hyperlink{classasio_1_1basic__streambuf_a83ca4bad37c9c96f72eda6c8ef133df4}{consume}(n); \textcolor{comment}{// sent data is removed from input sequence}
\end{DoxyCode}

\end{DoxyParagraph}
Reading from a socket directly into a streambuf\+: 
\begin{DoxyCode}
\hyperlink{classasio_1_1basic__streambuf}{asio::streambuf} \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b};

\textcolor{comment}{// reserve 512 bytes in output sequence}
\hyperlink{classasio_1_1mutable__buffers__1}{asio::streambuf::mutable\_buffers\_type} bufs = b.
      \hyperlink{classasio_1_1basic__streambuf_a4f19d44bcf40de432f9e6984df959e73}{prepare}(512);

\textcolor{keywordtype}{size\_t} n = sock.receive(bufs);

\textcolor{comment}{// received data is "committed" from output sequence to input sequence}
b.\hyperlink{classasio_1_1basic__streambuf_a6d01805ae2a9382cbb81934111c8ea1c}{commit}(n);

std::istream is(&b);
std::string \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s};
is >> \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s};
\end{DoxyCode}
 

Definition at line 110 of file basic\+\_\+streambuf.\+hpp.



\subsection{Member Typedef Documentation}
\hypertarget{classasio_1_1basic__streambuf_a6318f8e7cef616d25207918033f02bc9}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!const\+\_\+buffers\+\_\+type@{const\+\_\+buffers\+\_\+type}}
\index{const\+\_\+buffers\+\_\+type@{const\+\_\+buffers\+\_\+type}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{const\+\_\+buffers\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ typedef {\bf asio\+::const\+\_\+buffers\+\_\+1} {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::{\bf const\+\_\+buffers\+\_\+type}}\label{classasio_1_1basic__streambuf_a6318f8e7cef616d25207918033f02bc9}


Definition at line 122 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_a4d2090a05e1d13270b4e30d848517272}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!mutable\+\_\+buffers\+\_\+type@{mutable\+\_\+buffers\+\_\+type}}
\index{mutable\+\_\+buffers\+\_\+type@{mutable\+\_\+buffers\+\_\+type}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{mutable\+\_\+buffers\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ typedef {\bf asio\+::mutable\+\_\+buffers\+\_\+1} {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::{\bf mutable\+\_\+buffers\+\_\+type}}\label{classasio_1_1basic__streambuf_a4d2090a05e1d13270b4e30d848517272}


Definition at line 123 of file basic\+\_\+streambuf.\+hpp.



\subsection{Member Enumeration Documentation}
\hypertarget{classasio_1_1basic__streambuf_a69fa699929e44c40b6194b8a4f600de0}{}\subsubsection[{anonymous enum}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ anonymous enum\hspace{0.3cm}{\ttfamily [protected]}}\label{classasio_1_1basic__streambuf_a69fa699929e44c40b6194b8a4f600de0}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{buffer\+\_\+delta@{buffer\+\_\+delta}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!buffer\+\_\+delta@{buffer\+\_\+delta}}\item[{\em 
\hypertarget{classasio_1_1basic__streambuf_a69fa699929e44c40b6194b8a4f600de0ad665b162cf9d1a1e82e74d40b3e8a329}{}buffer\+\_\+delta\label{classasio_1_1basic__streambuf_a69fa699929e44c40b6194b8a4f600de0ad665b162cf9d1a1e82e74d40b3e8a329}
}]\end{description}
\end{Desc}


Definition at line 248 of file basic\+\_\+streambuf.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classasio_1_1basic__streambuf_ae170fa1aa36003d7bf294b18d95559a8}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!basic\+\_\+streambuf@{basic\+\_\+streambuf}}
\index{basic\+\_\+streambuf@{basic\+\_\+streambuf}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{basic\+\_\+streambuf(std\+::size\+\_\+t maximum\+\_\+size=(std\+::numeric\+\_\+limits$<$ std\+::size\+\_\+t $>$\+::max)(), const Allocator \&allocator=\+Allocator())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::{\bf basic\+\_\+streambuf} (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{maximum\+\_\+size = {\ttfamily (std\+:\+:numeric\+\_\+limits$<$std\+:\+:size\+\_\+t$>$\+:\+:max)()}, }
\item[{const Allocator \&}]{allocator = {\ttfamily Allocator()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classasio_1_1basic__streambuf_ae170fa1aa36003d7bf294b18d95559a8}


Construct a \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} object. 

Constructs a streambuf with the specified maximum size. The initial size of the streambuf\textquotesingle{}s input sequence is 0. 

Definition at line 131 of file basic\+\_\+streambuf.\+hpp.



\subsection{Member Function Documentation}
\hypertarget{classasio_1_1basic__streambuf_a6d01805ae2a9382cbb81934111c8ea1c}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!commit@{commit}}
\index{commit@{commit}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{commit(std\+::size\+\_\+t n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ void {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::commit (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__streambuf_a6d01805ae2a9382cbb81934111c8ea1c}


Move characters from the output sequence to the input sequence. 

Appends {\ttfamily n} characters from the start of the output sequence to the input sequence. The beginning of the output sequence is advanced by {\ttfamily n} characters.

Requires a preceding call {\ttfamily prepare(x)} where {\ttfamily x $>$= n}, and no intervening operations that modify the input or output sequence.

\begin{DoxyNote}{Note}
If {\ttfamily n} is greater than the size of the output sequence, the entire output sequence is moved to the input sequence and no error is issued. 
\end{DoxyNote}


Definition at line 223 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_a83ca4bad37c9c96f72eda6c8ef133df4}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!consume@{consume}}
\index{consume@{consume}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{consume(std\+::size\+\_\+t n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ void {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::consume (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__streambuf_a83ca4bad37c9c96f72eda6c8ef133df4}


Remove characters from the input sequence. 

Removes {\ttfamily n} characters from the beginning of the input sequence.

\begin{DoxyNote}{Note}
If {\ttfamily n} is greater than the size of the input sequence, the entire input sequence is consumed and no error is issued. 
\end{DoxyNote}


Definition at line 238 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_a0bcecbf99eb1d32613738a73db9de4c9}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!data@{data}}
\index{data@{data}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{data() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ {\bf const\+\_\+buffers\+\_\+type} {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__streambuf_a0bcecbf99eb1d32613738a73db9de4c9}


Get a list of buffers that represents the input sequence. 

\begin{DoxyReturn}{Returns}
An object of type {\ttfamily const\+\_\+buffers\+\_\+type} that satisfies Const\+Buffer\+Sequence requirements, representing all character arrays in the input sequence.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The returned object is invalidated by any {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} member function that modifies the input sequence or output sequence. 
\end{DoxyNote}


Definition at line 182 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_aee4f81154657df05c5c01cc732fe8a3a}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!max\+\_\+size@{max\+\_\+size}}
\index{max\+\_\+size@{max\+\_\+size}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{max\+\_\+size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::max\+\_\+size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__streambuf_aee4f81154657df05c5c01cc732fe8a3a}


Get the maximum size of the \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}. 

\begin{DoxyReturn}{Returns}
The allowed maximum of the sum of the sizes of the input sequence and output sequence. 
\end{DoxyReturn}


Definition at line 168 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_a8c66d95fc706065ca0c87e0d6959e72f}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!overflow@{overflow}}
\index{overflow@{overflow}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{overflow(int\+\_\+type c)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ int\+\_\+type {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::overflow (
\begin{DoxyParamCaption}
\item[{int\+\_\+type}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classasio_1_1basic__streambuf_a8c66d95fc706065ca0c87e0d6959e72f}


Override std\+::streambuf behaviour. 

Behaves according to the specification of {\ttfamily std\+::streambuf\+::overflow()}, with the specialisation that {\ttfamily std\+::length\+\_\+error} is thrown if appending the character to the input sequence would require the condition {\ttfamily \hyperlink{classasio_1_1basic__streambuf_a18183b8bfcb9a7cda8c467c80d578e69}{size()} $>$ \hyperlink{classasio_1_1basic__streambuf_aee4f81154657df05c5c01cc732fe8a3a}{max\+\_\+size()}} to be true. 

Definition at line 274 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_a4f19d44bcf40de432f9e6984df959e73}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!prepare@{prepare}}
\index{prepare@{prepare}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{prepare(std\+::size\+\_\+t n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ {\bf mutable\+\_\+buffers\+\_\+type} {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::prepare (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__streambuf_a4f19d44bcf40de432f9e6984df959e73}
Get a list of buffers that represents the output sequence, with the given size. Ensures that the output sequence can accommodate {\ttfamily n} characters, reallocating character array objects as necessary.

\begin{DoxyReturn}{Returns}
An object of type {\ttfamily mutable\+\_\+buffers\+\_\+type} that satisfies Mutable\+Buffer\+Sequence requirements, representing character array objects at the start of the output sequence such that the sum of the buffer sizes is {\ttfamily n}.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::length\+\_\+error} & If {\ttfamily \hyperlink{classasio_1_1basic__streambuf_a18183b8bfcb9a7cda8c467c80d578e69}{size()} + n $>$ \hyperlink{classasio_1_1basic__streambuf_aee4f81154657df05c5c01cc732fe8a3a}{max\+\_\+size()}}.\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
The returned object is invalidated by any {\ttfamily \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf}} member function that modifies the input sequence or output sequence. 
\end{DoxyNote}


Definition at line 204 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_a76d97a93b5e468f95ebe343aff1b3aa8}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!reserve@{reserve}}
\index{reserve@{reserve}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{reserve(std\+::size\+\_\+t n)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ void {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::reserve (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classasio_1_1basic__streambuf_a76d97a93b5e468f95ebe343aff1b3aa8}


Definition at line 299 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_a18183b8bfcb9a7cda8c467c80d578e69}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!size@{size}}
\index{size@{size}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ std\+::size\+\_\+t {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classasio_1_1basic__streambuf_a18183b8bfcb9a7cda8c467c80d578e69}


Get the size of the input sequence. 

\begin{DoxyReturn}{Returns}
The size of the input sequence. The value is equal to that calculated for {\ttfamily s} in the following code\+: 
\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} s = 0;
\hyperlink{classasio_1_1basic__streambuf_a6318f8e7cef616d25207918033f02bc9}{const\_buffers\_type} bufs = \hyperlink{classasio_1_1basic__streambuf_a0bcecbf99eb1d32613738a73db9de4c9}{data}();
\hyperlink{classasio_1_1const__buffers__1_af82877a0ca877a65af2e4c0990c854b4}{const\_buffers\_type::const\_iterator} i = bufs.begin();
\textcolor{keywordflow}{while} (i != bufs.end())
\{
  const\_buffer \hyperlink{namespaceasio_1_1detail_1_1descriptor__ops_ad10e658a754ff775cdcc3b3decd3c8c9}{buf}(*i++);
  s += \hyperlink{group__buffer__size_gabe8b5f116fbb66004b6d0ba8ee39c3d5}{buffer\_size}(buf);
\}
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 158 of file basic\+\_\+streambuf.\+hpp.

\hypertarget{classasio_1_1basic__streambuf_ab1d0caa8e5cd788d2d7588ff79b9fd5e}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!underflow@{underflow}}
\index{underflow@{underflow}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{underflow()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ int\+\_\+type {\bf asio\+::basic\+\_\+streambuf}$<$ Allocator $>$\+::underflow (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classasio_1_1basic__streambuf_ab1d0caa8e5cd788d2d7588ff79b9fd5e}


Override std\+::streambuf behaviour. 

Behaves according to the specification of {\ttfamily std\+::streambuf\+::underflow()}. 

Definition at line 254 of file basic\+\_\+streambuf.\+hpp.



\subsection{Friends And Related Function Documentation}
\hypertarget{classasio_1_1basic__streambuf_af169822c1317b8129f360cb23ddd2e15}{}\index{asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}!read\+\_\+size\+\_\+helper@{read\+\_\+size\+\_\+helper}}
\index{read\+\_\+size\+\_\+helper@{read\+\_\+size\+\_\+helper}!asio\+::basic\+\_\+streambuf@{asio\+::basic\+\_\+streambuf}}
\subsubsection[{read\+\_\+size\+\_\+helper}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Allocator$>$ std\+::size\+\_\+t read\+\_\+size\+\_\+helper (
\begin{DoxyParamCaption}
\item[{{\bf basic\+\_\+streambuf}$<$ Allocator $>$ \&}]{sb, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [friend]}}\label{classasio_1_1basic__streambuf_af169822c1317b8129f360cb23ddd2e15}


Definition at line 344 of file basic\+\_\+streambuf.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
ext/asio/\hyperlink{basic__streambuf_8hpp}{basic\+\_\+streambuf.\+hpp}\end{DoxyCompactItemize}
