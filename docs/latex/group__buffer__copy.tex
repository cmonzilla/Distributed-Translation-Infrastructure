\hypertarget{group__buffer__copy}{}\section{asio\+:\+:buffer\+\_\+copy}
\label{group__buffer__copy}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}


The \hyperlink{group__buffer__copy_ga8bc8cbf49a91e58205de746721d614d8}{asio\+::buffer\+\_\+copy} function is used to copy bytes from a source buffer (or buffer sequence) to a target buffer (or buffer sequence).  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga8bc8cbf49a91e58205de746721d614d8}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const const\+\_\+buffer \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga09726c974288624f654a593b06ba1a0c}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const const\+\_\+buffers\+\_\+1 \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_gad7a03807f5083b423e1fff2173edf991}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const mutable\+\_\+buffer \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga8ed1b2c796b937a0b044df908ad4e3d8}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const mutable\+\_\+buffers\+\_\+1 \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Const\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_gae2aab004dd723dc638aeb08552e4c9a9}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const Const\+Buffer\+Sequence \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer sequence to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga579f9adb02c3bc0b597f6a7bff4cf18e}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffer \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga12327c4bafb7677e99bb0358bfe22605}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffers\+\_\+1 \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_gad90d26f875c173b7a76b133f43b42820}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffer \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_gaae1f69957daad37a92d711b3d6f3d474}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffers\+\_\+1 \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Const\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_gaf4a2817b703dafb592312891de669218}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const Const\+Buffer\+Sequence \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer sequence to a target buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga53ec05b1cae10cdc08b8768bd6b7b7b2}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffer \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer sequence. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga980f80c33ea8e7287819bc1753a92f7b}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffers\+\_\+1 \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer sequence. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga805c350f27581373ee6c1d0fdcff92e0}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffer \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer sequence. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga77fdccbc8ef71eca2becc0ae9b5a5921}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffers\+\_\+1 \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer to a target buffer sequence. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence , typename Const\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga0ee2be3725dff58302a47a0eb2bc72bb}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const Const\+Buffer\+Sequence \&source)
\begin{DoxyCompactList}\small\item\em Copies bytes from a source buffer sequence to a target buffer sequence. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_gaccb89801dc44bbcbf308e08dcb0c9181}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const const\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga9e6ea40e73105d4a5a73b24320feb59d}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const const\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga13c7347ac0eae54aea68d4b70d144a2e}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const mutable\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga4d1a32a028494196848be4e5347edd43}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const mutable\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Const\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga3c033d3e12841b6835b036344da2305f}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffer \&target, const Const\+Buffer\+Sequence \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_gacdaafbbc9b0024de24f208ccc933f6e3}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga4d26475b811386a5c1cfc779368dd56d}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga39411f1f8eae62b00cfc5fdec52e62ef}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga3ec7ca61beddb66bdf2c1b9950e5ef25}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\begin{DoxyCompactList}\small\item\em Copies a limited number of bytes from a source buffer to a target buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Const\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_gaebf4f7f5d3db8dfaaeabd5d8bbfc3c30}{asio\+::buffer\+\_\+copy} (const mutable\+\_\+buffers\+\_\+1 \&target, const Const\+Buffer\+Sequence \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga8a4ac1b034c7a80d4e5ebbd858a9c727}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_gaa146b63f2bdc20a3c0bd5e4c4d8d0ead}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga31d071ecd1fc863feac8d1ca303c4346}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga328a0f81f124d05c142465d3ebeeefeb}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\item 
{\footnotesize template$<$typename Mutable\+Buffer\+Sequence , typename Const\+Buffer\+Sequence $>$ }\\std\+::size\+\_\+t \hyperlink{group__buffer__copy_ga0552327b5c66c5f764476539909d3d15}{asio\+::buffer\+\_\+copy} (const Mutable\+Buffer\+Sequence \&target, const Const\+Buffer\+Sequence \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
The \hyperlink{group__buffer__copy_ga8bc8cbf49a91e58205de746721d614d8}{asio\+::buffer\+\_\+copy} function is used to copy bytes from a source buffer (or buffer sequence) to a target buffer (or buffer sequence). 

The {\ttfamily buffer\+\_\+copy} function is available in two forms\+:

\begin{DoxyItemize}
\item A 2-\/argument form\+: {\ttfamily buffer\+\_\+copy(target, source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item A 3-\/argument form\+: {\ttfamily buffer\+\_\+copy(target, source, max\+\_\+bytes\+\_\+to\+\_\+copy)} \end{DoxyItemize}
Both forms return the number of bytes actually copied. The number of bytes copied is the lesser of\+:

\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily If} specified, {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy}.\end{DoxyItemize}
This prevents buffer overflow, regardless of the buffer sizes used in the copy operation.

Note that \hyperlink{group__buffer__copy}{asio\+::buffer\+\_\+copy} is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

\subsection{Function Documentation}
\hypertarget{group__buffer__copy_ga8bc8cbf49a91e58205de746721d614d8}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const const\+\_\+buffer \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf const\+\_\+buffer} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga8bc8cbf49a91e58205de746721d614d8}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1295 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga09726c974288624f654a593b06ba1a0c}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const const\+\_\+buffers\+\_\+1 \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf const\+\_\+buffers\+\_\+1} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga09726c974288624f654a593b06ba1a0c}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1325 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gad7a03807f5083b423e1fff2173edf991}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const mutable\+\_\+buffer \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffer} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gad7a03807f5083b423e1fff2173edf991}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1351 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga8ed1b2c796b937a0b044df908ad4e3d8}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const mutable\+\_\+buffers\+\_\+1 \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga8ed1b2c796b937a0b044df908ad4e3d8}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1377 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gae2aab004dd723dc638aeb08552e4c9a9}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const Const\+Buffer\+Sequence \&source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Const\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const Const\+Buffer\+Sequence \&}]{source}
\end{DoxyParamCaption}
)}\label{group__buffer__copy_gae2aab004dd723dc638aeb08552e4c9a9}


Copies bytes from a source buffer sequence to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer sequence representing the memory regions from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1403 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga579f9adb02c3bc0b597f6a7bff4cf18e}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffer \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf const\+\_\+buffer} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga579f9adb02c3bc0b597f6a7bff4cf18e}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1442 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga12327c4bafb7677e99bb0358bfe22605}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffers\+\_\+1 \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf const\+\_\+buffers\+\_\+1} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga12327c4bafb7677e99bb0358bfe22605}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1467 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gad90d26f875c173b7a76b133f43b42820}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffer \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffer} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gad90d26f875c173b7a76b133f43b42820}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1494 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gaae1f69957daad37a92d711b3d6f3d474}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffers\+\_\+1 \&source)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gaae1f69957daad37a92d711b3d6f3d474}


Copies bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1521 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gaf4a2817b703dafb592312891de669218}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const Const\+Buffer\+Sequence \&source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Const\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const Const\+Buffer\+Sequence \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gaf4a2817b703dafb592312891de669218}


Copies bytes from a source buffer sequence to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer sequence representing the memory regions from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1548 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga53ec05b1cae10cdc08b8768bd6b7b7b2}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffer \&source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf const\+\_\+buffer} \&}]{source}
\end{DoxyParamCaption}
)}\label{group__buffer__copy_ga53ec05b1cae10cdc08b8768bd6b7b7b2}


Copies bytes from a source buffer to a target buffer sequence. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1574 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga980f80c33ea8e7287819bc1753a92f7b}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffers\+\_\+1 \&source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf const\+\_\+buffers\+\_\+1} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga980f80c33ea8e7287819bc1753a92f7b}


Copies bytes from a source buffer to a target buffer sequence. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1614 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga805c350f27581373ee6c1d0fdcff92e0}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffer \&source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf mutable\+\_\+buffer} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga805c350f27581373ee6c1d0fdcff92e0}


Copies bytes from a source buffer to a target buffer sequence. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1641 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga77fdccbc8ef71eca2becc0ae9b5a5921}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffers\+\_\+1 \&source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga77fdccbc8ef71eca2becc0ae9b5a5921}


Copies bytes from a source buffer to a target buffer sequence. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1668 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga0ee2be3725dff58302a47a0eb2bc72bb}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const Const\+Buffer\+Sequence \&source)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence , typename Const\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const Const\+Buffer\+Sequence \&}]{source}
\end{DoxyParamCaption}
)}\label{group__buffer__copy_ga0ee2be3725dff58302a47a0eb2bc72bb}


Copies bytes from a source buffer sequence to a target buffer sequence. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer sequence representing the memory regions from which the bytes will be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1694 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gaccb89801dc44bbcbf308e08dcb0c9181}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const const\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf const\+\_\+buffer} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gaccb89801dc44bbcbf308e08dcb0c9181}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1761 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga9e6ea40e73105d4a5a73b24320feb59d}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const const\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf const\+\_\+buffers\+\_\+1} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga9e6ea40e73105d4a5a73b24320feb59d}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1790 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga13c7347ac0eae54aea68d4b70d144a2e}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const mutable\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffer} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga13c7347ac0eae54aea68d4b70d144a2e}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1820 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga4d1a32a028494196848be4e5347edd43}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const mutable\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga4d1a32a028494196848be4e5347edd43}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1850 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga3c033d3e12841b6835b036344da2305f}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffer \&target, const Const\+Buffer\+Sequence \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Const\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{target, }
\item[{const Const\+Buffer\+Sequence \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga3c033d3e12841b6835b036344da2305f}
Copies a limited number of bytes from a source buffer sequence to a target buffer. 
\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer sequence representing the memory regions from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1881 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gacdaafbbc9b0024de24f208ccc933f6e3}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf const\+\_\+buffer} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gacdaafbbc9b0024de24f208ccc933f6e3}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1910 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga4d26475b811386a5c1cfc779368dd56d}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const const\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf const\+\_\+buffers\+\_\+1} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga4d26475b811386a5c1cfc779368dd56d}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1939 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga39411f1f8eae62b00cfc5fdec52e62ef}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffer} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga39411f1f8eae62b00cfc5fdec52e62ef}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1969 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga3ec7ca61beddb66bdf2c1b9950e5ef25}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const mutable\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga3ec7ca61beddb66bdf2c1b9950e5ef25}


Copies a limited number of bytes from a source buffer to a target buffer. 


\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 1999 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gaebf4f7f5d3db8dfaaeabd5d8bbfc3c30}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const mutable\+\_\+buffers\+\_\+1 \&target, const Const\+Buffer\+Sequence \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Const\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{target, }
\item[{const Const\+Buffer\+Sequence \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gaebf4f7f5d3db8dfaaeabd5d8bbfc3c30}
Copies a limited number of bytes from a source buffer sequence to a target buffer. 
\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer representing the memory region to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer sequence representing the memory regions from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 2030 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga8a4ac1b034c7a80d4e5ebbd858a9c727}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf const\+\_\+buffer} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga8a4ac1b034c7a80d4e5ebbd858a9c727}
Copies a limited number of bytes from a source buffer to a target buffer sequence. 
\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 2061 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_gaa146b63f2bdc20a3c0bd5e4c4d8d0ead}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const const\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf const\+\_\+buffers\+\_\+1} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_gaa146b63f2bdc20a3c0bd5e4c4d8d0ead}
Copies a limited number of bytes from a source buffer to a target buffer sequence. 
\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer representing the memory region from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 2092 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga31d071ecd1fc863feac8d1ca303c4346}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffer \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf mutable\+\_\+buffer} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga31d071ecd1fc863feac8d1ca303c4346}
Copies a limited number of bytes from a source buffer to a target buffer sequence. 
\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 2124 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga328a0f81f124d05c142465d3ebeeefeb}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const mutable\+\_\+buffers\+\_\+1 \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const {\bf mutable\+\_\+buffers\+\_\+1} \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer__copy_ga328a0f81f124d05c142465d3ebeeefeb}
Copies a limited number of bytes from a source buffer to a target buffer sequence. 
\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A modifiable buffer representing the memory region from which the bytes will be copied. The contents of the source buffer will not be modified.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 2156 of file buffer.\+hpp.

\hypertarget{group__buffer__copy_ga0552327b5c66c5f764476539909d3d15}{}\index{asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}!buffer\+\_\+copy@{buffer\+\_\+copy}}
\index{buffer\+\_\+copy@{buffer\+\_\+copy}!asio\+::buffer\+\_\+copy@{asio\+::buffer\+\_\+copy}}
\subsubsection[{buffer\+\_\+copy(const Mutable\+Buffer\+Sequence \&target, const Const\+Buffer\+Sequence \&source, std\+::size\+\_\+t max\+\_\+bytes\+\_\+to\+\_\+copy)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Mutable\+Buffer\+Sequence , typename Const\+Buffer\+Sequence $>$ std\+::size\+\_\+t asio\+::buffer\+\_\+copy (
\begin{DoxyParamCaption}
\item[{const Mutable\+Buffer\+Sequence \&}]{target, }
\item[{const Const\+Buffer\+Sequence \&}]{source, }
\item[{std\+::size\+\_\+t}]{max\+\_\+bytes\+\_\+to\+\_\+copy}
\end{DoxyParamCaption}
)}\label{group__buffer__copy_ga0552327b5c66c5f764476539909d3d15}
Copies a limited number of bytes from a source buffer sequence to a target buffer sequence. 
\begin{DoxyParams}{Parameters}
{\em target} & A modifiable buffer sequence representing the memory regions to which the bytes will be copied.\\
\hline
{\em source} & A non-\/modifiable buffer sequence representing the memory regions from which the bytes will be copied.\\
\hline
{\em max\+\_\+bytes\+\_\+to\+\_\+copy} & The maximum number of bytes to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes copied.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of bytes copied is the lesser of\+:
\end{DoxyNote}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(target)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily buffer\+\_\+size(source)} \end{DoxyItemize}
\begin{DoxyItemize}
\item {\ttfamily max\+\_\+bytes\+\_\+to\+\_\+copy} \end{DoxyItemize}
This function is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions. 

Definition at line 2187 of file buffer.\+hpp.

