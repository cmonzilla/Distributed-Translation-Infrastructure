<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Basic Phrase Based Decoding: asio::ssl::old::stream&lt; Stream, Service &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="owl.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Basic Phrase Based Decoding
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ client/server language translation infrastructure</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classasio_1_1ssl_1_1old_1_1stream.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classasio_1_1ssl_1_1old_1_1stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asio::ssl::old::stream&lt; Stream, Service &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides stream-oriented functionality using SSL.  
 <a href="classasio_1_1ssl_1_1old_1_1stream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for asio::ssl::old::stream&lt; Stream, Service &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classasio_1_1ssl_1_1old_1_1stream.png" usemap="#asio::ssl::old::stream&lt; Stream, Service &gt;_map" alt=""/>
  <map id="asio::ssl::old::stream&lt; Stream, Service &gt;_map" name="asio::ssl::old::stream&lt; Stream, Service &gt;_map">
<area href="classasio_1_1ssl_1_1stream__base.html" alt="asio::ssl::stream_base" shape="rect" coords="0,0,238,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a71ae7adcbd44cae6750157541c2ddf8e"><td class="memItemLeft" align="right" valign="top">typedef remove_reference&lt; Stream &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a71ae7adcbd44cae6750157541c2ddf8e">next_layer_type</a></td></tr>
<tr class="memdesc:a71ae7adcbd44cae6750157541c2ddf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer.  <a href="#a71ae7adcbd44cae6750157541c2ddf8e">More...</a><br /></td></tr>
<tr class="separator:a71ae7adcbd44cae6750157541c2ddf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b664149066b698269db4e2f4e846ca2"><td class="memItemLeft" align="right" valign="top">typedef next_layer_type::lowest_layer_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a6b664149066b698269db4e2f4e846ca2">lowest_layer_type</a></td></tr>
<tr class="memdesc:a6b664149066b698269db4e2f4e846ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the lowest layer.  <a href="#a6b664149066b698269db4e2f4e846ca2">More...</a><br /></td></tr>
<tr class="separator:a6b664149066b698269db4e2f4e846ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e027ffad5f6a2acd99689211e717ac5"><td class="memItemLeft" align="right" valign="top">typedef Service&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a2e027ffad5f6a2acd99689211e717ac5">service_type</a></td></tr>
<tr class="memdesc:a2e027ffad5f6a2acd99689211e717ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the service that will be used to provide stream operations.  <a href="#a2e027ffad5f6a2acd99689211e717ac5">More...</a><br /></td></tr>
<tr class="separator:a2e027ffad5f6a2acd99689211e717ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965fd8deeebbf308d18fbac925009d8d"><td class="memItemLeft" align="right" valign="top">typedef service_type::impl_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a965fd8deeebbf308d18fbac925009d8d">impl_type</a></td></tr>
<tr class="memdesc:a965fd8deeebbf308d18fbac925009d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native implementation type of the stream.  <a href="#a965fd8deeebbf308d18fbac925009d8d">More...</a><br /></td></tr>
<tr class="separator:a965fd8deeebbf308d18fbac925009d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classasio_1_1ssl_1_1stream__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classasio_1_1ssl_1_1stream__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classasio_1_1ssl_1_1stream__base.html">asio::ssl::stream_base</a></td></tr>
<tr class="memitem:a2f18813d3860bc8aee99249834d7c320 inherit pub_types_classasio_1_1ssl_1_1stream__base"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> { <a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320a68134fb041cb11ffe46e248ed1e1d73f">client</a>, 
<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320a2f9bac13b8adb5945e7436945061d090">server</a>
 }<tr class="memdesc:a2f18813d3860bc8aee99249834d7c320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different handshake types.  <a href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">More...</a><br /></td></tr>
<tr class="separator:a2f18813d3860bc8aee99249834d7c320 inherit pub_types_classasio_1_1ssl_1_1stream__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9dba46a8e681a91084c5b38734fc380f"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Context_Service &gt; </td></tr>
<tr class="memitem:a9dba46a8e681a91084c5b38734fc380f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a9dba46a8e681a91084c5b38734fc380f">stream</a> (Arg &amp;arg, <a class="el" href="classasio_1_1ssl_1_1old_1_1basic__context.html">basic_context</a>&lt; Context_Service &gt; &amp;<a class="el" href="classasio_1_1ssl_1_1context.html">context</a>)</td></tr>
<tr class="memdesc:a9dba46a8e681a91084c5b38734fc380f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a stream.  <a href="#a9dba46a8e681a91084c5b38734fc380f">More...</a><br /></td></tr>
<tr class="separator:a9dba46a8e681a91084c5b38734fc380f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab930e318ba05be52b65007769a9e2409"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ab930e318ba05be52b65007769a9e2409">~stream</a> ()</td></tr>
<tr class="memdesc:ab930e318ba05be52b65007769a9e2409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab930e318ba05be52b65007769a9e2409">More...</a><br /></td></tr>
<tr class="separator:ab930e318ba05be52b65007769a9e2409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f0be52be35bcef5ac6ae3d42f0f592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1io__service.html">asio::io_service</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ad5f0be52be35bcef5ac6ae3d42f0f592">get_io_service</a> ()</td></tr>
<tr class="memdesc:ad5f0be52be35bcef5ac6ae3d42f0f592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> associated with the object.  <a href="#ad5f0be52be35bcef5ac6ae3d42f0f592">More...</a><br /></td></tr>
<tr class="separator:ad5f0be52be35bcef5ac6ae3d42f0f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32040331ac2eb6aa5098aa02316bb9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a71ae7adcbd44cae6750157541c2ddf8e">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a32040331ac2eb6aa5098aa02316bb9d8">next_layer</a> ()</td></tr>
<tr class="memdesc:a32040331ac2eb6aa5098aa02316bb9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the next layer.  <a href="#a32040331ac2eb6aa5098aa02316bb9d8">More...</a><br /></td></tr>
<tr class="separator:a32040331ac2eb6aa5098aa02316bb9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48e43adf4001a1a318d76213fd7186d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a6b664149066b698269db4e2f4e846ca2">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ac48e43adf4001a1a318d76213fd7186d">lowest_layer</a> ()</td></tr>
<tr class="memdesc:ac48e43adf4001a1a318d76213fd7186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#ac48e43adf4001a1a318d76213fd7186d">More...</a><br /></td></tr>
<tr class="separator:ac48e43adf4001a1a318d76213fd7186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab029c9d927db0140d70c6730226aad03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a6b664149066b698269db4e2f4e846ca2">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ab029c9d927db0140d70c6730226aad03">lowest_layer</a> () const </td></tr>
<tr class="memdesc:ab029c9d927db0140d70c6730226aad03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the lowest layer.  <a href="#ab029c9d927db0140d70c6730226aad03">More...</a><br /></td></tr>
<tr class="separator:ab029c9d927db0140d70c6730226aad03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d24d7329411233167125d82b6d38bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a965fd8deeebbf308d18fbac925009d8d">impl_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ac8d24d7329411233167125d82b6d38bf">impl</a> ()</td></tr>
<tr class="memdesc:ac8d24d7329411233167125d82b6d38bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying implementation in the native type.  <a href="#ac8d24d7329411233167125d82b6d38bf">More...</a><br /></td></tr>
<tr class="separator:ac8d24d7329411233167125d82b6d38bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326a75224a55b43ac12d2676d465958c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a326a75224a55b43ac12d2676d465958c">handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type)</td></tr>
<tr class="memdesc:a326a75224a55b43ac12d2676d465958c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SSL handshaking.  <a href="#a326a75224a55b43ac12d2676d465958c">More...</a><br /></td></tr>
<tr class="separator:a326a75224a55b43ac12d2676d465958c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d612fa88c243e25dad7e1db1428973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ad4d612fa88c243e25dad7e1db1428973">handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ad4d612fa88c243e25dad7e1db1428973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SSL handshaking.  <a href="#ad4d612fa88c243e25dad7e1db1428973">More...</a><br /></td></tr>
<tr class="separator:ad4d612fa88c243e25dad7e1db1428973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d27ecfa0483d789afcf60638db66d76"><td class="memTemplParams" colspan="2">template&lt;typename HandshakeHandler &gt; </td></tr>
<tr class="memitem:a0d27ecfa0483d789afcf60638db66d76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a0d27ecfa0483d789afcf60638db66d76">async_handshake</a> (<a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a> type, HandshakeHandler handler)</td></tr>
<tr class="memdesc:a0d27ecfa0483d789afcf60638db66d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous SSL handshake.  <a href="#a0d27ecfa0483d789afcf60638db66d76">More...</a><br /></td></tr>
<tr class="separator:a0d27ecfa0483d789afcf60638db66d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6067ec453251827936bcc62058a6c592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a6067ec453251827936bcc62058a6c592">shutdown</a> ()</td></tr>
<tr class="memdesc:a6067ec453251827936bcc62058a6c592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down SSL on the stream.  <a href="#a6067ec453251827936bcc62058a6c592">More...</a><br /></td></tr>
<tr class="separator:a6067ec453251827936bcc62058a6c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72e660505e1880675fe99d6c7dc5b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ac72e660505e1880675fe99d6c7dc5b9c">shutdown</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ac72e660505e1880675fe99d6c7dc5b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down SSL on the stream.  <a href="#ac72e660505e1880675fe99d6c7dc5b9c">More...</a><br /></td></tr>
<tr class="separator:ac72e660505e1880675fe99d6c7dc5b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523d381e2548587dc0ac216292572f11"><td class="memTemplParams" colspan="2">template&lt;typename ShutdownHandler &gt; </td></tr>
<tr class="memitem:a523d381e2548587dc0ac216292572f11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a523d381e2548587dc0ac216292572f11">async_shutdown</a> (ShutdownHandler handler)</td></tr>
<tr class="memdesc:a523d381e2548587dc0ac216292572f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously shut down SSL on the stream.  <a href="#a523d381e2548587dc0ac216292572f11">More...</a><br /></td></tr>
<tr class="separator:a523d381e2548587dc0ac216292572f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c46226ee7670e8b246045d7083f3dc3"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a5c46226ee7670e8b246045d7083f3dc3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a5c46226ee7670e8b246045d7083f3dc3">write_some</a> (const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:a5c46226ee7670e8b246045d7083f3dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the stream.  <a href="#a5c46226ee7670e8b246045d7083f3dc3">More...</a><br /></td></tr>
<tr class="separator:a5c46226ee7670e8b246045d7083f3dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e60094fcd1c78f221157b2d1e7ecaa9"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a8e60094fcd1c78f221157b2d1e7ecaa9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a8e60094fcd1c78f221157b2d1e7ecaa9">write_some</a> (const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a8e60094fcd1c78f221157b2d1e7ecaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the stream.  <a href="#a8e60094fcd1c78f221157b2d1e7ecaa9">More...</a><br /></td></tr>
<tr class="separator:a8e60094fcd1c78f221157b2d1e7ecaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ca80ae61f3a80ef7fdc5eca375f85e"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , typename WriteHandler &gt; </td></tr>
<tr class="memitem:a92ca80ae61f3a80ef7fdc5eca375f85e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a92ca80ae61f3a80ef7fdc5eca375f85e">async_write_some</a> (const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, WriteHandler handler)</td></tr>
<tr class="memdesc:a92ca80ae61f3a80ef7fdc5eca375f85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous write.  <a href="#a92ca80ae61f3a80ef7fdc5eca375f85e">More...</a><br /></td></tr>
<tr class="separator:a92ca80ae61f3a80ef7fdc5eca375f85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af187c4f0f580a4941538d9c9c43ef5"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a0af187c4f0f580a4941538d9c9c43ef5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a0af187c4f0f580a4941538d9c9c43ef5">read_some</a> (const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:a0af187c4f0f580a4941538d9c9c43ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the stream.  <a href="#a0af187c4f0f580a4941538d9c9c43ef5">More...</a><br /></td></tr>
<tr class="separator:a0af187c4f0f580a4941538d9c9c43ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbd732b0ea3986dd05e76aa493e5b65"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a8cbd732b0ea3986dd05e76aa493e5b65"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a8cbd732b0ea3986dd05e76aa493e5b65">read_some</a> (const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a8cbd732b0ea3986dd05e76aa493e5b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the stream.  <a href="#a8cbd732b0ea3986dd05e76aa493e5b65">More...</a><br /></td></tr>
<tr class="separator:a8cbd732b0ea3986dd05e76aa493e5b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1826635812b110e43aab623bc4c884b7"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:a1826635812b110e43aab623bc4c884b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a1826635812b110e43aab623bc4c884b7">async_read_some</a> (const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, ReadHandler handler)</td></tr>
<tr class="memdesc:a1826635812b110e43aab623bc4c884b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous read.  <a href="#a1826635812b110e43aab623bc4c884b7">More...</a><br /></td></tr>
<tr class="separator:a1826635812b110e43aab623bc4c884b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a04711b312236f6e3d07c2b9717fefc"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a5a04711b312236f6e3d07c2b9717fefc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a5a04711b312236f6e3d07c2b9717fefc">peek</a> (const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:a5a04711b312236f6e3d07c2b9717fefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#a5a04711b312236f6e3d07c2b9717fefc">More...</a><br /></td></tr>
<tr class="separator:a5a04711b312236f6e3d07c2b9717fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f1136af69b6f6d4c4eb5ae9824343b"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a60f1136af69b6f6d4c4eb5ae9824343b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a60f1136af69b6f6d4c4eb5ae9824343b">peek</a> (const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a60f1136af69b6f6d4c4eb5ae9824343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#a60f1136af69b6f6d4c4eb5ae9824343b">More...</a><br /></td></tr>
<tr class="separator:a60f1136af69b6f6d4c4eb5ae9824343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7146a346f17d1411adca213934632a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a0a7146a346f17d1411adca213934632a">in_avail</a> ()</td></tr>
<tr class="memdesc:a0a7146a346f17d1411adca213934632a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#a0a7146a346f17d1411adca213934632a">More...</a><br /></td></tr>
<tr class="separator:a0a7146a346f17d1411adca213934632a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1de782526b419d58092c1a5d69bb0e5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#ae1de782526b419d58092c1a5d69bb0e5">in_avail</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ae1de782526b419d58092c1a5d69bb0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#ae1de782526b419d58092c1a5d69bb0e5">More...</a><br /></td></tr>
<tr class="separator:ae1de782526b419d58092c1a5d69bb0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classasio_1_1ssl_1_1stream__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classasio_1_1ssl_1_1stream__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classasio_1_1ssl_1_1stream__base.html">asio::ssl::stream_base</a></td></tr>
<tr class="memitem:af44f60fc18949a1235701c7ab76848b8 inherit pro_methods_classasio_1_1ssl_1_1stream__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#af44f60fc18949a1235701c7ab76848b8">~stream_base</a> ()</td></tr>
<tr class="memdesc:af44f60fc18949a1235701c7ab76848b8 inherit pro_methods_classasio_1_1ssl_1_1stream__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor to prevent deletion through this type.  <a href="#af44f60fc18949a1235701c7ab76848b8">More...</a><br /></td></tr>
<tr class="separator:af44f60fc18949a1235701c7ab76848b8 inherit pro_methods_classasio_1_1ssl_1_1stream__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Stream, typename Service = old::stream_service&gt;<br />
class asio::ssl::old::stream&lt; Stream, Service &gt;</h3>

<p>Provides stream-oriented functionality using SSL. </p>
<p>The stream class template provides asynchronous and blocking stream-oriented functionality using SSL.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br />
<em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To use the SSL stream template with an <a class="el" href="classasio_1_1ip_1_1tcp.html#a6f5bf95251747bb81d75784387938d6a" title="The TCP socket type. ">ip::tcp::socket</a>, you would write: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1io__service.html">asio::io_service</a> io_service;</div>
<div class="line"><a class="code" href="classasio_1_1ssl_1_1context.html">asio::ssl::context</a> context(io_service, <a class="code" href="classasio_1_1ssl_1_1context__base.html#ac37d498266e3b13607f011ace6417525ae478c3ede58b50c99d6c6ff9ed7c0124">asio::ssl::context::sslv23</a>);</div>
<div class="line"><a class="code" href="classasio_1_1ssl_1_1stream.html">asio::ssl::stream&lt;asio::ip::tcp::socket&gt;</a> sock(io_service, context);</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>AsyncReadStream, AsyncWriteStream, Stream, SyncRead_Stream, SyncWriteStream. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00056">56</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a965fd8deeebbf308d18fbac925009d8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef service_type::impl_type <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::<a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a965fd8deeebbf308d18fbac925009d8d">impl_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The native implementation type of the stream. </p>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00071">71</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b664149066b698269db4e2f4e846ca2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef next_layer_type::lowest_layer_type <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::<a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a6b664149066b698269db4e2f4e846ca2">lowest_layer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the lowest layer. </p>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00065">65</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71ae7adcbd44cae6750157541c2ddf8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef remove_reference&lt;Stream&gt;::type <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::<a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a71ae7adcbd44cae6750157541c2ddf8e">next_layer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the next layer. </p>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00062">62</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e027ffad5f6a2acd99689211e717ac5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Service <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::<a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a2e027ffad5f6a2acd99689211e717ac5">service_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the service that will be used to provide stream operations. </p>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00068">68</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9dba46a8e681a91084c5b38734fc380f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename Arg , typename Context_Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::<a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1old_1_1basic__context.html">basic_context</a>&lt; Context_Service &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a stream. </p>
<p>This constructor creates a stream and initialises the underlying stream object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument to be passed to initialise the underlying stream.</td></tr>
    <tr><td class="paramname">context</td><td>The SSL context to be used for the stream. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00083">83</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab930e318ba05be52b65007769a9e2409"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::~<a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00092">92</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0d27ecfa0483d789afcf60638db66d76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename HandshakeHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an asynchronous SSL handshake. </p>
<p>This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div>
<div class="line">); </div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00209">209</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1826635812b110e43aab623bc4c884b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an asynchronous read. </p>
<p>This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes read.</span></div>
<div class="line">); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The async_read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__async__read.html">asio::async_read</a> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00407">407</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a523d381e2548587dc0ac216292572f11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename ShutdownHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::async_shutdown </td>
          <td>(</td>
          <td class="paramtype">ShutdownHandler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously shut down SSL on the stream. </p>
<p>This function is used to asynchronously shut down SSL on the stream. This function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div>
<div class="line">); </div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00253">253</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92ca80ae61f3a80ef7fdc5eca375f85e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence , typename WriteHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an asynchronous write. </p>
<p>This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written.</span></div>
<div class="line">); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The async_write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__async__write.html">asio::async_write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00329">329</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5f0be52be35bcef5ac6ae3d42f0f592"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1io__service.html">asio::io_service</a>&amp; <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> associated with the object. </p>
<p>This function may be used to obtain the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> object that the stream uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> object that stream will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00105">105</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a326a75224a55b43ac12d2676d465958c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SSL handshaking. </p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00170">170</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4d612fa88c243e25dad7e1db1428973"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1ssl_1_1stream__base.html#a2f18813d3860bc8aee99249834d7c320">handshake_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SSL handshaking. </p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00187">187</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8d24d7329411233167125d82b6d38bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a965fd8deeebbf308d18fbac925009d8d">impl_type</a> <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying implementation in the native type. </p>
<p>This function may be used to obtain the underlying implementation of the context. This is intended to allow access to stream functionality that is not otherwise provided. </p>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00155">155</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a7146a346f17d1411adca213934632a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::in_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the amount of data that may be read without blocking. </p>
<p>This function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes of data that can be read without blocking.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00462">462</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae1de782526b419d58092c1a5d69bb0e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::in_avail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the amount of data that may be read without blocking. </p>
<p>This function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes of data that can be read without blocking. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00479">479</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac48e43adf4001a1a318d76213fd7186d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a6b664149066b698269db4e2f4e846ca2">lowest_layer_type</a>&amp; <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p>This function returns a reference to the lowest layer in a stack of stream layers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00131">131</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab029c9d927db0140d70c6730226aad03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a6b664149066b698269db4e2f4e846ca2">lowest_layer_type</a>&amp; <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the lowest layer. </p>
<p>This function returns a const reference to the lowest layer in a stack of stream layers.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00144">144</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32040331ac2eb6aa5098aa02316bb9d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html#a71ae7adcbd44cae6750157541c2ddf8e">next_layer_type</a>&amp; <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the next layer. </p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00118">118</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a04711b312236f6e3d07c2b9717fefc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the incoming data on the stream. </p>
<p>This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00426">426</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60f1136af69b6f6d4c4eb5ae9824343b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the incoming data on the stream. </p>
<p>This function is used to peek at the incoming data on the stream, withoutxi removing it from the input queue. The function call will block until data has been read successfully or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. Returns 0 if an error occurred. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00447">447</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0af187c4f0f580a4941538d9c9c43ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data from the stream. </p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__read.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00352">352</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cbd732b0ea3986dd05e76aa493e5b65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data from the stream. </p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__read.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00377">377</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6067ec453251827936bcc62058a6c592"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shut down SSL on the stream. </p>
<p>This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00221">221</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac72e660505e1880675fe99d6c7dc5b9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shut down SSL on the stream. </p>
<p>This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00235">235</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c46226ee7670e8b246045d7083f3dc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some data to the stream. </p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00275">275</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e60094fcd1c78f221157b2d1e7ecaa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename Service  = old::stream_service&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">asio::ssl::old::stream</a>&lt; Stream, Service &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some data to the stream. </p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

<p>Definition at line <a class="el" href="old_2stream_8hpp_source.html#l00300">300</a> of file <a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ext/asio/ssl/old/<a class="el" href="old_2stream_8hpp_source.html">stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceasio.html">asio</a></li><li class="navelem"><a class="el" href="namespaceasio_1_1ssl.html">ssl</a></li><li class="navelem"><a class="el" href="namespaceasio_1_1ssl_1_1old.html">old</a></li><li class="navelem"><a class="el" href="classasio_1_1ssl_1_1old_1_1stream.html">stream</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
