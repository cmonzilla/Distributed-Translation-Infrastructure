<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Basic Phrase Based Decoding: asio Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="owl.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Basic Phrase Based Decoding
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ client/server language translation infrastructure</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceasio.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">asio Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceasio_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1error"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1generic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1generic.html">generic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ip"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ip.html">ip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ssl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ssl.html">ssl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result.html">async_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for customising the behaviour of an initiating function.  <a href="classasio_1_1async__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1coro__handler_3_01_handler_00_01_t_01_4_01_4.html">async_result&lt; detail::coro_handler&lt; Handler, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1coro__handler_3_01_handler_00_01void_01_4_01_4.html">async_result&lt; detail::coro_handler&lt; Handler, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01detail_1_1promise__handler_3_01_t_01_4_01_4.html">async_result&lt; detail::promise_handler&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__datagram__socket.html">basic_datagram_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides datagram-oriented socket functionality.  <a href="classasio_1_1basic__datagram__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__io__object.html">basic_io_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all I/O objects.  <a href="classasio_1_1basic__io__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__raw__socket.html">basic_raw_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw-oriented socket functionality.  <a href="classasio_1_1basic__raw__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__seq__packet__socket.html">basic_seq_packet_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides sequenced packet socket functionality.  <a href="classasio_1_1basic__seq__packet__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides signal functionality.  <a href="classasio_1_1basic__signal__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides socket functionality.  <a href="classasio_1_1basic__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the ability to accept new connections.  <a href="classasio_1_1basic__socket__acceptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__iostream.html">basic_socket_iostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream interface for a socket.  <a href="classasio_1_1basic__socket__iostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__streambuf.html">basic_socket_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream streambuf for a socket.  <a href="classasio_1_1basic__socket__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__stream__socket.html">basic_stream_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides stream-oriented socket functionality.  <a href="classasio_1_1basic__stream__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically resizable buffer class based on std::streambuf.  <a href="classasio_1_1basic__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="classasio_1_1basic__waitable__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context object the represents the currently executing coroutine.  <a href="classasio_1_1basic__yield__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream.  <a href="classasio_1_1buffered__read__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__stream.html">buffered_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream.  <a href="classasio_1_1buffered__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream.  <a href="classasio_1_1buffered__write__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator over the bytes in a buffer sequence.  <a href="classasio_1_1buffers__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that cannot be modified.  <a href="classasio_1_1const__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1coroutine.html">coroutine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides support for implementing stackless coroutines.  <a href="classasio_1_1coroutine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1datagram__socket__service.html">datagram_socket_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default service implementation for a datagram socket.  <a href="classasio_1_1datagram__socket__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1enable__if.html">enable_if</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1error__category.html">error_category</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all error categories.  <a href="classasio_1_1error__category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1error__code.html">error_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to represent an error code value.  <a href="classasio_1_1error__code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type.html">handler_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler type traits provided for all handlers.  <a href="structasio_1_1handler__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01basic__yield__context_3_01_handler_01_4_00_01_01_01_01_01_01_01_4293f21a96d71a94577a209dcb83a1de.html">handler_type&lt; basic_yield_context&lt; Handler &gt;,           ReturnType(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01basic__yield__context_3_01_handler_01_4_00_01_01_01_01_01_01_01_d15b502de1534464d7abfd193f1b4967.html">handler_type&lt; basic_yield_context&lt; Handler &gt;,           ReturnType(asio::error_code, Arg2)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01basic__yield__context_3_01_handler_01_4_00_01_return_type_07_arg1_08_4.html">handler_type&lt; basic_yield_context&lt; Handler &gt;, ReturnType(Arg1)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01const_01_handler_01_6_00_01_signature_01_4.html">handler_type&lt; const Handler &amp;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01const_01_handler_00_01_signature_01_4.html">handler_type&lt; const Handler, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01const_01volatile_01_handler_01_6_00_01_signature_01_4.html">handler_type&lt; const volatile Handler &amp;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01const_01volatile_01_handler_00_01_signature_01_4.html">handler_type&lt; const volatile Handler, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01_handler_01_6_00_01_signature_01_4.html">handler_type&lt; Handler &amp;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01_return_type_07_arg1_08_00_01_signature_01_4.html">handler_type&lt; ReturnType(Arg1), Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01_return_type_07_arg1_00_01_arg2_08_00_01_signature_01_4.html">handler_type&lt; ReturnType(Arg1, Arg2), Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01_return_type_07_arg1_00_01_arg2_00_01_arg3_08_00_01_signature_01_4.html">handler_type&lt; ReturnType(Arg1, Arg2, Arg3), Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01_return_type_07_arg1_00_01_arg2_00_01_arg3_00_01_arg4_08_00_01_signature_01_4.html">handler_type&lt; ReturnType(Arg1, Arg2, Arg3, Arg4), Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01_return_type_07_arg1_00_01_arg2_00_01_arg3_00_01_arg4_00_01_arg5_08_00_01_signature_01_4.html">handler_type&lt; ReturnType(Arg1, Arg2, Arg3, Arg4, Arg5), Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01use__future__t_3_01_allocator_01_4_00_01_01_01_01_01_01_01_01_01e03a2a25b6ea2f5e6fbc374eca266e19.html">handler_type&lt; use_future_t&lt; Allocator &gt;,           ReturnType(asio::error_code)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01use__future__t_3_01_allocator_01_4_00_01_01_01_01_01_01_01_01_01912bb47ba4497b53d32e350e5bfa0a51.html">handler_type&lt; use_future_t&lt; Allocator &gt;,           ReturnType(asio::error_code, Arg2)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01use__future__t_3_01_allocator_01_4_00_01_return_type_07_arg1_08_4.html">handler_type&lt; use_future_t&lt; Allocator &gt;, ReturnType(Arg1)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01volatile_01_handler_01_6_00_01_signature_01_4.html">handler_type&lt; volatile Handler &amp;, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type_3_01volatile_01_handler_00_01_signature_01_4.html">handler_type&lt; volatile Handler, Signature &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1invalid__service__owner.html">invalid_service_owner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1io__service.html">io_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core I/O functionality.  <a href="classasio_1_1io__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__read__buffered.html">is_read_buffered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__write__buffered.html">is_write_buffered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that can be modified.  <a href="classasio_1_1mutable__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1null__buffers.html">null_buffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1raw__socket__service.html">raw_socket_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default service implementation for a raw socket.  <a href="classasio_1_1raw__socket__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1seq__packet__socket__service.html">seq_packet_socket_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default service implementation for a sequenced packet socket.  <a href="classasio_1_1seq__packet__socket__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1service__already__exists.html">service_already_exists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when trying to add a duplicate service to an <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a>.  <a href="classasio_1_1service__already__exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1signal__set__service.html">signal_set_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default service implementation for a signal set.  <a href="classasio_1_1signal__set__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__acceptor__service.html">socket_acceptor_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default service implementation for a socket acceptor.  <a href="classasio_1_1socket__acceptor__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html">socket_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1stream__socket__service.html">stream_socket_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default service implementation for a stream socket.  <a href="classasio_1_1stream__socket__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__error.html">system_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread.html">thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple abstraction for starting threads.  <a href="classasio_1_1thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1use__future__t.html">use_future_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to specify that an asynchronous operation should return a future.  <a href="classasio_1_1use__future__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1wait__traits.html">wait_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait traits suitable for use with the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality. ">basic_waitable_timer</a> class template.  <a href="structasio_1_1wait__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1waitable__timer__service.html">waitable_timer_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default service implementation for a timer.  <a href="classasio_1_1waitable__timer__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4f135fc124cc60e4e00dc2dbb309f354"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4f135fc124cc60e4e00dc2dbb309f354">signal_set</a></td></tr>
<tr class="memdesc:a4f135fc124cc60e4e00dc2dbb309f354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of a signal set.  <a href="#a4f135fc124cc60e4e00dc2dbb309f354">More...</a><br /></td></tr>
<tr class="separator:a4f135fc124cc60e4e00dc2dbb309f354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e285c1148c5ff12c443f3bfa9bdd9a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; <a class="el" href="classasio_1_1detail_1_1wrapped__handler.html">detail::wrapped_handler</a>&lt; <a class="el" href="classasio_1_1io__service_1_1strand.html">io_service::strand</a>, void(*)(), <a class="el" href="structasio_1_1detail_1_1is__continuation__if__running.html">detail::is_continuation_if_running</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a41e285c1148c5ff12c443f3bfa9bdd9a">yield_context</a></td></tr>
<tr class="separator:a41e285c1148c5ff12c443f3bfa9bdd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be3fa00c86ab58ba41aabe8fcbf11be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1io__service_1_1strand.html">asio::io_service::strand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3be3fa00c86ab58ba41aabe8fcbf11be">strand</a></td></tr>
<tr class="separator:a3be3fa00c86ab58ba41aabe8fcbf11be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7ba348943527312eeace3492bf32ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6a7ba348943527312eeace3492bf32ee">streambuf</a></td></tr>
<tr class="memdesc:a6a7ba348943527312eeace3492bf32ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a>.  <a href="#a6a7ba348943527312eeace3492bf32ee">More...</a><br /></td></tr>
<tr class="separator:a6a7ba348943527312eeace3492bf32ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1cf92f0e55c9196057b27a1d35997824"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a1cf92f0e55c9196057b27a1d35997824"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1cf92f0e55c9196057b27a1d35997824">read_size_helper</a> (<a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;sb, std::size_t max_size)</td></tr>
<tr class="separator:a1cf92f0e55c9196057b27a1d35997824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8b5f116fbb66004b6d0ba8ee39c3d5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__size.html#gabe8b5f116fbb66004b6d0ba8ee39c3d5">buffer_size</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:gabe8b5f116fbb66004b6d0ba8ee39c3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes in a modifiable buffer.  <a href="group__buffer__size.html#gabe8b5f116fbb66004b6d0ba8ee39c3d5">More...</a><br /></td></tr>
<tr class="separator:gabe8b5f116fbb66004b6d0ba8ee39c3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51568d795ef652942a495a95397617a6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__size.html#ga51568d795ef652942a495a95397617a6">buffer_size</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga51568d795ef652942a495a95397617a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes in a modifiable buffer.  <a href="group__buffer__size.html#ga51568d795ef652942a495a95397617a6">More...</a><br /></td></tr>
<tr class="separator:ga51568d795ef652942a495a95397617a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d80aa96b2589938b695deb42eda2c7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__size.html#ga41d80aa96b2589938b695deb42eda2c7">buffer_size</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga41d80aa96b2589938b695deb42eda2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes in a non-modifiable buffer.  <a href="group__buffer__size.html#ga41d80aa96b2589938b695deb42eda2c7">More...</a><br /></td></tr>
<tr class="separator:ga41d80aa96b2589938b695deb42eda2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab096963a970c5183e81c428e9d98a65f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__size.html#gab096963a970c5183e81c428e9d98a65f">buffer_size</a> (const <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:gab096963a970c5183e81c428e9d98a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes in a non-modifiable buffer.  <a href="group__buffer__size.html#gab096963a970c5183e81c428e9d98a65f">More...</a><br /></td></tr>
<tr class="separator:gab096963a970c5183e81c428e9d98a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a60e9305e8e7193de581172f360657b"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:ga2a60e9305e8e7193de581172f360657b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__size.html#ga2a60e9305e8e7193de581172f360657b">buffer_size</a> (const BufferSequence &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga2a60e9305e8e7193de581172f360657b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bytes in a buffer sequence.  <a href="group__buffer__size.html#ga2a60e9305e8e7193de581172f360657b">More...</a><br /></td></tr>
<tr class="separator:ga2a60e9305e8e7193de581172f360657b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6faa5f9daa2512cc9c3cefa8b5ab0704"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:ga6faa5f9daa2512cc9c3cefa8b5ab0704"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__cast.html#ga6faa5f9daa2512cc9c3cefa8b5ab0704">buffer_cast</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga6faa5f9daa2512cc9c3cefa8b5ab0704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <a href="group__buffer__cast.html#ga6faa5f9daa2512cc9c3cefa8b5ab0704">More...</a><br /></td></tr>
<tr class="separator:ga6faa5f9daa2512cc9c3cefa8b5ab0704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc1fdf63b08b041819a9e18423ef630"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:ga0bc1fdf63b08b041819a9e18423ef630"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__cast.html#ga0bc1fdf63b08b041819a9e18423ef630">buffer_cast</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga0bc1fdf63b08b041819a9e18423ef630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <a href="group__buffer__cast.html#ga0bc1fdf63b08b041819a9e18423ef630">More...</a><br /></td></tr>
<tr class="separator:ga0bc1fdf63b08b041819a9e18423ef630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed66e401559cbfd19595392f653b47c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga1ed66e401559cbfd19595392f653b47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">More...</a><br /></td></tr>
<tr class="separator:ga1ed66e401559cbfd19595392f653b47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93a06eac8bd6d1db394ba92e260b9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf93a06eac8bd6d1db394ba92e260b9fa">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gaf93a06eac8bd6d1db394ba92e260b9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#gaf93a06eac8bd6d1db394ba92e260b9fa">More...</a><br /></td></tr>
<tr class="separator:gaf93a06eac8bd6d1db394ba92e260b9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00b079c860c589f80a312b975828780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gac00b079c860c589f80a312b975828780">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:gac00b079c860c589f80a312b975828780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#gac00b079c860c589f80a312b975828780">More...</a><br /></td></tr>
<tr class="separator:gac00b079c860c589f80a312b975828780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2a3b8cbb0e8aefbc870d5f43cf5872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gafe2a3b8cbb0e8aefbc870d5f43cf5872">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gafe2a3b8cbb0e8aefbc870d5f43cf5872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#gafe2a3b8cbb0e8aefbc870d5f43cf5872">More...</a><br /></td></tr>
<tr class="separator:gafe2a3b8cbb0e8aefbc870d5f43cf5872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa066734007c417692255c8f515f0fb01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa066734007c417692255c8f515f0fb01">buffer</a> (void *data, std::size_t size_in_bytes)</td></tr>
<tr class="memdesc:gaa066734007c417692255c8f515f0fb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <a href="group__buffer.html#gaa066734007c417692255c8f515f0fb01">More...</a><br /></td></tr>
<tr class="separator:gaa066734007c417692255c8f515f0fb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b6109423e7efc76b46b8d1337a5b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa6b6109423e7efc76b46b8d1337a5b0f">buffer</a> (const void *data, std::size_t size_in_bytes)</td></tr>
<tr class="memdesc:gaa6b6109423e7efc76b46b8d1337a5b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <a href="group__buffer.html#gaa6b6109423e7efc76b46b8d1337a5b0f">More...</a><br /></td></tr>
<tr class="separator:gaa6b6109423e7efc76b46b8d1337a5b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a348932d9b7ffda26ff318191489fd8"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga9a348932d9b7ffda26ff318191489fd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga9a348932d9b7ffda26ff318191489fd8">buffer</a> (PodType(&amp;data)[N])</td></tr>
<tr class="memdesc:ga9a348932d9b7ffda26ff318191489fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga9a348932d9b7ffda26ff318191489fd8">More...</a><br /></td></tr>
<tr class="separator:ga9a348932d9b7ffda26ff318191489fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga817f0fd9a7e1eebab155ccf5b62456f0">buffer</a> (PodType(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga817f0fd9a7e1eebab155ccf5b62456f0">More...</a><br /></td></tr>
<tr class="separator:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73b5385bad9b7c92afce06d92c11f1e"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gae73b5385bad9b7c92afce06d92c11f1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gae73b5385bad9b7c92afce06d92c11f1e">buffer</a> (const PodType(&amp;data)[N])</td></tr>
<tr class="memdesc:gae73b5385bad9b7c92afce06d92c11f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gae73b5385bad9b7c92afce06d92c11f1e">More...</a><br /></td></tr>
<tr class="separator:gae73b5385bad9b7c92afce06d92c11f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37e6d30503997261200b1c9a2492182"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gae37e6d30503997261200b1c9a2492182"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gae37e6d30503997261200b1c9a2492182">buffer</a> (const PodType(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gae37e6d30503997261200b1c9a2492182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gae37e6d30503997261200b1c9a2492182">More...</a><br /></td></tr>
<tr class="separator:gae37e6d30503997261200b1c9a2492182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec66696edfddf306d7c91aba75b1723"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gafec66696edfddf306d7c91aba75b1723"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gafec66696edfddf306d7c91aba75b1723">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data)</td></tr>
<tr class="memdesc:gafec66696edfddf306d7c91aba75b1723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gafec66696edfddf306d7c91aba75b1723">More...</a><br /></td></tr>
<tr class="separator:gafec66696edfddf306d7c91aba75b1723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gabcdc30c4b4b6a28885f65e7c8fe08cc2">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gabcdc30c4b4b6a28885f65e7c8fe08cc2">More...</a><br /></td></tr>
<tr class="separator:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b564725e9315afaad270e46161ac21c"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga7b564725e9315afaad270e46161ac21c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga7b564725e9315afaad270e46161ac21c">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data)</td></tr>
<tr class="memdesc:ga7b564725e9315afaad270e46161ac21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga7b564725e9315afaad270e46161ac21c">More...</a><br /></td></tr>
<tr class="separator:ga7b564725e9315afaad270e46161ac21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf0529bedd017b4b01fd0920e35ed22cd">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf0529bedd017b4b01fd0920e35ed22cd">More...</a><br /></td></tr>
<tr class="separator:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee4fc886d2abc070fbabc77ebeb508d"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gacee4fc886d2abc070fbabc77ebeb508d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gacee4fc886d2abc070fbabc77ebeb508d">buffer</a> (const <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data)</td></tr>
<tr class="memdesc:gacee4fc886d2abc070fbabc77ebeb508d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gacee4fc886d2abc070fbabc77ebeb508d">More...</a><br /></td></tr>
<tr class="separator:gacee4fc886d2abc070fbabc77ebeb508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e496b244e3999f2035c29043cd2ff9"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gac7e496b244e3999f2035c29043cd2ff9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gac7e496b244e3999f2035c29043cd2ff9">buffer</a> (const <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gac7e496b244e3999f2035c29043cd2ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gac7e496b244e3999f2035c29043cd2ff9">More...</a><br /></td></tr>
<tr class="separator:gac7e496b244e3999f2035c29043cd2ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382ee4d2d0dd90e88e374e4344302749"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga382ee4d2d0dd90e88e374e4344302749"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga382ee4d2d0dd90e88e374e4344302749">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data)</td></tr>
<tr class="memdesc:ga382ee4d2d0dd90e88e374e4344302749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga382ee4d2d0dd90e88e374e4344302749">More...</a><br /></td></tr>
<tr class="separator:ga382ee4d2d0dd90e88e374e4344302749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gad0a0b6813e25e7bcce7fcfe32a5cdab9">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#gad0a0b6813e25e7bcce7fcfe32a5cdab9">More...</a><br /></td></tr>
<tr class="separator:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa908d4c98b0745c8c51540e153627f44"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa908d4c98b0745c8c51540e153627f44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa908d4c98b0745c8c51540e153627f44">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data)</td></tr>
<tr class="memdesc:gaa908d4c98b0745c8c51540e153627f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#gaa908d4c98b0745c8c51540e153627f44">More...</a><br /></td></tr>
<tr class="separator:gaa908d4c98b0745c8c51540e153627f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad172ef969f244d265d3cfcfea727b904"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:gad172ef969f244d265d3cfcfea727b904"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gad172ef969f244d265d3cfcfea727b904">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gad172ef969f244d265d3cfcfea727b904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#gad172ef969f244d265d3cfcfea727b904">More...</a><br /></td></tr>
<tr class="separator:gad172ef969f244d265d3cfcfea727b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe609d07578ac226c777107fbe51eff5"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:gafe609d07578ac226c777107fbe51eff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gafe609d07578ac226c777107fbe51eff5">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data)</td></tr>
<tr class="memdesc:gafe609d07578ac226c777107fbe51eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#gafe609d07578ac226c777107fbe51eff5">More...</a><br /></td></tr>
<tr class="separator:gafe609d07578ac226c777107fbe51eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04e7aa3e90adacebceb59007629e923"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa04e7aa3e90adacebceb59007629e923"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa04e7aa3e90adacebceb59007629e923">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gaa04e7aa3e90adacebceb59007629e923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#gaa04e7aa3e90adacebceb59007629e923">More...</a><br /></td></tr>
<tr class="separator:gaa04e7aa3e90adacebceb59007629e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bc8cbf49a91e58205de746721d614d8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga8bc8cbf49a91e58205de746721d614d8">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;source)</td></tr>
<tr class="memdesc:ga8bc8cbf49a91e58205de746721d614d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga8bc8cbf49a91e58205de746721d614d8">More...</a><br /></td></tr>
<tr class="separator:ga8bc8cbf49a91e58205de746721d614d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09726c974288624f654a593b06ba1a0c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga09726c974288624f654a593b06ba1a0c">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> &amp;source)</td></tr>
<tr class="memdesc:ga09726c974288624f654a593b06ba1a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga09726c974288624f654a593b06ba1a0c">More...</a><br /></td></tr>
<tr class="separator:ga09726c974288624f654a593b06ba1a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a03807f5083b423e1fff2173edf991"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gad7a03807f5083b423e1fff2173edf991">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;source)</td></tr>
<tr class="memdesc:gad7a03807f5083b423e1fff2173edf991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#gad7a03807f5083b423e1fff2173edf991">More...</a><br /></td></tr>
<tr class="separator:gad7a03807f5083b423e1fff2173edf991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed1b2c796b937a0b044df908ad4e3d8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga8ed1b2c796b937a0b044df908ad4e3d8">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;source)</td></tr>
<tr class="memdesc:ga8ed1b2c796b937a0b044df908ad4e3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga8ed1b2c796b937a0b044df908ad4e3d8">More...</a><br /></td></tr>
<tr class="separator:ga8ed1b2c796b937a0b044df908ad4e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2aab004dd723dc638aeb08552e4c9a9"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:gae2aab004dd723dc638aeb08552e4c9a9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gae2aab004dd723dc638aeb08552e4c9a9">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const ConstBufferSequence &amp;source)</td></tr>
<tr class="memdesc:gae2aab004dd723dc638aeb08552e4c9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer sequence to a target buffer.  <a href="group__buffer__copy.html#gae2aab004dd723dc638aeb08552e4c9a9">More...</a><br /></td></tr>
<tr class="separator:gae2aab004dd723dc638aeb08552e4c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579f9adb02c3bc0b597f6a7bff4cf18e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga579f9adb02c3bc0b597f6a7bff4cf18e">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;source)</td></tr>
<tr class="memdesc:ga579f9adb02c3bc0b597f6a7bff4cf18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga579f9adb02c3bc0b597f6a7bff4cf18e">More...</a><br /></td></tr>
<tr class="separator:ga579f9adb02c3bc0b597f6a7bff4cf18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12327c4bafb7677e99bb0358bfe22605"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga12327c4bafb7677e99bb0358bfe22605">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> &amp;source)</td></tr>
<tr class="memdesc:ga12327c4bafb7677e99bb0358bfe22605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga12327c4bafb7677e99bb0358bfe22605">More...</a><br /></td></tr>
<tr class="separator:ga12327c4bafb7677e99bb0358bfe22605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90d26f875c173b7a76b133f43b42820"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gad90d26f875c173b7a76b133f43b42820">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;source)</td></tr>
<tr class="memdesc:gad90d26f875c173b7a76b133f43b42820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#gad90d26f875c173b7a76b133f43b42820">More...</a><br /></td></tr>
<tr class="separator:gad90d26f875c173b7a76b133f43b42820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1f69957daad37a92d711b3d6f3d474"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gaae1f69957daad37a92d711b3d6f3d474">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;source)</td></tr>
<tr class="memdesc:gaae1f69957daad37a92d711b3d6f3d474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#gaae1f69957daad37a92d711b3d6f3d474">More...</a><br /></td></tr>
<tr class="separator:gaae1f69957daad37a92d711b3d6f3d474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a2817b703dafb592312891de669218"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:gaf4a2817b703dafb592312891de669218"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gaf4a2817b703dafb592312891de669218">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const ConstBufferSequence &amp;source)</td></tr>
<tr class="memdesc:gaf4a2817b703dafb592312891de669218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer sequence to a target buffer.  <a href="group__buffer__copy.html#gaf4a2817b703dafb592312891de669218">More...</a><br /></td></tr>
<tr class="separator:gaf4a2817b703dafb592312891de669218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ec05b1cae10cdc08b8768bd6b7b7b2"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga53ec05b1cae10cdc08b8768bd6b7b7b2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga53ec05b1cae10cdc08b8768bd6b7b7b2">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;source)</td></tr>
<tr class="memdesc:ga53ec05b1cae10cdc08b8768bd6b7b7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer sequence.  <a href="group__buffer__copy.html#ga53ec05b1cae10cdc08b8768bd6b7b7b2">More...</a><br /></td></tr>
<tr class="separator:ga53ec05b1cae10cdc08b8768bd6b7b7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga980f80c33ea8e7287819bc1753a92f7b"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga980f80c33ea8e7287819bc1753a92f7b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga980f80c33ea8e7287819bc1753a92f7b">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> &amp;source)</td></tr>
<tr class="memdesc:ga980f80c33ea8e7287819bc1753a92f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer sequence.  <a href="group__buffer__copy.html#ga980f80c33ea8e7287819bc1753a92f7b">More...</a><br /></td></tr>
<tr class="separator:ga980f80c33ea8e7287819bc1753a92f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805c350f27581373ee6c1d0fdcff92e0"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga805c350f27581373ee6c1d0fdcff92e0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga805c350f27581373ee6c1d0fdcff92e0">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;source)</td></tr>
<tr class="memdesc:ga805c350f27581373ee6c1d0fdcff92e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer sequence.  <a href="group__buffer__copy.html#ga805c350f27581373ee6c1d0fdcff92e0">More...</a><br /></td></tr>
<tr class="separator:ga805c350f27581373ee6c1d0fdcff92e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77fdccbc8ef71eca2becc0ae9b5a5921"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga77fdccbc8ef71eca2becc0ae9b5a5921"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga77fdccbc8ef71eca2becc0ae9b5a5921">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;source)</td></tr>
<tr class="memdesc:ga77fdccbc8ef71eca2becc0ae9b5a5921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer to a target buffer sequence.  <a href="group__buffer__copy.html#ga77fdccbc8ef71eca2becc0ae9b5a5921">More...</a><br /></td></tr>
<tr class="separator:ga77fdccbc8ef71eca2becc0ae9b5a5921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee2be3725dff58302a47a0eb2bc72bb"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga0ee2be3725dff58302a47a0eb2bc72bb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga0ee2be3725dff58302a47a0eb2bc72bb">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source)</td></tr>
<tr class="memdesc:ga0ee2be3725dff58302a47a0eb2bc72bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer sequence to a target buffer sequence.  <a href="group__buffer__copy.html#ga0ee2be3725dff58302a47a0eb2bc72bb">More...</a><br /></td></tr>
<tr class="separator:ga0ee2be3725dff58302a47a0eb2bc72bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb89801dc44bbcbf308e08dcb0c9181"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gaccb89801dc44bbcbf308e08dcb0c9181">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:gaccb89801dc44bbcbf308e08dcb0c9181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#gaccb89801dc44bbcbf308e08dcb0c9181">More...</a><br /></td></tr>
<tr class="separator:gaccb89801dc44bbcbf308e08dcb0c9181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e6ea40e73105d4a5a73b24320feb59d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga9e6ea40e73105d4a5a73b24320feb59d">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:ga9e6ea40e73105d4a5a73b24320feb59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga9e6ea40e73105d4a5a73b24320feb59d">More...</a><br /></td></tr>
<tr class="separator:ga9e6ea40e73105d4a5a73b24320feb59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c7347ac0eae54aea68d4b70d144a2e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga13c7347ac0eae54aea68d4b70d144a2e">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:ga13c7347ac0eae54aea68d4b70d144a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga13c7347ac0eae54aea68d4b70d144a2e">More...</a><br /></td></tr>
<tr class="separator:ga13c7347ac0eae54aea68d4b70d144a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1a32a028494196848be4e5347edd43"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga4d1a32a028494196848be4e5347edd43">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:ga4d1a32a028494196848be4e5347edd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga4d1a32a028494196848be4e5347edd43">More...</a><br /></td></tr>
<tr class="separator:ga4d1a32a028494196848be4e5347edd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c033d3e12841b6835b036344da2305f"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga3c033d3e12841b6835b036344da2305f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga3c033d3e12841b6835b036344da2305f">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;target, const ConstBufferSequence &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="separator:ga3c033d3e12841b6835b036344da2305f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdaafbbc9b0024de24f208ccc933f6e3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gacdaafbbc9b0024de24f208ccc933f6e3">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:gacdaafbbc9b0024de24f208ccc933f6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#gacdaafbbc9b0024de24f208ccc933f6e3">More...</a><br /></td></tr>
<tr class="separator:gacdaafbbc9b0024de24f208ccc933f6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d26475b811386a5c1cfc779368dd56d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga4d26475b811386a5c1cfc779368dd56d">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:ga4d26475b811386a5c1cfc779368dd56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga4d26475b811386a5c1cfc779368dd56d">More...</a><br /></td></tr>
<tr class="separator:ga4d26475b811386a5c1cfc779368dd56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39411f1f8eae62b00cfc5fdec52e62ef"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga39411f1f8eae62b00cfc5fdec52e62ef">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:ga39411f1f8eae62b00cfc5fdec52e62ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga39411f1f8eae62b00cfc5fdec52e62ef">More...</a><br /></td></tr>
<tr class="separator:ga39411f1f8eae62b00cfc5fdec52e62ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec7ca61beddb66bdf2c1b9950e5ef25"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga3ec7ca61beddb66bdf2c1b9950e5ef25">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="memdesc:ga3ec7ca61beddb66bdf2c1b9950e5ef25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer to a target buffer.  <a href="group__buffer__copy.html#ga3ec7ca61beddb66bdf2c1b9950e5ef25">More...</a><br /></td></tr>
<tr class="separator:ga3ec7ca61beddb66bdf2c1b9950e5ef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf4f7f5d3db8dfaaeabd5d8bbfc3c30"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:gaebf4f7f5d3db8dfaaeabd5d8bbfc3c30"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gaebf4f7f5d3db8dfaaeabd5d8bbfc3c30">buffer_copy</a> (const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;target, const ConstBufferSequence &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="separator:gaebf4f7f5d3db8dfaaeabd5d8bbfc3c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a4ac1b034c7a80d4e5ebbd858a9c727"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga8a4ac1b034c7a80d4e5ebbd858a9c727"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga8a4ac1b034c7a80d4e5ebbd858a9c727">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="separator:ga8a4ac1b034c7a80d4e5ebbd858a9c727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa146b63f2bdc20a3c0bd5e4c4d8d0ead"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:gaa146b63f2bdc20a3c0bd5e4c4d8d0ead"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#gaa146b63f2bdc20a3c0bd5e4c4d8d0ead">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="separator:gaa146b63f2bdc20a3c0bd5e4c4d8d0ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d071ecd1fc863feac8d1ca303c4346"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga31d071ecd1fc863feac8d1ca303c4346"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga31d071ecd1fc863feac8d1ca303c4346">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="separator:ga31d071ecd1fc863feac8d1ca303c4346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga328a0f81f124d05c142465d3ebeeefeb"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga328a0f81f124d05c142465d3ebeeefeb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga328a0f81f124d05c142465d3ebeeefeb">buffer_copy</a> (const MutableBufferSequence &amp;target, const <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="separator:ga328a0f81f124d05c142465d3ebeeefeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0552327b5c66c5f764476539909d3d15"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga0552327b5c66c5f764476539909d3d15"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga0552327b5c66c5f764476539909d3d15">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source, std::size_t max_bytes_to_copy)</td></tr>
<tr class="separator:ga0552327b5c66c5f764476539909d3d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9d6099d23e9bf78b2b1ad82d164d3d7e">buffers_begin</a> (const BufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the beginning of the buffers' data.  <a href="#a9d6099d23e9bf78b2b1ad82d164d3d7e">More...</a><br /></td></tr>
<tr class="separator:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef4b181d4561848de38fac7907d4a0b"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a2ef4b181d4561848de38fac7907d4a0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2ef4b181d4561848de38fac7907d4a0b">buffers_end</a> (const BufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:a2ef4b181d4561848de38fac7907d4a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the end of the buffers' data.  <a href="#a2ef4b181d4561848de38fac7907d4a0b">More...</a><br /></td></tr>
<tr class="separator:a2ef4b181d4561848de38fac7907d4a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a82e92df79aa8401a8bc2117d4cf900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__all__t.html">detail::transfer_all_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__completion__condition.html#ga4a82e92df79aa8401a8bc2117d4cf900">transfer_all</a> ()</td></tr>
<tr class="separator:ga4a82e92df79aa8401a8bc2117d4cf900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b10af704afcd6c7ed7f0d3b740033ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__at__least__t.html">detail::transfer_at_least_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__completion__condition.html#ga2b10af704afcd6c7ed7f0d3b740033ef">transfer_at_least</a> (std::size_t minimum)</td></tr>
<tr class="separator:ga2b10af704afcd6c7ed7f0d3b740033ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2ada9400d78a5df0e5f65dd2b9967e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__exactly__t.html">detail::transfer_exactly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__completion__condition.html#gadb2ada9400d78a5df0e5f65dd2b9967e">transfer_exactly</a> (std::size_t size)</td></tr>
<tr class="separator:gadb2ada9400d78a5df0e5f65dd2b9967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29acd61d7a875cef7dbd1f892be2906c"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator &gt; </td></tr>
<tr class="memitem:ga29acd61d7a875cef7dbd1f892be2906c"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga29acd61d7a875cef7dbd1f892be2906c">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>)</td></tr>
<tr class="memdesc:ga29acd61d7a875cef7dbd1f892be2906c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga29acd61d7a875cef7dbd1f892be2906c">More...</a><br /></td></tr>
<tr class="separator:ga29acd61d7a875cef7dbd1f892be2906c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb975e78fb1233032ba2b13a229cc8e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator &gt; </td></tr>
<tr class="memitem:ga1bb975e78fb1233032ba2b13a229cc8e"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga1bb975e78fb1233032ba2b13a229cc8e">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga1bb975e78fb1233032ba2b13a229cc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga1bb975e78fb1233032ba2b13a229cc8e">More...</a><br /></td></tr>
<tr class="separator:ga1bb975e78fb1233032ba2b13a229cc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8617a800bbe4f0e99be3826d8e48e60e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator &gt; </td></tr>
<tr class="memitem:ga8617a800bbe4f0e99be3826d8e48e60e"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga8617a800bbe4f0e99be3826d8e48e60e">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, Iterator <a class="el" href="group__async__connect.html#gadb6ad0193229ae84828688e812cd325c">end</a>)</td></tr>
<tr class="memdesc:ga8617a800bbe4f0e99be3826d8e48e60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga8617a800bbe4f0e99be3826d8e48e60e">More...</a><br /></td></tr>
<tr class="separator:ga8617a800bbe4f0e99be3826d8e48e60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc8005658c5ece3566508bc108d4c83"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator &gt; </td></tr>
<tr class="memitem:ga6cc8005658c5ece3566508bc108d4c83"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga6cc8005658c5ece3566508bc108d4c83">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, Iterator <a class="el" href="group__async__connect.html#gadb6ad0193229ae84828688e812cd325c">end</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga6cc8005658c5ece3566508bc108d4c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga6cc8005658c5ece3566508bc108d4c83">More...</a><br /></td></tr>
<tr class="separator:ga6cc8005658c5ece3566508bc108d4c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a192c653d045eaa7c8c7817316a52b5"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga9a192c653d045eaa7c8c7817316a52b5"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga9a192c653d045eaa7c8c7817316a52b5">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, ConnectCondition <a class="el" href="group__async__connect.html#ga47e3dda205dfba3553f4c7e005897687">connect_condition</a>)</td></tr>
<tr class="memdesc:ga9a192c653d045eaa7c8c7817316a52b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga9a192c653d045eaa7c8c7817316a52b5">More...</a><br /></td></tr>
<tr class="separator:ga9a192c653d045eaa7c8c7817316a52b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab16905fe7662fdaa7410ea98e4a5d38a"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:gab16905fe7662fdaa7410ea98e4a5d38a"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gab16905fe7662fdaa7410ea98e4a5d38a">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, ConnectCondition <a class="el" href="group__async__connect.html#ga47e3dda205dfba3553f4c7e005897687">connect_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gab16905fe7662fdaa7410ea98e4a5d38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gab16905fe7662fdaa7410ea98e4a5d38a">More...</a><br /></td></tr>
<tr class="separator:gab16905fe7662fdaa7410ea98e4a5d38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85284052d2233e8ea3993625e9f28184"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga85284052d2233e8ea3993625e9f28184"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga85284052d2233e8ea3993625e9f28184">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, Iterator <a class="el" href="group__async__connect.html#gadb6ad0193229ae84828688e812cd325c">end</a>, ConnectCondition <a class="el" href="group__async__connect.html#ga47e3dda205dfba3553f4c7e005897687">connect_condition</a>)</td></tr>
<tr class="memdesc:ga85284052d2233e8ea3993625e9f28184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga85284052d2233e8ea3993625e9f28184">More...</a><br /></td></tr>
<tr class="separator:ga85284052d2233e8ea3993625e9f28184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga309aa819fa86c14156c10c5374eb0d24"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga309aa819fa86c14156c10c5374eb0d24"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga309aa819fa86c14156c10c5374eb0d24">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, SocketService &gt; &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, Iterator <a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, Iterator <a class="el" href="group__async__connect.html#gadb6ad0193229ae84828688e812cd325c">end</a>, ConnectCondition <a class="el" href="group__async__connect.html#ga47e3dda205dfba3553f4c7e005897687">connect_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga309aa819fa86c14156c10c5374eb0d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga309aa819fa86c14156c10c5374eb0d24">More...</a><br /></td></tr>
<tr class="separator:ga309aa819fa86c14156c10c5374eb0d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8de8138419acd99224c0a7071a99a0"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator , typename ComposedConnectHandler &gt; </td></tr>
<tr class="memitem:ga7b8de8138419acd99224c0a7071a99a0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga7b8de8138419acd99224c0a7071a99a0">ASIO_INITFN_RESULT_TYPE</a> (ComposedConnectHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="separator:ga7b8de8138419acd99224c0a7071a99a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62bf3d82e9459cfd1fc6f51024aceb25"><td class="memItemLeft" align="right" valign="top">SocketService Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga62bf3d82e9459cfd1fc6f51024aceb25">ASIO_MOVE_ARG</a> (ComposedConnectHandler) handler)</td></tr>
<tr class="separator:ga62bf3d82e9459cfd1fc6f51024aceb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97861978f077050db440c518ba215350"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename SocketService , typename Iterator , typename ConnectCondition , typename ComposedConnectHandler &gt; </td></tr>
<tr class="memitem:ga97861978f077050db440c518ba215350"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga97861978f077050db440c518ba215350">ASIO_INITFN_RESULT_TYPE</a> (ComposedConnectHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="separator:ga97861978f077050db440c518ba215350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1776aa9a745f4da041978ce17abc44ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> const <a class="el" href="classasio_1_1error__category.html">error_category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1776aa9a745f4da041978ce17abc44ff">system_category</a> ()</td></tr>
<tr class="memdesc:a1776aa9a745f4da041978ce17abc44ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error category used for the system errors produced by asio.  <a href="#a1776aa9a745f4da041978ce17abc44ff">More...</a><br /></td></tr>
<tr class="separator:a1776aa9a745f4da041978ce17abc44ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951615f7e517dd14f0a1c3ceaa538145"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits &gt; </td></tr>
<tr class="memitem:a951615f7e517dd14f0a1c3ceaa538145"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a951615f7e517dd14f0a1c3ceaa538145">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;os, const <a class="el" href="classasio_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a951615f7e517dd14f0a1c3ceaa538145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an error code.  <a href="#a951615f7e517dd14f0a1c3ceaa538145">More...</a><br /></td></tr>
<tr class="separator:a951615f7e517dd14f0a1c3ceaa538145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825c2034d7e4609cb65e53ec2cf833bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a825c2034d7e4609cb65e53ec2cf833bf">asio_handler_allocate</a> (std::size_t size,...)</td></tr>
<tr class="memdesc:a825c2034d7e4609cb65e53ec2cf833bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default allocation function for handlers.  <a href="#a825c2034d7e4609cb65e53ec2cf833bf">More...</a><br /></td></tr>
<tr class="separator:a825c2034d7e4609cb65e53ec2cf833bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1316007445a73023bc5603a69c97d9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1316007445a73023bc5603a69c97d9b7">asio_handler_deallocate</a> (void *pointer, std::size_t size,...)</td></tr>
<tr class="memdesc:a1316007445a73023bc5603a69c97d9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default deallocation function for handlers.  <a href="#a1316007445a73023bc5603a69c97d9b7">More...</a><br /></td></tr>
<tr class="separator:a1316007445a73023bc5603a69c97d9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7613e3b437b2491c154e056f1a26668f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a> (...)</td></tr>
<tr class="memdesc:a7613e3b437b2491c154e056f1a26668f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default continuation function for handlers.  <a href="#a7613e3b437b2491c154e056f1a26668f">More...</a><br /></td></tr>
<tr class="separator:a7613e3b437b2491c154e056f1a26668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91c8e702816572ffb691ca3f60a27871"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga91c8e702816572ffb691ca3f60a27871"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asio__handler__invoke.html#ga91c8e702816572ffb691ca3f60a27871">asio_handler_invoke</a> (Function &amp;function,...)</td></tr>
<tr class="memdesc:ga91c8e702816572ffb691ca3f60a27871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler invocation hook used for non-const function objects.  <a href="group__asio__handler__invoke.html#ga91c8e702816572ffb691ca3f60a27871">More...</a><br /></td></tr>
<tr class="separator:ga91c8e702816572ffb691ca3f60a27871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asio__handler__invoke.html#gabe759a0b25886ffc0b10ecd98bb69edd">asio_handler_invoke</a> (const Function &amp;function,...)</td></tr>
<tr class="memdesc:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler invocation hook used for const function objects.  <a href="group__asio__handler__invoke.html#gabe759a0b25886ffc0b10ecd98bb69edd">More...</a><br /></td></tr>
<tr class="separator:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461c3a69a56dac355730dd6bbddf4ec3"><td class="memTemplParams" colspan="2">template&lt;typename ReadHandler &gt; </td></tr>
<tr class="memitem:a461c3a69a56dac355730dd6bbddf4ec3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a461c3a69a56dac355730dd6bbddf4ec3">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream &gt;</td></tr>
<tr class="separator:a461c3a69a56dac355730dd6bbddf4ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7deb94f1e4f209ff535c2fd9ac06ba8"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ae7deb94f1e4f209ff535c2fd9ac06ba8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae7deb94f1e4f209ff535c2fd9ac06ba8">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream &gt;</td></tr>
<tr class="separator:ae7deb94f1e4f209ff535c2fd9ac06ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cc551c7151133f0292ec21e4d08647"><td class="memTemplParams" colspan="2">template&lt;typename WriteHandler &gt; </td></tr>
<tr class="memitem:a83cc551c7151133f0292ec21e4d08647"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a83cc551c7151133f0292ec21e4d08647">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a>&lt; Stream &gt;</td></tr>
<tr class="separator:a83cc551c7151133f0292ec21e4d08647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae155d327b1f08e08ca04fad48cf39b9"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , typename WriteHandler &gt; </td></tr>
<tr class="memitem:aae155d327b1f08e08ca04fad48cf39b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aae155d327b1f08e08ca04fad48cf39b9">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a>&lt; Stream &gt;</td></tr>
<tr class="separator:aae155d327b1f08e08ca04fad48cf39b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58b7928a252af75bd55864260c19685"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:af58b7928a252af75bd55864260c19685"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af58b7928a252af75bd55864260c19685">use_service</a> (<a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;ios)</td></tr>
<tr class="separator:af58b7928a252af75bd55864260c19685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0262ce1729113b74df9d11992c95d6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abc0262ce1729113b74df9d11992c95d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceasio_1_1detail.html#a6d61d9b8e53c11288be549d82aec5a42">detail::io_service_impl</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#abc0262ce1729113b74df9d11992c95d6">use_service&lt; detail::io_service_impl &gt;</a> (<a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;ios)</td></tr>
<tr class="separator:abc0262ce1729113b74df9d11992c95d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb48bc8e931affee7ab772dd7706bb74"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:acb48bc8e931affee7ab772dd7706bb74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#acb48bc8e931affee7ab772dd7706bb74">add_service</a> (<a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;ios, Service *svc)</td></tr>
<tr class="separator:acb48bc8e931affee7ab772dd7706bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99c6070cedcd4c0ba471a8e41f66e9f"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:ae99c6070cedcd4c0ba471a8e41f66e9f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ae99c6070cedcd4c0ba471a8e41f66e9f">has_service</a> (<a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;ios)</td></tr>
<tr class="separator:ae99c6070cedcd4c0ba471a8e41f66e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d02e61810aed938d944fa2dae09d66c"><td class="memTemplParams" colspan="2">template&lt;typename CompletionHandler &gt; </td></tr>
<tr class="memitem:a2d02e61810aed938d944fa2dae09d66c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2d02e61810aed938d944fa2dae09d66c">ASIO_INITFN_RESULT_TYPE</a> (CompletionHandler, void()) <a class="el" href="classasio_1_1io__service.html">io_service</a></td></tr>
<tr class="separator:a2d02e61810aed938d944fa2dae09d66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b2bc31177c2bf7cba974b5c65f9036"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga68b2bc31177c2bf7cba974b5c65f9036"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga68b2bc31177c2bf7cba974b5c65f9036">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga68b2bc31177c2bf7cba974b5c65f9036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga68b2bc31177c2bf7cba974b5c65f9036">More...</a><br /></td></tr>
<tr class="separator:ga68b2bc31177c2bf7cba974b5c65f9036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c82bf41e199a1c6a5e1c19dbb79d4f8"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga9c82bf41e199a1c6a5e1c19dbb79d4f8"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga9c82bf41e199a1c6a5e1c19dbb79d4f8">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:ga9c82bf41e199a1c6a5e1c19dbb79d4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga9c82bf41e199a1c6a5e1c19dbb79d4f8">More...</a><br /></td></tr>
<tr class="separator:ga9c82bf41e199a1c6a5e1c19dbb79d4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a4f3670e5250b6f8703337b583f1c9"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga96a4f3670e5250b6f8703337b583f1c9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga96a4f3670e5250b6f8703337b583f1c9">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga96a4f3670e5250b6f8703337b583f1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga96a4f3670e5250b6f8703337b583f1c9">More...</a><br /></td></tr>
<tr class="separator:ga96a4f3670e5250b6f8703337b583f1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d689815cf77799d209397d92d0a2f79"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga3d689815cf77799d209397d92d0a2f79"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga3d689815cf77799d209397d92d0a2f79">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:ga3d689815cf77799d209397d92d0a2f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga3d689815cf77799d209397d92d0a2f79">More...</a><br /></td></tr>
<tr class="separator:ga3d689815cf77799d209397d92d0a2f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6038b695e95ef357b104f35a28edfe3d"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga6038b695e95ef357b104f35a28edfe3d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga6038b695e95ef357b104f35a28edfe3d">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga6038b695e95ef357b104f35a28edfe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga6038b695e95ef357b104f35a28edfe3d">More...</a><br /></td></tr>
<tr class="separator:ga6038b695e95ef357b104f35a28edfe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gaaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gaaeda9d140628ff399cbe4a076cb15cee">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:gaaeda9d140628ff399cbe4a076cb15cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gaaeda9d140628ff399cbe4a076cb15cee">More...</a><br /></td></tr>
<tr class="separator:gaaeda9d140628ff399cbe4a076cb15cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gabc0bc3183df1291c7b2a35ec30d5428c">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gabc0bc3183df1291c7b2a35ec30d5428c">More...</a><br /></td></tr>
<tr class="separator:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeadfb55ae835155abb8b6dc11a063b54"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaeadfb55ae835155abb8b6dc11a063b54"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gaeadfb55ae835155abb8b6dc11a063b54">read</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:gaeadfb55ae835155abb8b6dc11a063b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gaeadfb55ae835155abb8b6dc11a063b54">More...</a><br /></td></tr>
<tr class="separator:gaeadfb55ae835155abb8b6dc11a063b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab321259782b3683c80f33eb1050a3251"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gab321259782b3683c80f33eb1050a3251"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gab321259782b3683c80f33eb1050a3251">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a></td></tr>
<tr class="separator:gab321259782b3683c80f33eb1050a3251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41f6414b06e189a76689422b8e2db35"><td class="memItemLeft" align="right" valign="top">const MutableBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#gac41f6414b06e189a76689422b8e2db35">ASIO_MOVE_ARG</a> (ReadHandler) handler)</td></tr>
<tr class="separator:gac41f6414b06e189a76689422b8e2db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a></td></tr>
<tr class="separator:ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88604242259da9fb0bacf3c4f0cc0002"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga88604242259da9fb0bacf3c4f0cc0002"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga88604242259da9fb0bacf3c4f0cc0002">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:ga88604242259da9fb0bacf3c4f0cc0002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga4ef7a26ff401494d673ad462a3f3f5c0">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="separator:ga4ef7a26ff401494d673ad462a3f3f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6587e766e26325457154a5dac2a0b785"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga6587e766e26325457154a5dac2a0b785"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga6587e766e26325457154a5dac2a0b785">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:ga6587e766e26325457154a5dac2a0b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16ebd52ad98e521ea4b75676d4db9fd"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaa16ebd52ad98e521ea4b75676d4db9fd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#gaa16ebd52ad98e521ea4b75676d4db9fd">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const MutableBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="separator:gaa16ebd52ad98e521ea4b75676d4db9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga926222f6d0bb8a716a17161a1eb725aa"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga926222f6d0bb8a716a17161a1eb725aa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga926222f6d0bb8a716a17161a1eb725aa">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:ga926222f6d0bb8a716a17161a1eb725aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301406c670bc22190df6e8628cbf0037"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:ga301406c670bc22190df6e8628cbf0037"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga301406c670bc22190df6e8628cbf0037">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="separator:ga301406c670bc22190df6e8628cbf0037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4511bad893697fc58d379d6e00aa84ff"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:ga4511bad893697fc58d379d6e00aa84ff"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga4511bad893697fc58d379d6e00aa84ff">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="separator:ga4511bad893697fc58d379d6e00aa84ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0126c00568f324b47c24b494c97ece14"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga0126c00568f324b47c24b494c97ece14"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga0126c00568f324b47c24b494c97ece14">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="separator:ga0126c00568f324b47c24b494c97ece14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">read_until</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, char <a class="el" href="group__async__read__until.html#gafbf62a75ad736aff941c1f70d4b3c223">delim</a>)</td></tr>
<tr class="memdesc:ga1aae2baa82596a6a9ad320e80b016006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">More...</a><br /></td></tr>
<tr class="separator:ga1aae2baa82596a6a9ad320e80b016006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">read_until</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, char <a class="el" href="group__async__read__until.html#gafbf62a75ad736aff941c1f70d4b3c223">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">More...</a><br /></td></tr>
<tr class="separator:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga6f38642ad22fcb7f72ddc9fd2b586541">read_until</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, const std::string &amp;<a class="el" href="group__async__read__until.html#gafbf62a75ad736aff941c1f70d4b3c223">delim</a>)</td></tr>
<tr class="memdesc:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga6f38642ad22fcb7f72ddc9fd2b586541">More...</a><br /></td></tr>
<tr class="separator:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27386e9b95114d7def2feee77e2dfd93"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga27386e9b95114d7def2feee77e2dfd93"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga27386e9b95114d7def2feee77e2dfd93">read_until</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, const std::string &amp;<a class="el" href="group__async__read__until.html#gafbf62a75ad736aff941c1f70d4b3c223">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga27386e9b95114d7def2feee77e2dfd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga27386e9b95114d7def2feee77e2dfd93">More...</a><br /></td></tr>
<tr class="separator:ga27386e9b95114d7def2feee77e2dfd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">read_until</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, MatchCondition <a class="el" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaacb23419d8878f33e469e3f743c738d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">More...</a><br /></td></tr>
<tr class="separator:gaacb23419d8878f33e469e3f743c738d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">read_until</a> (SyncReadStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, MatchCondition <a class="el" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">More...</a><br /></td></tr>
<tr class="separator:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab95c6736198fcded5573a1d43fe25ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1read__until__match__op.html">detail::read_until_match_op</a>&lt; AsyncReadStream, Allocator, MatchCondition, <a class="el" href="handler__type_8hpp.html#a3e8a48d0097c0be0da56b81efe2c183e">ASIO_HANDLER_TYPE</a>(ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t))&gt;(<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a>, init.handler)(asio return <a class="el" href="namespaceasio.html#abae608ba848ec0b5f26a2e6f213dcf6d">init</a> result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aab95c6736198fcded5573a1d43fe25ed">get</a> ()</td></tr>
<tr class="separator:aab95c6736198fcded5573a1d43fe25ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2228347a699338928b72b60b52e345"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename Function &gt; </td></tr>
<tr class="memitem:ga4f2228347a699338928b72b60b52e345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga4f2228347a699338928b72b60b52e345">spawn</a> (<a class="el" href="group__async__read.html#ga6d72a97784dde9476c6d93b8904a4967">ASIO_MOVE_ARG</a>(Handler) handler, <a class="el" href="group__async__read.html#ga6d72a97784dde9476c6d93b8904a4967">ASIO_MOVE_ARG</a>(Function) function, const boost::coroutines::attributes &amp;attributes)</td></tr>
<tr class="separator:ga4f2228347a699338928b72b60b52e345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a673b1867f7983c6701bb0dc658c36"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename Function &gt; </td></tr>
<tr class="memitem:ga96a673b1867f7983c6701bb0dc658c36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga96a673b1867f7983c6701bb0dc658c36">spawn</a> (<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Handler &gt; ctx, <a class="el" href="group__async__read.html#ga6d72a97784dde9476c6d93b8904a4967">ASIO_MOVE_ARG</a>(Function) function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:ga96a673b1867f7983c6701bb0dc658c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine, inheriting the execution context of another.  <a href="group__spawn.html#ga96a673b1867f7983c6701bb0dc658c36">More...</a><br /></td></tr>
<tr class="separator:ga96a673b1867f7983c6701bb0dc658c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832418b551fda9707d57eadcbb40142c"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga832418b551fda9707d57eadcbb40142c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga832418b551fda9707d57eadcbb40142c">spawn</a> (<a class="el" href="classasio_1_1io__service_1_1strand.html">asio::io_service::strand</a> <a class="el" href="namespaceasio.html#a3be3fa00c86ab58ba41aabe8fcbf11be">strand</a>, <a class="el" href="group__async__read.html#ga6d72a97784dde9476c6d93b8904a4967">ASIO_MOVE_ARG</a>(Function) function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:ga832418b551fda9707d57eadcbb40142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes in the context of a strand.  <a href="group__spawn.html#ga832418b551fda9707d57eadcbb40142c">More...</a><br /></td></tr>
<tr class="separator:ga832418b551fda9707d57eadcbb40142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab669a6a11388d45fb48bc9be9e5bda38"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gab669a6a11388d45fb48bc9be9e5bda38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#gab669a6a11388d45fb48bc9be9e5bda38">spawn</a> (<a class="el" href="classasio_1_1io__service.html">asio::io_service</a> &amp;<a class="el" href="classasio_1_1io__service.html">io_service</a>, <a class="el" href="group__async__read.html#ga6d72a97784dde9476c6d93b8904a4967">ASIO_MOVE_ARG</a>(Function) function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:gab669a6a11388d45fb48bc9be9e5bda38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a>.  <a href="group__spawn.html#gab669a6a11388d45fb48bc9be9e5bda38">More...</a><br /></td></tr>
<tr class="separator:gab669a6a11388d45fb48bc9be9e5bda38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53a6638aac728c8bf61621b12fa8fce"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaf53a6638aac728c8bf61621b12fa8fce"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gaf53a6638aac728c8bf61621b12fa8fce">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gaf53a6638aac728c8bf61621b12fa8fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#gaf53a6638aac728c8bf61621b12fa8fce">More...</a><br /></td></tr>
<tr class="separator:gaf53a6638aac728c8bf61621b12fa8fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab293266ad69e271fdda0ff6f8086fb5c"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:gab293266ad69e271fdda0ff6f8086fb5c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gab293266ad69e271fdda0ff6f8086fb5c">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:gab293266ad69e271fdda0ff6f8086fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#gab293266ad69e271fdda0ff6f8086fb5c">More...</a><br /></td></tr>
<tr class="separator:gab293266ad69e271fdda0ff6f8086fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe88679a7a77cbb22870cafa20414cb"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:gacfe88679a7a77cbb22870cafa20414cb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gacfe88679a7a77cbb22870cafa20414cb">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gacfe88679a7a77cbb22870cafa20414cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#gacfe88679a7a77cbb22870cafa20414cb">More...</a><br /></td></tr>
<tr class="separator:gacfe88679a7a77cbb22870cafa20414cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646f54905cf959c2c16f221a2e1c1ce7"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga646f54905cf959c2c16f221a2e1c1ce7"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga646f54905cf959c2c16f221a2e1c1ce7">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:ga646f54905cf959c2c16f221a2e1c1ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#ga646f54905cf959c2c16f221a2e1c1ce7">More...</a><br /></td></tr>
<tr class="separator:ga646f54905cf959c2c16f221a2e1c1ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393e12e427f89cb932c6a2bd800236fb"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga393e12e427f89cb932c6a2bd800236fb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga393e12e427f89cb932c6a2bd800236fb">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga393e12e427f89cb932c6a2bd800236fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#ga393e12e427f89cb932c6a2bd800236fb">More...</a><br /></td></tr>
<tr class="separator:ga393e12e427f89cb932c6a2bd800236fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85807d13da87adf48b62979f65f41152"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga85807d13da87adf48b62979f65f41152"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga85807d13da87adf48b62979f65f41152">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga85807d13da87adf48b62979f65f41152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#ga85807d13da87adf48b62979f65f41152">More...</a><br /></td></tr>
<tr class="separator:ga85807d13da87adf48b62979f65f41152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gaf72f7eddd7d4629ea2e2b7f5b7f355bc">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#gaf72f7eddd7d4629ea2e2b7f5b7f355bc">More...</a><br /></td></tr>
<tr class="separator:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80988391fb309ee53cc557d0065550a"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaa80988391fb309ee53cc557d0065550a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gaa80988391fb309ee53cc557d0065550a">write</a> (SyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:gaa80988391fb309ee53cc557d0065550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#gaa80988391fb309ee53cc557d0065550a">More...</a><br /></td></tr>
<tr class="separator:gaa80988391fb309ee53cc557d0065550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1e5b963aeb45f6fc692c4e1a07ed04"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga5a1e5b963aeb45f6fc692c4e1a07ed04"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#ga5a1e5b963aeb45f6fc692c4e1a07ed04">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a></td></tr>
<tr class="separator:ga5a1e5b963aeb45f6fc692c4e1a07ed04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9600cc9bb72a930568b318a8d6f79afa"><td class="memItemLeft" align="right" valign="top">const ConstBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__write.html#ga9600cc9bb72a930568b318a8d6f79afa">ASIO_MOVE_ARG</a> (WriteHandler) handler)</td></tr>
<tr class="separator:ga9600cc9bb72a930568b318a8d6f79afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b61e40209cec169c7de5fafc16a6f9c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga7b61e40209cec169c7de5fafc16a6f9c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#ga7b61e40209cec169c7de5fafc16a6f9c">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a></td></tr>
<tr class="separator:ga7b61e40209cec169c7de5fafc16a6f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51133c1e260b8abeeed55646e765fdd6"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga51133c1e260b8abeeed55646e765fdd6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga51133c1e260b8abeeed55646e765fdd6">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga51133c1e260b8abeeed55646e765fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga51133c1e260b8abeeed55646e765fdd6">More...</a><br /></td></tr>
<tr class="separator:ga51133c1e260b8abeeed55646e765fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd67a05a29d183782491d14aceec7d41"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:gadd67a05a29d183782491d14aceec7d41"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#gadd67a05a29d183782491d14aceec7d41">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:gadd67a05a29d183782491d14aceec7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#gadd67a05a29d183782491d14aceec7d41">More...</a><br /></td></tr>
<tr class="separator:gadd67a05a29d183782491d14aceec7d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga8c1abcb5870505ea2a0c524a59638da0">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga8c1abcb5870505ea2a0c524a59638da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#ga8c1abcb5870505ea2a0c524a59638da0">More...</a><br /></td></tr>
<tr class="separator:ga8c1abcb5870505ea2a0c524a59638da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga3e6b2f5dd13f4273695fbf0cdec0314a">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, const ConstBufferSequence &amp;<a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga3e6b2f5dd13f4273695fbf0cdec0314a">More...</a><br /></td></tr>
<tr class="separator:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431966af634f0701ceac7f54fc1b0371"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga431966af634f0701ceac7f54fc1b0371"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga431966af634f0701ceac7f54fc1b0371">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga431966af634f0701ceac7f54fc1b0371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga431966af634f0701ceac7f54fc1b0371">More...</a><br /></td></tr>
<tr class="separator:ga431966af634f0701ceac7f54fc1b0371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db1f75a907c17918092b41f2f242104"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:ga1db1f75a907c17918092b41f2f242104"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga1db1f75a907c17918092b41f2f242104">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:ga1db1f75a907c17918092b41f2f242104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#ga1db1f75a907c17918092b41f2f242104">More...</a><br /></td></tr>
<tr class="separator:ga1db1f75a907c17918092b41f2f242104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#gaa6f42435acf937c35ee4c81af44ee6ce">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#gaa6f42435acf937c35ee4c81af44ee6ce">More...</a><br /></td></tr>
<tr class="separator:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e23f5418309ba130d75f6757b7b8e15"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga2e23f5418309ba130d75f6757b7b8e15"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga2e23f5418309ba130d75f6757b7b8e15">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t <a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:ga2e23f5418309ba130d75f6757b7b8e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga2e23f5418309ba130d75f6757b7b8e15">More...</a><br /></td></tr>
<tr class="separator:ga2e23f5418309ba130d75f6757b7b8e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga31ab74b9ea6c77932dddd016cfc7920a"><td class="memItemLeft" align="right" valign="top">SocketService &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a></td></tr>
<tr class="separator:ga31ab74b9ea6c77932dddd016cfc7920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7055bca9225050c030c19c7dc926fa53"><td class="memItemLeft" align="right" valign="top">SocketService Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a></td></tr>
<tr class="separator:ga7055bca9225050c030c19c7dc926fa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6ad0193229ae84828688e812cd325c"><td class="memItemLeft" align="right" valign="top">SocketService Iterator Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__connect.html#gadb6ad0193229ae84828688e812cd325c">end</a></td></tr>
<tr class="separator:gadb6ad0193229ae84828688e812cd325c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e3dda205dfba3553f4c7e005897687"><td class="memItemLeft" align="right" valign="top">SocketService Iterator ConnectCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga47e3dda205dfba3553f4c7e005897687">connect_condition</a></td></tr>
<tr class="separator:ga47e3dda205dfba3553f4c7e005897687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54dede45c3175148a77fe6635222c47d"><td class="memItemLeft" align="right" valign="top">const MutableBufferSequence &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a></td></tr>
<tr class="separator:ga54dede45c3175148a77fe6635222c47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e215d5013596cc2b385bb6c13fa518"><td class="memItemLeft" align="right" valign="top">const MutableBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a></td></tr>
<tr class="separator:gae2e215d5013596cc2b385bb6c13fa518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945a5c18fa77a9e2eba420f8f44b2a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a></td></tr>
<tr class="separator:ga945a5c18fa77a9e2eba420f8f44b2a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d72a97784dde9476c6d93b8904a4967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga6d72a97784dde9476c6d93b8904a4967">ASIO_MOVE_ARG</a> (ReadHandler) handler)</td></tr>
<tr class="separator:ga6d72a97784dde9476c6d93b8904a4967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dcdb41a4adfd6fe5322b5dd666d9f29"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read__at.html#ga8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a></td></tr>
<tr class="separator:ga8dcdb41a4adfd6fe5322b5dd666d9f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf62a75ad736aff941c1f70d4b3c223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#gafbf62a75ad736aff941c1f70d4b3c223">delim</a></td></tr>
<tr class="separator:gafbf62a75ad736aff941c1f70d4b3c223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga950b81fb954e4a0f01e13a57e15721b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a></td></tr>
<tr class="separator:ga950b81fb954e4a0f01e13a57e15721b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65c0ded2d2baf1e7bd7141628710c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#aa65c0ded2d2baf1e7bd7141628710c64">ASIO_READ_HANDLER_CHECK</a> (ReadHandler, handler) type_check</td></tr>
<tr class="separator:aa65c0ded2d2baf1e7bd7141628710c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae608ba848ec0b5f26a2e6f213dcf6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1detail_1_1async__result__init.html">detail::async_result_init</a>&lt; ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#abae608ba848ec0b5f26a2e6f213dcf6d">init</a> (<a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(ReadHandler)(handler))</td></tr>
<tr class="separator:abae608ba848ec0b5f26a2e6f213dcf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4f135fc124cc60e4e00dc2dbb309f354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a> <a class="el" href="namespaceasio.html#a4f135fc124cc60e4e00dc2dbb309f354">asio::signal_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of a signal set. </p>

<p>Definition at line <a class="el" href="signal__set_8hpp_source.html#l00024">24</a> of file <a class="el" href="signal__set_8hpp_source.html">signal_set.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3be3fa00c86ab58ba41aabe8fcbf11be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1io__service_1_1strand.html">asio::io_service::strand</a> <a class="el" href="namespaceasio.html#a3be3fa00c86ab58ba41aabe8fcbf11be">asio::strand</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use <a class="el" href="classasio_1_1io__service_1_1strand.html" title="Provides serialised handler execution. ">asio::io_service::strand</a>.) Typedef for backwards compatibility. </p>

<p>Definition at line <a class="el" href="strand_8hpp_source.html#l00246">246</a> of file <a class="el" href="strand_8hpp_source.html">strand.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a7ba348943527312eeace3492bf32ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a> <a class="el" href="namespaceasio.html#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a>. </p>

<p>Definition at line <a class="el" href="streambuf_8hpp_source.html#l00027">27</a> of file <a class="el" href="streambuf_8hpp_source.html">streambuf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41e285c1148c5ff12c443f3bfa9bdd9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; <a class="el" href="classasio_1_1detail_1_1wrapped__handler.html">detail::wrapped_handler</a>&lt; <a class="el" href="classasio_1_1io__service_1_1strand.html">io_service::strand</a>, void(*)(), <a class="el" href="structasio_1_1detail_1_1is__continuation__if__running.html">detail::is_continuation_if_running</a>&gt; &gt; <a class="el" href="namespaceasio.html#a41e285c1148c5ff12c443f3bfa9bdd9a">asio::yield_context</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="spawn_8hpp_source.html#l00139">139</a> of file <a class="el" href="spawn_8hpp_source.html">spawn.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acb48bc8e931affee7ab772dd7706bb74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::add_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;&#160;</td>
          <td class="paramname"><em>ios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Service *&#160;</td>
          <td class="paramname"><em>svc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to add a service to the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>The <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> object that owns the service.</td></tr>
    <tr><td class="paramname">svc</td><td>The service object. On success, ownership of the service object is transferred to the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a>. When the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> object is destroyed, it will destroy the service object by performing: <div class="fragment"><div class="line"><span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>io_service::service*<span class="keyword">&gt;</span>(svc) </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1service__already__exists.html" title="Exception thrown when trying to add a duplicate service to an io_service. ">asio::service_already_exists</a></td><td>Thrown if a service of the given type is already present in the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="classasio_1_1invalid__service__owner.html">asio::invalid_service_owner</a></td><td>Thrown if the service's owning <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> is not the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> object specified by the ios parameter. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="impl_2io__service_8hpp_source.html#l00043">43</a> of file <a class="el" href="impl_2io__service_8hpp_source.html">io_service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a825c2034d7e4609cb65e53ec2cf833bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * asio::asio_handler_allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default allocation function for handlers. </p>
<p>Asynchronous operations may need to allocate temporary objects. Since asynchronous operations have a handler function object, these temporary objects can be said to be associated with the handler.</p>
<p>Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for these temporary objects.</p>
<p>The default implementation of these allocation hooks uses <code>::operator new</code> and <code>::operator delete</code>.</p>
<dl class="section note"><dt>Note</dt><dd>All temporary objects associated with a handler will be deallocated before the upcall to the handler is performed. This allows the same memory to be reused for a subsequent asynchronous operation initiated by the handler.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span>* <a class="code" href="namespaceasio.html#a825c2034d7e4609cb65e53ec2cf833bf">asio_handler_allocate</a>(std::size_t size, my_handler* context)</div>
<div class="line">{</div>
<div class="line">  return ::operator <span class="keyword">new</span>(<a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceasio.html#a1316007445a73023bc5603a69c97d9b7">asio_handler_deallocate</a>(<span class="keywordtype">void</span>* pointer, std::size_t size,</div>
<div class="line">    my_handler* context)</div>
<div class="line">{</div>
<div class="line">  ::operator <span class="keyword">delete</span>(pointer);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="handler__alloc__hook_8ipp_source.html#l00038">38</a> of file <a class="el" href="handler__alloc__hook_8ipp_source.html">handler_alloc_hook.ipp</a>.</p>

</div>
</div>
<a class="anchor" id="a1316007445a73023bc5603a69c97d9b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asio::asio_handler_deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default deallocation function for handlers. </p>
<p>Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for the associated temporary objects.</p>
<p>The default implementation of these allocation hooks uses <code>::operator new</code> and <code>::operator delete</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceasio.html#a825c2034d7e4609cb65e53ec2cf833bf" title="Default allocation function for handlers. ">asio_handler_allocate</a>. </dd></dl>

<p>Definition at line <a class="el" href="handler__alloc__hook_8ipp_source.html#l00055">55</a> of file <a class="el" href="handler__alloc__hook_8ipp_source.html">handler_alloc_hook.ipp</a>.</p>

</div>
</div>
<a class="anchor" id="a7613e3b437b2491c154e056f1a26668f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::asio_handler_is_continuation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default continuation function for handlers. </p>
<p>Asynchronous operations may represent a continuation of the asynchronous control flow associated with the current handler. The implementation can use this knowledge to optimise scheduling of the handler.</p>
<p>Implement asio_handler_is_continuation for your own handlers to indicate when a handler represents a continuation.</p>
<p>The default implementation of the continuation hook returns <code>false</code>.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a>(my_handler* context)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="handler__continuation__hook_8hpp_source.html#l00045">45</a> of file <a class="el" href="handler__continuation__hook_8hpp_source.html">handler_continuation_hook.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d02e61810aed938d944fa2dae09d66c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void()&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2io__service_8hpp_source.html#l00077">77</a> of file <a class="el" href="impl_2io__service_8hpp_source.html">io_service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83cc551c7151133f0292ec21e4d08647"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2buffered__write__stream_8hpp_source.html#l00128">128</a> of file <a class="el" href="impl_2buffered__write__stream_8hpp_source.html">buffered_write_stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a461c3a69a56dac355730dd6bbddf4ec3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2buffered__read__stream_8hpp_source.html#l00142">142</a> of file <a class="el" href="impl_2buffered__read__stream_8hpp_source.html">buffered_read_stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae155d327b1f08e08ca04fad48cf39b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence , typename WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2buffered__write__stream_8hpp_source.html#l00286">286</a> of file <a class="el" href="impl_2buffered__write__stream_8hpp_source.html">buffered_write_stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7deb94f1e4f209ff535c2fd9ac06ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2buffered__read__stream_8hpp_source.html#l00300">300</a> of file <a class="el" href="impl_2buffered__read__stream_8hpp_source.html">buffered_read_stream.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d6099d23e9bf78b2b1ad82d164d3d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt;BufferSequence&gt; asio::buffers_begin </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the beginning of the buffers' data. </p>

<p>Definition at line <a class="el" href="buffers__iterator_8hpp_source.html#l00463">463</a> of file <a class="el" href="buffers__iterator_8hpp_source.html">buffers_iterator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ef4b181d4561848de38fac7907d4a0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt;BufferSequence&gt; asio::buffers_end </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the end of the buffers' data. </p>

<p>Definition at line <a class="el" href="buffers__iterator_8hpp_source.html#l00471">471</a> of file <a class="el" href="buffers__iterator_8hpp_source.html">buffers_iterator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab95c6736198fcded5573a1d43fe25ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1read__until__match__op.html">detail::read_until_match_op</a>&lt;AsyncReadStream, Allocator, MatchCondition, <a class="el" href="handler__type_8hpp.html#a3e8a48d0097c0be0da56b81efe2c183e">ASIO_HANDLER_TYPE</a>(ReadHandler, void (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t))&gt; ( <a class="el" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a>, init.handler)( asio return <a class="el" href="namespaceasio.html#abae608ba848ec0b5f26a2e6f213dcf6d">init</a> result asio::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae99c6070cedcd4c0ba471a8e41f66e9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::has_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;&#160;</td>
          <td class="paramname"><em>ios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to determine whether the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> contains a service object corresponding to the given service type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>The <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> contains the service. </dd></dl>

<p>Definition at line <a class="el" href="impl_2io__service_8hpp_source.html#l00053">53</a> of file <a class="el" href="impl_2io__service_8hpp_source.html">io_service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a951615f7e517dd14f0a1c3ceaa538145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;Elem, Traits&gt;&amp; asio::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output an error code. </p>

<p>Definition at line <a class="el" href="error__code_8hpp_source.html#l00169">169</a> of file <a class="el" href="error__code_8hpp_source.html">error_code.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cf92f0e55c9196057b27a1d35997824"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_size_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="basic__streambuf_8hpp_source.html#l00356">356</a> of file <a class="el" href="basic__streambuf_8hpp_source.html">basic_streambuf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1776aa9a745f4da041978ce17abc44ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1error__category.html">error_category</a> &amp; asio::system_category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error category used for the system errors produced by asio. </p>

<p>Definition at line <a class="el" href="error__code_8ipp_source.html#l00118">118</a> of file <a class="el" href="error__code_8ipp_source.html">error_code.ipp</a>.</p>

</div>
</div>
<a class="anchor" id="af58b7928a252af75bd55864260c19685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;&#160;</td>
          <td class="paramname"><em>ios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> will create a new instance of the service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>The <a class="el" href="classasio_1_1io__service.html" title="Provides core I/O functionality. ">io_service</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. </dd></dl>

<p>Definition at line <a class="el" href="impl_2io__service_8hpp_source.html#l00026">26</a> of file <a class="el" href="impl_2io__service_8hpp_source.html">io_service.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc0262ce1729113b74df9d11992c95d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceasio_1_1detail.html#a6d61d9b8e53c11288be549d82aec5a42">detail::io_service_impl</a>&amp; <a class="el" href="namespaceasio.html#af58b7928a252af75bd55864260c19685">asio::use_service</a>&lt; <a class="el" href="namespaceasio_1_1detail.html#a6d61d9b8e53c11288be549d82aec5a42">detail::io_service_impl</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__service.html">io_service</a> &amp;&#160;</td>
          <td class="paramname"><em>ios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2io__service_8hpp_source.html#l00036">36</a> of file <a class="el" href="impl_2io__service_8hpp_source.html">io_service.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aa65c0ded2d2baf1e7bd7141628710c64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt;Allocator&gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt;MatchCondition&gt;::value&gt;::type* asio::ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abae608ba848ec0b5f26a2e6f213dcf6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1detail_1_1async__result__init.html">detail::async_result_init</a>&lt; ReadHandler, void (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&gt; asio::init(<a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(ReadHandler)(handler))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceasio.html">asio</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
