<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Basic Phrase Based Decoding: uva::smt::bpbd::server::decoder::stack::stack_level Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="owl.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Basic Phrase Based Decoding
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ client/server language translation infrastructure</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uva::smt::bpbd::server::decoder::stack::stack_level Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b4a0804fe2e2ff95adcea7524bde943"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a0b4a0804fe2e2ff95adcea7524bde943">stack_level</a> (const <a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder.html#aaf4d5faf3a48156401c854d163d4b848">de_parameters</a> &amp;params, <a class="el" href="namespaceuva_1_1utils_1_1threads.html#a1c174d3a90b2b056554d897188ad2c74">acr_bool_flag</a> is_stop)</td></tr>
<tr class="separator:a0b4a0804fe2e2ff95adcea7524bde943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3e904bae304d82a82512b930512119"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a0c3e904bae304d82a82512b930512119">~stack_level</a> ()</td></tr>
<tr class="separator:a0c3e904bae304d82a82512b930512119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf7e806780c481ad3e1107c240b76da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a7bf7e806780c481ad3e1107c240b76da">add_state</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> new_state)</td></tr>
<tr class="separator:a7bf7e806780c481ad3e1107c240b76da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69347391556956dd6307a7e964d2847c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a69347391556956dd6307a7e964d2847c">expand</a> ()</td></tr>
<tr class="separator:a69347391556956dd6307a7e964d2847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b62b70fda5f4d743e86a6a65a95071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#af9b62b70fda5f4d743e86a6a65a95071">get_best_trans</a> (string &amp;target_sent) const </td></tr>
<tr class="separator:af9b62b70fda5f4d743e86a6a65a95071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef60eb980e7e283c59a5b0a1db12c42b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#aef60eb980e7e283c59a5b0a1db12c42b">get_size</a> () const </td></tr>
<tr class="separator:aef60eb980e7e283c59a5b0a1db12c42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:add73733b755d8835ca3b5c2339736451"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#add73733b755d8835ca3b5c2339736451">find_recombine</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> &amp;curr_state, <a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#a30416dfcace69691af43f9f44a076f7e">stack_state</a> &amp;new_state)</td></tr>
<tr class="separator:add73733b755d8835ca3b5c2339736451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a33e33ce484e82bae8315e8d3b25308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a4a33e33ce484e82bae8315e8d3b25308">add_last</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> new_state)</td></tr>
<tr class="separator:a4a33e33ce484e82bae8315e8d3b25308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552d8f4cfe4ff1680623bf747e578b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a552d8f4cfe4ff1680623bf747e578b73">add_before</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> curr_state, <a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> new_state)</td></tr>
<tr class="separator:a552d8f4cfe4ff1680623bf747e578b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaa5c1fade73f6643f6d31795a0fc2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#abbaa5c1fade73f6643f6d31795a0fc2e">remember_best_score</a> ()</td></tr>
<tr class="separator:abbaa5c1fade73f6643f6d31795a0fc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a550b351762d3d456535f33df7b9fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a0a550b351762d3d456535f33df7b9fd5">is_space_left</a> () const </td></tr>
<tr class="separator:a0a550b351762d3d456535f33df7b9fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1312ea6fdd24e8d91c81564525e7edaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a1312ea6fdd24e8d91c81564525e7edaf">prune_states</a> ()</td></tr>
<tr class="separator:a1312ea6fdd24e8d91c81564525e7edaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac487fa956e94d7840ac4190137502d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#ac487fa956e94d7840ac4190137502d51">insert_as_first</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> state)</td></tr>
<tr class="separator:ac487fa956e94d7840ac4190137502d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a44b9204f548253eae6b3816a39af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a65a44b9204f548253eae6b3816a39af7">insert_as_last</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> state)</td></tr>
<tr class="separator:a65a44b9204f548253eae6b3816a39af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0055e713c18c42277d21b34d214a5ff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a0055e713c18c42277d21b34d214a5ff0">insert_between</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> prev, <a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> next, <a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> state)</td></tr>
<tr class="separator:a0055e713c18c42277d21b34d214a5ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34db813fc46305cf50e782f700f6b71b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a34db813fc46305cf50e782f700f6b71b">insert_before</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> curr_state, <a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> new_state)</td></tr>
<tr class="separator:a34db813fc46305cf50e782f700f6b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07981c21a1c88317159af94b53177fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html#a07981c21a1c88317159af94b53177fdc">remove_from_level</a> (<a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> state)</td></tr>
<tr class="separator:a07981c21a1c88317159af94b53177fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the multi-stack level </p>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00045">45</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0b4a0804fe2e2ff95adcea7524bde943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uva::smt::bpbd::server::decoder::stack::stack_level::stack_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder.html#aaf4d5faf3a48156401c854d163d4b848">de_parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1utils_1_1threads.html#a1c174d3a90b2b056554d897188ad2c74">acr_bool_flag</a>&#160;</td>
          <td class="paramname"><em>is_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The basic constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>the decoder parameters, stores the reference to it </td></tr>
    <tr><td class="paramname">is_stop</td><td>the stop flag </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00053">53</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c3e904bae304d82a82512b930512119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uva::smt::bpbd::server::decoder::stack::stack_level::~stack_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The basic destructor, this implementation is iterative. </p>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00062">62</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a552d8f4cfe4ff1680623bf747e578b73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::add_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>curr_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to add a new state to the level before some existing state. The new state is to have a bigger weight that the provided current state and is to be non equal (recombinable) to any other state before. This method makes sure that any state after the new one will be checked for a possible recombination to the new one, if yes the recombination will be done. Pruning is performed unconditionally. We known that the state satisfies the total weight threshold. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_state</td><td>the pointer to the state, not NULL, we need to add the new state prior to. </td></tr>
    <tr><td class="paramname">new_state</td><td>the pointer to the new state, not NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00252">252</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a33e33ce484e82bae8315e8d3b25308"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::add_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>new_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to add the new state as the last one to the level. This new state is to have the smallest weight that all the other states in the level and is not to be equal (recombinable) to any other state to the level. Note that we know that the new state cost is within the current threshold bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_state</td><td>the new state to add as the last one, if satisfies the pruning thresholds. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00222">222</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bf7e806780c481ad3e1107c240b76da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::add_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>new_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to add a new state into the level </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_state</td><td>the new state to add </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00082">82</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69347391556956dd6307a7e964d2847c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::expand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to expand the stack elements, to do that this method just goes through all the stack elements one by one and expands them. We could have done this recursively but this way we avoid stack allocations so we might be just faster. </p>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00134">134</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add73733b755d8835ca3b5c2339736451"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uva::smt::bpbd::server::decoder::stack::stack_level::find_recombine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#a30416dfcace69691af43f9f44a076f7e">stack_state</a> &amp;&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method allows to search for a position to insert the new state into. We known that the state satisfies the total weight threshold. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_state</td><td>[out] </td></tr>
    <tr><td class="paramname">new_state</td><td>[in] the new state to be inserted into the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the new state was recombined into an existing one, otherwise false. </dd></dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00186">186</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9b62b70fda5f4d743e86a6a65a95071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::get_best_trans </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>target_sent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to get the best translation target string for this stack. To do that, it takes the first element/state in the level's ordered by costs stack and asks it to unroll itself to give its translation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_sent</td><td>[out] the variable to store the translation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00158">158</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef60eb980e7e283c59a5b0a1db12c42b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t uva::smt::bpbd::server::decoder::stack::stack_level::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method allows to retrieve the number of stack level elements </p><dl class="section return"><dt>Returns</dt><dd>the number of stack level elements. </dd></dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00173">173</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac487fa956e94d7840ac4190137502d51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::insert_as_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to insert the stack state as the first one in the level This method increments the level size counter. Updates the best score! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state to insert </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00359">359</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65a44b9204f548253eae6b3816a39af7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::insert_as_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to insert the stack state as the last one in the level This method increments the level size counter. Updates the best score! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state to insert </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00394">394</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34db813fc46305cf50e782f700f6b71b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>curr_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to insert a new element before the given stack element in the level list This method increments the level size counter. Updates the best score! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_state</td><td>the state before which the new state is to be inserted, not NULL </td></tr>
    <tr><td class="paramname">new_state</td><td>the state to be inserted, NOT NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00460">460</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0055e713c18c42277d21b34d214a5ff0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::insert_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to insert the stack state in between the given two elements Note that the next and previous states are to be different! This method increments the level size counter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>the pointer reference to the prev state, NOT NULL </td></tr>
    <tr><td class="paramname">next</td><td>the pointer reference to the next state, NOT NULL </td></tr>
    <tr><td class="paramname">state</td><td>the state to insert, NUL NULL </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00428">428</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a550b351762d3d456535f33df7b9fd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uva::smt::bpbd::server::decoder::stack::stack_level::is_space_left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to check if there is still space left for adding states into the level If there is no space left then we can still add states but we shall do histogram pruning afterwards in order to keep the stack size within the capacity limits. </p><dl class="section return"><dt>Returns</dt><dd>true if there is empty space left for adding states </dd></dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00315">315</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1312ea6fdd24e8d91c81564525e7edaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::prune_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method makes sure there is not too many elements in the stack, the last ones are removed. This method decrements the level size counter. </p>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00326">326</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbaa5c1fade73f6643f6d31795a0fc2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::remember_best_score </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to update the best score, or rather threshold for threshold pruning. </p>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00297">297</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07981c21a1c88317159af94b53177fdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uva::smt::bpbd::server::decoder::stack::stack_level::remove_from_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html#ab08047a5fae45b1c4311bd5d5aa2c4fc">stack_state_ptr</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to remove the given state from the level. The state is not destroyed, its memory is not deleted. This method decrements the level size counter. The given state must be within the level list of states! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state to be destroyed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__level_8hpp_source.html#l00480">480</a> of file <a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>inc/server/decoder/stack/<a class="el" href="stack__level_8hpp_source.html">stack_level.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceuva.html">uva</a></li><li class="navelem"><a class="el" href="namespaceuva_1_1smt.html">smt</a></li><li class="navelem"><a class="el" href="namespaceuva_1_1smt_1_1bpbd.html">bpbd</a></li><li class="navelem"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server.html">server</a></li><li class="navelem"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder.html">decoder</a></li><li class="navelem"><a class="el" href="namespaceuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack.html">stack</a></li><li class="navelem"><a class="el" href="classuva_1_1smt_1_1bpbd_1_1server_1_1decoder_1_1stack_1_1stack__level.html">stack_level</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
