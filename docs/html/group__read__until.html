<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Basic Phrase Based Decoding: asio::read_until</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="owl.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Basic Phrase Based Decoding
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ client/server language translation infrastructure</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__read__until.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::read_until</div>  </div>
</div><!--header-->
<div class="contents">

<p>Read data into a streambuf until it contains a delimiter, matches a regular expression, or a function object indicates a match.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>
<tr class="memdesc:ga1aae2baa82596a6a9ad320e80b016006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">More...</a><br /></td></tr>
<tr class="separator:ga1aae2baa82596a6a9ad320e80b016006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">More...</a><br /></td></tr>
<tr class="separator:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga6f38642ad22fcb7f72ddc9fd2b586541">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const std::string &amp;delim)</td></tr>
<tr class="memdesc:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga6f38642ad22fcb7f72ddc9fd2b586541">More...</a><br /></td></tr>
<tr class="separator:ga6f38642ad22fcb7f72ddc9fd2b586541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27386e9b95114d7def2feee77e2dfd93"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga27386e9b95114d7def2feee77e2dfd93"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga27386e9b95114d7def2feee77e2dfd93">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const std::string &amp;delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga27386e9b95114d7def2feee77e2dfd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga27386e9b95114d7def2feee77e2dfd93">More...</a><br /></td></tr>
<tr class="separator:ga27386e9b95114d7def2feee77e2dfd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, typename enable_if&lt; is_match_condition&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">More...</a><br /></td></tr>
<tr class="separator:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; is_match_condition&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaacb23419d8878f33e469e3f743c738d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">More...</a><br /></td></tr>
<tr class="separator:gaacb23419d8878f33e469e3f743c738d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Read data into a streambuf until it contains a delimiter, matches a regular expression, or a function object indicates a match. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1aae2baa82596a6a9ad320e80b016006"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line"><a class="code" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">asio::read_until</a>(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, b, <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::istream is(&amp;b);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

<p>Definition at line <a class="el" href="impl_2read__until_8hpp_source.html#l00037">37</a> of file <a class="el" href="impl_2read__until_8hpp_source.html">read_until.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab9d265cc5b757caf9c9a602da2d6a3e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

<p>Definition at line <a class="el" href="impl_2read__until_8hpp_source.html#l00047">47</a> of file <a class="el" href="impl_2read__until_8hpp_source.html">read_until.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f38642ad22fcb7f72ddc9fd2b586541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line"><a class="code" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">asio::read_until</a>(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, b, <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::istream is(&amp;b);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

<p>Definition at line <a class="el" href="impl_2read__until_8hpp_source.html#l00093">93</a> of file <a class="el" href="impl_2read__until_8hpp_source.html">read_until.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga27386e9b95114d7def2feee77e2dfd93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

<p>Definition at line <a class="el" href="impl_2read__until_8hpp_source.html#l00138">138</a> of file <a class="el" href="impl_2read__until_8hpp_source.html">read_until.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaacb23419d8878f33e469e3f743c738d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a>(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

<p>Definition at line <a class="el" href="impl_2read__until_8hpp_source.html#l00264">264</a> of file <a class="el" href="impl_2read__until_8hpp_source.html">read_until.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5aa4b441eca98c82a144cb9a3c625db4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a>(iterator begin, iterator end);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"></div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator begin, iterator end)</div>
<div class="line">{</div>
<div class="line">  iterator i = <a class="code" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line"><a class="code" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">asio::read_until</a>(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, b, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = <a class="code" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line"><a class="code" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">asio::read_until</a>(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, b, match_char(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="impl_2read__until_8hpp_source.html#l00316">316</a> of file <a class="el" href="impl_2read__until_8hpp_source.html">read_until.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
