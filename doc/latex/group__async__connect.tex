\hypertarget{group__async__connect}{}\section{asio\+:\+:async\+\_\+connect}
\label{group__async__connect}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}


Asynchronously establishes a socket connection by trying each endpoint in a sequence.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Protocol , typename Socket\+Service , typename Iterator , typename Composed\+Connect\+Handler $>$ }\\\hyperlink{group__async__connect_ga7b8de8138419acd99224c0a7071a99a0}{asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E} (Composed\+Connect\+Handler, void(\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code}, Iterator)) async\+\_\+connect(basic\+\_\+socket$<$ Protocol
\item 
Socket\+Service Iterator \hyperlink{group__async__connect_ga62bf3d82e9459cfd1fc6f51024aceb25}{asio\+::\+A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G} (Composed\+Connect\+Handler) handler)
\item 
{\footnotesize template$<$typename Protocol , typename Socket\+Service , typename Iterator , typename Connect\+Condition , typename Composed\+Connect\+Handler $>$ }\\\hyperlink{group__async__connect_ga97861978f077050db440c518ba215350}{asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E} (Composed\+Connect\+Handler, void(\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code}, Iterator)) async\+\_\+connect(basic\+\_\+socket$<$ Protocol
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
Socket\+Service \& \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{asio\+::s}
\item 
Socket\+Service Iterator \hyperlink{group__async__connect_ga7055bca9225050c030c19c7dc926fa53}{asio\+::begin}
\item 
Socket\+Service Iterator Iterator \hyperlink{group__async__connect_gadb6ad0193229ae84828688e812cd325c}{asio\+::end}
\item 
Socket\+Service Iterator Connect\+Condition \hyperlink{group__async__connect_ga47e3dda205dfba3553f4c7e005897687}{asio\+::connect\+\_\+condition}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Asynchronously establishes a socket connection by trying each endpoint in a sequence. 



\subsection{Function Documentation}
\hypertarget{group__async__connect_ga7b8de8138419acd99224c0a7071a99a0}{}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}!A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}}
\index{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}!asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}
\subsubsection[{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E(\+Composed\+Connect\+Handler, void(asio\+::error\+\_\+code, Iterator)) async\+\_\+connect(basic\+\_\+socket$<$ Protocol}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Protocol , typename Socket\+Service , typename Iterator , typename Composed\+Connect\+Handler $>$ asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E (
\begin{DoxyParamCaption}
\item[{Composed\+Connect\+Handler}]{, }
\item[{void({\bf asio\+::error\+\_\+code}, Iterator)}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__async__connect_ga7b8de8138419acd99224c0a7071a99a0}
Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket\textquotesingle{}s {\ttfamily async\+\_\+connect} member function, once for each endpoint in the sequence, until a connection is successfully established.


\begin{DoxyParams}{Parameters}
{\em s} & The socket to be connected. If the socket is already open, it will be closed.\\
\hline
{\em begin} & An iterator pointing to the start of a sequence of endpoints.\\
\hline
{\em handler} & The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation. if the sequence is empty, set to}
  \textcolor{comment}{// asio::error::not\_found. Otherwise, contains the}
  \textcolor{comment}{// error from the last connection attempt.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// On success, an iterator denoting the successfully}
  \textcolor{comment}{// connected endpoint. Otherwise, the end iterator.}
  Iterator iterator
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This overload assumes that a default constructed object of type {\ttfamily Iterator} represents the end of the sequence. This is a valid assumption for iterator types such as {\ttfamily \hyperlink{classasio_1_1ip_1_1basic__resolver_ad1cc50a31ba4971329a34eb01ef5a21c}{asio\+::ip\+::tcp\+::resolver\+::iterator}}.
\end{DoxyNote}
\begin{DoxyParagraph}{Example}

\begin{DoxyCode}
 tcp::resolver r(io\_service);
tcp::resolver::query q(\textcolor{stringliteral}{"host"}, \textcolor{stringliteral}{"service"});
\hyperlink{namespacewebsocketpp_1_1transport_1_1asio_1_1socket_1_1error_a828ddaa5ed63a761e1b557465a35f05aa0c31b356014843e1d09514e794a539a7}{tcp::socket} \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}(io\_service);

\textcolor{comment}{// ...}

r.async\_resolve(q, resolve\_handler);

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} resolve\_handler(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{keywordflow}{if} (!ec)
  \{
    asio::async\_connect(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, i, \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler});
  \}
\}

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler}(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{comment}{// ...}
\} 
\end{DoxyCode}

\end{DoxyParagraph}
Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket\textquotesingle{}s {\ttfamily async\+\_\+connect} member function, once for each endpoint in the sequence, until a connection is successfully established.


\begin{DoxyParams}{Parameters}
{\em s} & The socket to be connected. If the socket is already open, it will be closed.\\
\hline
{\em begin} & An iterator pointing to the start of a sequence of endpoints.\\
\hline
{\em end} & An iterator pointing to the end of a sequence of endpoints.\\
\hline
{\em handler} & The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation. if the sequence is empty, set to}
  \textcolor{comment}{// asio::error::not\_found. Otherwise, contains the}
  \textcolor{comment}{// error from the last connection attempt.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// On success, an iterator denoting the successfully}
  \textcolor{comment}{// connected endpoint. Otherwise, the end iterator.}
  Iterator iterator
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyParagraph}{Example}

\begin{DoxyCode}
 tcp::resolver r(io\_service);
tcp::resolver::query q(\textcolor{stringliteral}{"host"}, \textcolor{stringliteral}{"service"});
\hyperlink{namespacewebsocketpp_1_1transport_1_1asio_1_1socket_1_1error_a828ddaa5ed63a761e1b557465a35f05aa0c31b356014843e1d09514e794a539a7}{tcp::socket} \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}(io\_service);

\textcolor{comment}{// ...}

r.async\_resolve(q, resolve\_handler);

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} resolve\_handler(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{keywordflow}{if} (!ec)
  \{
    tcp::resolver::iterator \hyperlink{group__async__connect_gadb6ad0193229ae84828688e812cd325c}{end};
    asio::async\_connect(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, i, end, \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler});
  \}
\}

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler}(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{comment}{// ...}
\} 
\end{DoxyCode}
 
\end{DoxyParagraph}
\hypertarget{group__async__connect_ga97861978f077050db440c518ba215350}{}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}!A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}}
\index{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}!asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}
\subsubsection[{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E(\+Composed\+Connect\+Handler, void(asio\+::error\+\_\+code, Iterator)) async\+\_\+connect(basic\+\_\+socket$<$ Protocol}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Protocol , typename Socket\+Service , typename Iterator , typename Connect\+Condition , typename Composed\+Connect\+Handler $>$ asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E (
\begin{DoxyParamCaption}
\item[{Composed\+Connect\+Handler}]{, }
\item[{void({\bf asio\+::error\+\_\+code}, Iterator)}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__async__connect_ga97861978f077050db440c518ba215350}
Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket\textquotesingle{}s {\ttfamily async\+\_\+connect} member function, once for each endpoint in the sequence, until a connection is successfully established.


\begin{DoxyParams}{Parameters}
{\em s} & The socket to be connected. If the socket is already open, it will be closed.\\
\hline
{\em begin} & An iterator pointing to the start of a sequence of endpoints.\\
\hline
{\em connect\+\_\+condition} & A function object that is called prior to each connection attempt. The signature of the function object must be\+: 
\begin{DoxyCode}
Iterator \hyperlink{group__async__connect_ga47e3dda205dfba3553f4c7e005897687}{connect\_condition}(
   \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
   Iterator next); 
\end{DoxyCode}
 The {\ttfamily ec} parameter contains the result from the most recent connect operation. Before the first connection attempt, {\ttfamily ec} is always set to indicate success. The {\ttfamily next} parameter is an iterator pointing to the next endpoint to be tried. The function object should return the next iterator, but is permitted to return a different iterator so that endpoints may be skipped. The implementation guarantees that the function object will never be called with the end iterator.\\
\hline
{\em handler} & The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation. if the sequence is empty, set to}
  \textcolor{comment}{// asio::error::not\_found. Otherwise, contains the}
  \textcolor{comment}{// error from the last connection attempt.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// On success, an iterator denoting the successfully}
  \textcolor{comment}{// connected endpoint. Otherwise, the end iterator.}
  Iterator iterator
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This overload assumes that a default constructed object of type {\ttfamily Iterator} represents the end of the sequence. This is a valid assumption for iterator types such as {\ttfamily \hyperlink{classasio_1_1ip_1_1basic__resolver_ad1cc50a31ba4971329a34eb01ef5a21c}{asio\+::ip\+::tcp\+::resolver\+::iterator}}.
\end{DoxyNote}
\begin{DoxyParagraph}{Example}
The following connect condition function object can be used to output information about the individual connection attempts\+: 
\begin{DoxyCode}
 \textcolor{keyword}{struct }my\_connect\_condition
\{
  \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>
  Iterator operator()(
      \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
      Iterator next)
  \{
    \textcolor{keywordflow}{if} (ec) std::cout << \textcolor{stringliteral}{"Error: "} << ec.\hyperlink{classasio_1_1error__code_a9e15b346b9ec23275530835d9c150711}{message}() << std::endl;
    std::cout << \textcolor{stringliteral}{"Trying: "} << next->endpoint() << std::endl;
    \textcolor{keywordflow}{return} next;
  \}
\}; 
\end{DoxyCode}
 It would be used with the \hyperlink{group__connect_ga29acd61d7a875cef7dbd1f892be2906c}{asio\+::connect} function as follows\+: 
\begin{DoxyCode}
 tcp::resolver r(io\_service);
tcp::resolver::query q(\textcolor{stringliteral}{"host"}, \textcolor{stringliteral}{"service"});
\hyperlink{namespacewebsocketpp_1_1transport_1_1asio_1_1socket_1_1error_a828ddaa5ed63a761e1b557465a35f05aa0c31b356014843e1d09514e794a539a7}{tcp::socket} \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}(io\_service);

\textcolor{comment}{// ...}

r.async\_resolve(q, resolve\_handler);

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} resolve\_handler(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{keywordflow}{if} (!ec)
  \{
    asio::async\_connect(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, i,
        my\_connect\_condition(),
        \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler});
  \}
\}

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler}(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{keywordflow}{if} (ec)
  \{
    \textcolor{comment}{// An error occurred.}
  \}
  \textcolor{keywordflow}{else}
  \{
    std::cout << \textcolor{stringliteral}{"Connected to: "} << i->endpoint() << std::endl;
  \}
\} 
\end{DoxyCode}

\end{DoxyParagraph}
Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket\textquotesingle{}s {\ttfamily async\+\_\+connect} member function, once for each endpoint in the sequence, until a connection is successfully established.


\begin{DoxyParams}{Parameters}
{\em s} & The socket to be connected. If the socket is already open, it will be closed.\\
\hline
{\em begin} & An iterator pointing to the start of a sequence of endpoints.\\
\hline
{\em end} & An iterator pointing to the end of a sequence of endpoints.\\
\hline
{\em connect\+\_\+condition} & A function object that is called prior to each connection attempt. The signature of the function object must be\+: 
\begin{DoxyCode}
Iterator \hyperlink{group__async__connect_ga47e3dda205dfba3553f4c7e005897687}{connect\_condition}(
   \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
   Iterator next); 
\end{DoxyCode}
 The {\ttfamily ec} parameter contains the result from the most recent connect operation. Before the first connection attempt, {\ttfamily ec} is always set to indicate success. The {\ttfamily next} parameter is an iterator pointing to the next endpoint to be tried. The function object should return the next iterator, but is permitted to return a different iterator so that endpoints may be skipped. The implementation guarantees that the function object will never be called with the end iterator.\\
\hline
{\em handler} & The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation. if the sequence is empty, set to}
  \textcolor{comment}{// asio::error::not\_found. Otherwise, contains the}
  \textcolor{comment}{// error from the last connection attempt.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// On success, an iterator denoting the successfully}
  \textcolor{comment}{// connected endpoint. Otherwise, the end iterator.}
  Iterator iterator
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyParagraph}{Example}
The following connect condition function object can be used to output information about the individual connection attempts\+: 
\begin{DoxyCode}
 \textcolor{keyword}{struct }my\_connect\_condition
\{
  \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>
  Iterator operator()(
      \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
      Iterator next)
  \{
    \textcolor{keywordflow}{if} (ec) std::cout << \textcolor{stringliteral}{"Error: "} << ec.\hyperlink{classasio_1_1error__code_a9e15b346b9ec23275530835d9c150711}{message}() << std::endl;
    std::cout << \textcolor{stringliteral}{"Trying: "} << next->endpoint() << std::endl;
    \textcolor{keywordflow}{return} next;
  \}
\}; 
\end{DoxyCode}
 It would be used with the \hyperlink{group__connect_ga29acd61d7a875cef7dbd1f892be2906c}{asio\+::connect} function as follows\+: 
\begin{DoxyCode}
 tcp::resolver r(io\_service);
tcp::resolver::query q(\textcolor{stringliteral}{"host"}, \textcolor{stringliteral}{"service"});
\hyperlink{namespacewebsocketpp_1_1transport_1_1asio_1_1socket_1_1error_a828ddaa5ed63a761e1b557465a35f05aa0c31b356014843e1d09514e794a539a7}{tcp::socket} \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}(io\_service);

\textcolor{comment}{// ...}

r.async\_resolve(q, resolve\_handler);

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} resolve\_handler(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{keywordflow}{if} (!ec)
  \{
    tcp::resolver::iterator \hyperlink{group__async__connect_gadb6ad0193229ae84828688e812cd325c}{end};
    asio::async\_connect(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, i, end,
        my\_connect\_condition(),
        \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler});
  \}
\}

\textcolor{comment}{// ...}

\textcolor{keywordtype}{void} \hyperlink{namespacewebsocketpp_1_1transport_ac392fca34e946b48414278c0c3addfa5}{connect\_handler}(
    \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& ec,
    tcp::resolver::iterator i)
\{
  \textcolor{keywordflow}{if} (ec)
  \{
    \textcolor{comment}{// An error occurred.}
  \}
  \textcolor{keywordflow}{else}
  \{
    std::cout << \textcolor{stringliteral}{"Connected to: "} << i->endpoint() << std::endl;
  \}
\} 
\end{DoxyCode}
 
\end{DoxyParagraph}
\hypertarget{group__async__connect_ga62bf3d82e9459cfd1fc6f51024aceb25}{}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}!A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G@{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}}
\index{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G@{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}!asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}
\subsubsection[{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G(\+Composed\+Connect\+Handler) handler)}]{\setlength{\rightskip}{0pt plus 5cm}Socket\+Service Iterator asio\+::\+A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G (
\begin{DoxyParamCaption}
\item[{Composed\+Connect\+Handler}]{}
\end{DoxyParamCaption}
)}\label{group__async__connect_ga62bf3d82e9459cfd1fc6f51024aceb25}


Definition at line 326 of file connect.\+hpp.



\subsection{Variable Documentation}
\hypertarget{group__async__connect_ga7055bca9225050c030c19c7dc926fa53}{}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}!begin@{begin}}
\index{begin@{begin}!asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}
\subsubsection[{begin}]{\setlength{\rightskip}{0pt plus 5cm}Socket\+Service Iterator asio\+::begin}\label{group__async__connect_ga7055bca9225050c030c19c7dc926fa53}


Definition at line 521 of file connect.\+hpp.

\hypertarget{group__async__connect_ga47e3dda205dfba3553f4c7e005897687}{}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}!connect\+\_\+condition@{connect\+\_\+condition}}
\index{connect\+\_\+condition@{connect\+\_\+condition}!asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}
\subsubsection[{connect\+\_\+condition}]{\setlength{\rightskip}{0pt plus 5cm}Socket\+Service Iterator Iterator Connect\+Condition asio\+::connect\+\_\+condition}\label{group__async__connect_ga47e3dda205dfba3553f4c7e005897687}


Definition at line 702 of file connect.\+hpp.

\hypertarget{group__async__connect_gadb6ad0193229ae84828688e812cd325c}{}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}!end@{end}}
\index{end@{end}!asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}
\subsubsection[{end}]{\setlength{\rightskip}{0pt plus 5cm}Socket\+Service Iterator Iterator asio\+::end}\label{group__async__connect_gadb6ad0193229ae84828688e812cd325c}


Definition at line 592 of file connect.\+hpp.

\hypertarget{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{}\index{asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}!s@{s}}
\index{s@{s}!asio\+::async\+\_\+connect@{asio\+::async\+\_\+connect}}
\subsubsection[{s}]{\setlength{\rightskip}{0pt plus 5cm}Socket\+Service \& asio\+::s}\label{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}


Definition at line 521 of file connect.\+hpp.

