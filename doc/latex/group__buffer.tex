\hypertarget{group__buffer}{}\section{asio\+:\+:buffer}
\label{group__buffer}\index{asio\+::buffer@{asio\+::buffer}}


The \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio\+::buffer} function is used to create a buffer object to represent raw memory, an array of P\+O\+D elements, a vector of P\+O\+D elements, or a std\+::string.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio\+::buffer} (const mutable\+\_\+buffer \&b)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer from an existing buffer. \end{DoxyCompactList}\item 
mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gaf93a06eac8bd6d1db394ba92e260b9fa}{asio\+::buffer} (const mutable\+\_\+buffer \&b, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer from an existing buffer. \end{DoxyCompactList}\item 
const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gac00b079c860c589f80a312b975828780}{asio\+::buffer} (const const\+\_\+buffer \&b)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer from an existing buffer. \end{DoxyCompactList}\item 
const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gafe2a3b8cbb0e8aefbc870d5f43cf5872}{asio\+::buffer} (const const\+\_\+buffer \&b, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer from an existing buffer. \end{DoxyCompactList}\item 
mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gaa066734007c417692255c8f515f0fb01}{asio\+::buffer} (void $\ast$data, std\+::size\+\_\+t size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer that represents the given memory range. \end{DoxyCompactList}\item 
const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gaa6b6109423e7efc76b46b8d1337a5b0f}{asio\+::buffer} (const void $\ast$data, std\+::size\+\_\+t size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given memory range. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_ga9a348932d9b7ffda26ff318191489fd8}{asio\+::buffer} (Pod\+Type(\&data)\mbox{[}N\mbox{]})
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_ga817f0fd9a7e1eebab155ccf5b62456f0}{asio\+::buffer} (Pod\+Type(\&data)\mbox{[}N\mbox{]}, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gae73b5385bad9b7c92afce06d92c11f1e}{asio\+::buffer} (const Pod\+Type(\&data)\mbox{[}N\mbox{]})
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gae37e6d30503997261200b1c9a2492182}{asio\+::buffer} (const Pod\+Type(\&data)\mbox{[}N\mbox{]}, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gafec66696edfddf306d7c91aba75b1723}{asio\+::buffer} (\hyperlink{classboost_1_1array}{boost\+::array}$<$ Pod\+Type, N $>$ \&data)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gabcdc30c4b4b6a28885f65e7c8fe08cc2}{asio\+::buffer} (\hyperlink{classboost_1_1array}{boost\+::array}$<$ Pod\+Type, N $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_ga7b564725e9315afaad270e46161ac21c}{asio\+::buffer} (\hyperlink{classboost_1_1array}{boost\+::array}$<$ const Pod\+Type, N $>$ \&data)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gaf0529bedd017b4b01fd0920e35ed22cd}{asio\+::buffer} (\hyperlink{classboost_1_1array}{boost\+::array}$<$ const Pod\+Type, N $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gacee4fc886d2abc070fbabc77ebeb508d}{asio\+::buffer} (const \hyperlink{classboost_1_1array}{boost\+::array}$<$ Pod\+Type, N $>$ \&data)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gac7e496b244e3999f2035c29043cd2ff9}{asio\+::buffer} (const \hyperlink{classboost_1_1array}{boost\+::array}$<$ Pod\+Type, N $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D array. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , typename Allocator $>$ }\\mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_ga382ee4d2d0dd90e88e374e4344302749}{asio\+::buffer} (std\+::vector$<$ Pod\+Type, Allocator $>$ \&data)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer that represents the given P\+O\+D vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , typename Allocator $>$ }\\mutable\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gad0a0b6813e25e7bcce7fcfe32a5cdab9}{asio\+::buffer} (std\+::vector$<$ Pod\+Type, Allocator $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new modifiable buffer that represents the given P\+O\+D vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , typename Allocator $>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gaa908d4c98b0745c8c51540e153627f44}{asio\+::buffer} (const std\+::vector$<$ Pod\+Type, Allocator $>$ \&data)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Pod\+Type , typename Allocator $>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gad172ef969f244d265d3cfcfea727b904}{asio\+::buffer} (const std\+::vector$<$ Pod\+Type, Allocator $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given P\+O\+D vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem , typename Traits , typename Allocator $>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gafe609d07578ac226c777107fbe51eff5}{asio\+::buffer} (const std\+::basic\+\_\+string$<$ Elem, Traits, Allocator $>$ \&data)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given string. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem , typename Traits , typename Allocator $>$ }\\const\+\_\+buffers\+\_\+1 \hyperlink{group__buffer_gaa04e7aa3e90adacebceb59007629e923}{asio\+::buffer} (const std\+::basic\+\_\+string$<$ Elem, Traits, Allocator $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Create a new non-\/modifiable buffer that represents the given string. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio\+::buffer} function is used to create a buffer object to represent raw memory, an array of P\+O\+D elements, a vector of P\+O\+D elements, or a std\+::string. 

A buffer object represents a contiguous region of memory as a 2-\/tuple consisting of a pointer and size in bytes. A tuple of the form {\ttfamily \{void$\ast$, size\+\_\+t\}} specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form {\ttfamily \{const void$\ast$, size\+\_\+t\}} specifies a const (non-\/modifiable) region of memory. These two forms correspond to the classes \hyperlink{classasio_1_1mutable__buffer}{mutable\+\_\+buffer} and \hyperlink{classasio_1_1const__buffer}{const\+\_\+buffer}, respectively. To mirror C++\textquotesingle{}s conversion rules, a \hyperlink{classasio_1_1mutable__buffer}{mutable\+\_\+buffer} is implicitly convertible to a \hyperlink{classasio_1_1const__buffer}{const\+\_\+buffer}, and the opposite conversion is not permitted.

The simplest use case involves reading or writing a single buffer of a specified size\+:


\begin{DoxyCode}
sock.send(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(data, \hyperlink{namespaceuva_1_1utils_1_1containers_aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791}{size})); 
\end{DoxyCode}


In the above example, the return value of \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio\+::buffer} meets the requirements of the Const\+Buffer\+Sequence concept so that it may be directly passed to the socket\textquotesingle{}s write function. A buffer created for modifiable memory also meets the requirements of the Mutable\+Buffer\+Sequence concept.

An individual buffer may be created from a builtin array, std\+::vector, std\+::array or \hyperlink{classboost_1_1array}{boost\+::array} of P\+O\+D elements. This helps prevent buffer overruns by automatically determining the size of the buffer\+:


\begin{DoxyCode}
 \textcolor{keywordtype}{char} d1[128];
\textcolor{keywordtype}{size\_t} bytes\_transferred = sock.receive(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d1));

std::vector<char> d2(128);
bytes\_transferred = sock.receive(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d2));

std::array<char, 128> d3;
bytes\_transferred = sock.receive(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d3));

\hyperlink{classboost_1_1array}{boost::array<char, 128>} d4;
bytes\_transferred = sock.receive(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d4)); 
\end{DoxyCode}


In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is {\itshape never} automatically resized when creating or using a buffer. The buffer size is determined using the vector\textquotesingle{}s {\ttfamily \hyperlink{namespaceuva_1_1utils_1_1containers_aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791}{size()}} member function, and not its capacity.

\begin{DoxyParagraph}{Accessing Buffer Contents}

\end{DoxyParagraph}
The contents of a buffer may be accessed using the \hyperlink{group__buffer__size}{asio\+::buffer\+\_\+size} and \hyperlink{group__buffer__cast}{asio\+::buffer\+\_\+cast} functions\+:


\begin{DoxyCode}
 \hyperlink{classasio_1_1mutable__buffer}{asio::mutable\_buffer} b1 = ...;
std::size\_t s1 = \hyperlink{group__buffer__size_gabe8b5f116fbb66004b6d0ba8ee39c3d5}{asio::buffer\_size}(b1);
\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* p1 = \hyperlink{group__buffer__cast_ga6faa5f9daa2512cc9c3cefa8b5ab0704}{asio::buffer\_cast}<\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*>(b1);

\hyperlink{classasio_1_1const__buffer}{asio::const\_buffer} b2 = ...;
std::size\_t s2 = \hyperlink{group__buffer__size_gabe8b5f116fbb66004b6d0ba8ee39c3d5}{asio::buffer\_size}(b2);
\textcolor{keyword}{const} \textcolor{keywordtype}{void}* p2 = \hyperlink{group__buffer__cast_ga6faa5f9daa2512cc9c3cefa8b5ab0704}{asio::buffer\_cast}<\textcolor{keyword}{const} \textcolor{keywordtype}{void}*>(b2); 
\end{DoxyCode}


The \hyperlink{group__buffer__cast_ga6faa5f9daa2512cc9c3cefa8b5ab0704}{asio\+::buffer\+\_\+cast} function permits violations of type safety, so uses of it in application code should be carefully considered.

For convenience, the \hyperlink{group__buffer__size}{asio\+::buffer\+\_\+size} function also works on buffer sequences (that is, types meeting the Const\+Buffer\+Sequence or Mutable\+Buffer\+Sequence type requirements). In this case, the function returns the total size of all buffers in the sequence.

\begin{DoxyParagraph}{Buffer Copying}

\end{DoxyParagraph}
The \hyperlink{group__buffer__copy}{asio\+::buffer\+\_\+copy} function may be used to copy raw bytes between individual buffers and buffer sequences.

In particular, when used with the \hyperlink{group__buffer__size}{asio\+::buffer\+\_\+size}, the \hyperlink{group__buffer__copy}{asio\+::buffer\+\_\+copy} function can be used to linearise a sequence of buffers. For example\+:


\begin{DoxyCode}
 vector<const\_buffer> buffers = ...;

vector<unsigned char> data(\hyperlink{group__buffer__size_gabe8b5f116fbb66004b6d0ba8ee39c3d5}{asio::buffer\_size}(buffers));
\hyperlink{group__buffer__copy_ga8bc8cbf49a91e58205de746721d614d8}{asio::buffer\_copy}(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(data), buffers); 
\end{DoxyCode}


Note that \hyperlink{group__buffer__copy}{asio\+::buffer\+\_\+copy} is implemented in terms of {\ttfamily memcpy}, and consequently it cannot be used to copy between overlapping memory regions.

\begin{DoxyParagraph}{Buffer Invalidation}

\end{DoxyParagraph}
A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/\+O operation. When the memory is no longer available, the buffer is said to have been invalidated.

For the \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio\+::buffer} overloads that accept an argument of type std\+::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.\+2.\+4)

For the \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio\+::buffer} overloads that accept an argument of type std\+::basic\+\_\+string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.\+3).

\begin{DoxyParagraph}{Buffer Arithmetic}

\end{DoxyParagraph}
Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows\+:


\begin{DoxyCode}
\hyperlink{classboost_1_1array}{boost::array<char, 6>} a = \{ \textcolor{charliteral}{'a'}, \textcolor{charliteral}{'b'}, \textcolor{charliteral}{'c'}, \textcolor{charliteral}{'d'}, \textcolor{charliteral}{'e'} \}; 
\end{DoxyCode}


A buffer object {\ttfamily b1} created using\+:


\begin{DoxyCode}
b1 = \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(a); 
\end{DoxyCode}


represents the entire array, {\ttfamily \{ \textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, \textquotesingle{}c\textquotesingle{}, \textquotesingle{}d\textquotesingle{}, \textquotesingle{}e\textquotesingle{} \}}. An optional second argument to the \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio\+::buffer} function may be used to limit the size, in bytes, of the buffer\+:


\begin{DoxyCode}
b2 = \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(a, 3); 
\end{DoxyCode}


such that {\ttfamily b2} represents the data {\ttfamily \{ \textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, \textquotesingle{}c\textquotesingle{} \}}. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.

An offset may be applied to an existing buffer to create a new one\+:


\begin{DoxyCode}
b3 = b1 + 2; 
\end{DoxyCode}


where {\ttfamily b3} will set to represent {\ttfamily \{ \textquotesingle{}c\textquotesingle{}, \textquotesingle{}d\textquotesingle{}, \textquotesingle{}e\textquotesingle{} \}}. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.

Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer\+:


\begin{DoxyCode}
b4 = \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(b1 + 1, 3); 
\end{DoxyCode}


so that {\ttfamily b4} will refer to the bytes {\ttfamily \{ \textquotesingle{}b\textquotesingle{}, \textquotesingle{}c\textquotesingle{}, \textquotesingle{}d\textquotesingle{} \}}.

\begin{DoxyParagraph}{Buffers and Scatter-\/\+Gather I/\+O}

\end{DoxyParagraph}
To read or write using multiple buffers (i.\+e. scatter-\/gather I/\+O), multiple buffer objects may be assigned into a container that supports the Mutable\+Buffer\+Sequence (for read) or Const\+Buffer\+Sequence (for write) concepts\+:


\begin{DoxyCode}
\textcolor{keywordtype}{char} d1[128];
std::vector<char> d2(128);
\hyperlink{classboost_1_1array}{boost::array<char, 128>} d3;

\hyperlink{classboost_1_1array}{boost::array<mutable\_buffer, 3>} bufs1 = \{
  \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d1),
  \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d2),
  \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d3) \};
bytes\_transferred = sock.receive(bufs1);

std::vector<const\_buffer> bufs2;
bufs2.push\_back(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d1));
bufs2.push\_back(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d2));
bufs2.push\_back(\hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(d3));
bytes\_transferred = sock.send(bufs2); 
\end{DoxyCode}
 

\subsection{Function Documentation}
\hypertarget{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const mutable\+\_\+buffer \&b)}]{\setlength{\rightskip}{0pt plus 5cm}mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_ga1ed66e401559cbfd19595392f653b47c}


Create a new modifiable buffer from an existing buffer. 

\begin{DoxyReturn}{Returns}
{\ttfamily mutable\+\_\+buffers\+\_\+1(b)}. 
\end{DoxyReturn}


Definition at line 706 of file buffer.\+hpp.

\hypertarget{group__buffer_gaf93a06eac8bd6d1db394ba92e260b9fa}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const mutable\+\_\+buffer \&b, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const {\bf mutable\+\_\+buffer} \&}]{b, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gaf93a06eac8bd6d1db394ba92e260b9fa}


Create a new modifiable buffer from an existing buffer. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1mutable__buffers__1}{mutable\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
mutable\_buffers\_1(
   buffer\_cast<void*>(\hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b}),
   min(\hyperlink{group__buffer__size_gabe8b5f116fbb66004b6d0ba8ee39c3d5}{buffer\_size}(\hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b}), max\_size\_in\_bytes)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 718 of file buffer.\+hpp.

\hypertarget{group__buffer_gac00b079c860c589f80a312b975828780}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const const\+\_\+buffer \&b)}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const {\bf const\+\_\+buffer} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gac00b079c860c589f80a312b975828780}


Create a new non-\/modifiable buffer from an existing buffer. 

\begin{DoxyReturn}{Returns}
{\ttfamily const\+\_\+buffers\+\_\+1(b)}. 
\end{DoxyReturn}


Definition at line 735 of file buffer.\+hpp.

\hypertarget{group__buffer_gafe2a3b8cbb0e8aefbc870d5f43cf5872}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const const\+\_\+buffer \&b, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const {\bf const\+\_\+buffer} \&}]{b, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gafe2a3b8cbb0e8aefbc870d5f43cf5872}


Create a new non-\/modifiable buffer from an existing buffer. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   buffer\_cast<const void*>(\hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b}),
   min(\hyperlink{group__buffer__size_gabe8b5f116fbb66004b6d0ba8ee39c3d5}{buffer\_size}(\hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b}), max\_size\_in\_bytes)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 747 of file buffer.\+hpp.

\hypertarget{group__buffer_gaa066734007c417692255c8f515f0fb01}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(void $\ast$data, std\+::size\+\_\+t size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{data, }
\item[{std\+::size\+\_\+t}]{size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gaa066734007c417692255c8f515f0fb01}


Create a new modifiable buffer that represents the given memory range. 

\begin{DoxyReturn}{Returns}
{\ttfamily mutable\+\_\+buffers\+\_\+1(data, size\+\_\+in\+\_\+bytes)}. 
\end{DoxyReturn}


Definition at line 764 of file buffer.\+hpp.

\hypertarget{group__buffer_gaa6b6109423e7efc76b46b8d1337a5b0f}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const void $\ast$data, std\+::size\+\_\+t size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{data, }
\item[{std\+::size\+\_\+t}]{size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gaa6b6109423e7efc76b46b8d1337a5b0f}


Create a new non-\/modifiable buffer that represents the given memory range. 

\begin{DoxyReturn}{Returns}
{\ttfamily const\+\_\+buffers\+\_\+1(data, size\+\_\+in\+\_\+bytes)}. 
\end{DoxyReturn}


Definition at line 773 of file buffer.\+hpp.

\hypertarget{group__buffer_ga9a348932d9b7ffda26ff318191489fd8}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(\+Pod\+Type(\&data)[N])}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{Pod\+Type(\&)}]{data\mbox{[}\+N\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_ga9a348932d9b7ffda26ff318191489fd8}


Create a new modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1mutable__buffers__1}{mutable\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
mutable\_buffers\_1(
   static\_cast<void*>(data),
   N * \textcolor{keyword}{sizeof}(PodType)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 787 of file buffer.\+hpp.

\hypertarget{group__buffer_ga817f0fd9a7e1eebab155ccf5b62456f0}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(\+Pod\+Type(\&data)[N], std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{Pod\+Type(\&)}]{data\mbox{[}\+N\mbox{]}, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_ga817f0fd9a7e1eebab155ccf5b62456f0}


Create a new modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1mutable__buffers__1}{mutable\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
mutable\_buffers\_1(
   static\_cast<void*>(data),
   min(N * \textcolor{keyword}{sizeof}(PodType), max\_size\_in\_bytes)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 800 of file buffer.\+hpp.

\hypertarget{group__buffer_gae73b5385bad9b7c92afce06d92c11f1e}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const Pod\+Type(\&data)[N])}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const Pod\+Type(\&)}]{data\mbox{[}\+N\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gae73b5385bad9b7c92afce06d92c11f1e}


Create a new non-\/modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   static\_cast<const void*>(data),
   N * \textcolor{keyword}{sizeof}(PodType)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 817 of file buffer.\+hpp.

\hypertarget{group__buffer_gae37e6d30503997261200b1c9a2492182}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const Pod\+Type(\&data)[N], std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const Pod\+Type(\&)}]{data\mbox{[}\+N\mbox{]}, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gae37e6d30503997261200b1c9a2492182}


Create a new non-\/modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   static\_cast<const void*>(data),
   min(N * \textcolor{keyword}{sizeof}(PodType), max\_size\_in\_bytes)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 830 of file buffer.\+hpp.

\hypertarget{group__buffer_gafec66696edfddf306d7c91aba75b1723}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(boost\+::array$<$ Pod\+Type, N $>$ \&data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{{\bf boost\+::array}$<$ Pod\+Type, N $>$ \&}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gafec66696edfddf306d7c91aba75b1723}


Create a new modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1mutable__buffers__1}{mutable\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
mutable\_buffers\_1(
   data.data(),
   data.size() * \textcolor{keyword}{sizeof}(PodType)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 916 of file buffer.\+hpp.

\hypertarget{group__buffer_gabcdc30c4b4b6a28885f65e7c8fe08cc2}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(boost\+::array$<$ Pod\+Type, N $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{{\bf boost\+::array}$<$ Pod\+Type, N $>$ \&}]{data, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gabcdc30c4b4b6a28885f65e7c8fe08cc2}


Create a new modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1mutable__buffers__1}{mutable\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
mutable\_buffers\_1(
   data.data(),
   min(data.size() * \textcolor{keyword}{sizeof}(PodType), max\_size\_in\_bytes)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 930 of file buffer.\+hpp.

\hypertarget{group__buffer_ga7b564725e9315afaad270e46161ac21c}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(boost\+::array$<$ const Pod\+Type, N $>$ \&data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{{\bf boost\+::array}$<$ const Pod\+Type, N $>$ \&}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_ga7b564725e9315afaad270e46161ac21c}


Create a new non-\/modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   data.data(),
   data.size() * \textcolor{keyword}{sizeof}(PodType)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 947 of file buffer.\+hpp.

\hypertarget{group__buffer_gaf0529bedd017b4b01fd0920e35ed22cd}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(boost\+::array$<$ const Pod\+Type, N $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{{\bf boost\+::array}$<$ const Pod\+Type, N $>$ \&}]{data, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gaf0529bedd017b4b01fd0920e35ed22cd}


Create a new non-\/modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   data.data(),
   min(data.size() * \textcolor{keyword}{sizeof}(PodType), max\_size\_in\_bytes)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 961 of file buffer.\+hpp.

\hypertarget{group__buffer_gacee4fc886d2abc070fbabc77ebeb508d}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const boost\+::array$<$ Pod\+Type, N $>$ \&data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const {\bf boost\+::array}$<$ Pod\+Type, N $>$ \&}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gacee4fc886d2abc070fbabc77ebeb508d}


Create a new non-\/modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   data.data(),
   data.size() * \textcolor{keyword}{sizeof}(PodType)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 980 of file buffer.\+hpp.

\hypertarget{group__buffer_gac7e496b244e3999f2035c29043cd2ff9}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const boost\+::array$<$ Pod\+Type, N $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , std\+::size\+\_\+t N$>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const {\bf boost\+::array}$<$ Pod\+Type, N $>$ \&}]{data, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gac7e496b244e3999f2035c29043cd2ff9}


Create a new non-\/modifiable buffer that represents the given P\+O\+D array. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   data.data(),
   min(data.size() * \textcolor{keyword}{sizeof}(PodType), max\_size\_in\_bytes)); 
\end{DoxyCode}
 
\end{DoxyReturn}


Definition at line 994 of file buffer.\+hpp.

\hypertarget{group__buffer_ga382ee4d2d0dd90e88e374e4344302749}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(std\+::vector$<$ Pod\+Type, Allocator $>$ \&data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , typename Allocator $>$ mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ Pod\+Type, Allocator $>$ \&}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_ga382ee4d2d0dd90e88e374e4344302749}


Create a new modifiable buffer that represents the given P\+O\+D vector. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1mutable__buffers__1}{mutable\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
mutable\_buffers\_1(
   data.size() ? &data[0] : 0,
   data.size() * \textcolor{keyword}{sizeof}(PodType)); 
\end{DoxyCode}

\end{DoxyReturn}
\begin{DoxyNote}{Note}
The buffer is invalidated by any vector operation that would also invalidate iterators. 
\end{DoxyNote}


Definition at line 1111 of file buffer.\+hpp.

\hypertarget{group__buffer_gad0a0b6813e25e7bcce7fcfe32a5cdab9}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(std\+::vector$<$ Pod\+Type, Allocator $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , typename Allocator $>$ mutable\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ Pod\+Type, Allocator $>$ \&}]{data, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gad0a0b6813e25e7bcce7fcfe32a5cdab9}


Create a new modifiable buffer that represents the given P\+O\+D vector. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1mutable__buffers__1}{mutable\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
mutable\_buffers\_1(
   data.size() ? &data[0] : 0,
   min(data.size() * \textcolor{keyword}{sizeof}(PodType), max\_size\_in\_bytes)); 
\end{DoxyCode}

\end{DoxyReturn}
\begin{DoxyNote}{Note}
The buffer is invalidated by any vector operation that would also invalidate iterators. 
\end{DoxyNote}


Definition at line 1134 of file buffer.\+hpp.

\hypertarget{group__buffer_gaa908d4c98b0745c8c51540e153627f44}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const std\+::vector$<$ Pod\+Type, Allocator $>$ \&data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , typename Allocator $>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ Pod\+Type, Allocator $>$ \&}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gaa908d4c98b0745c8c51540e153627f44}


Create a new non-\/modifiable buffer that represents the given P\+O\+D vector. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   data.size() ? &data[0] : 0,
   data.size() * \textcolor{keyword}{sizeof}(PodType)); 
\end{DoxyCode}

\end{DoxyReturn}
\begin{DoxyNote}{Note}
The buffer is invalidated by any vector operation that would also invalidate iterators. 
\end{DoxyNote}


Definition at line 1160 of file buffer.\+hpp.

\hypertarget{group__buffer_gad172ef969f244d265d3cfcfea727b904}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const std\+::vector$<$ Pod\+Type, Allocator $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Pod\+Type , typename Allocator $>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ Pod\+Type, Allocator $>$ \&}]{data, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gad172ef969f244d265d3cfcfea727b904}


Create a new non-\/modifiable buffer that represents the given P\+O\+D vector. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   data.size() ? &data[0] : 0,
   min(data.size() * \textcolor{keyword}{sizeof}(PodType), max\_size\_in\_bytes)); 
\end{DoxyCode}

\end{DoxyReturn}
\begin{DoxyNote}{Note}
The buffer is invalidated by any vector operation that would also invalidate iterators. 
\end{DoxyNote}


Definition at line 1184 of file buffer.\+hpp.

\hypertarget{group__buffer_gafe609d07578ac226c777107fbe51eff5}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const std\+::basic\+\_\+string$<$ Elem, Traits, Allocator $>$ \&data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem , typename Traits , typename Allocator $>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const std\+::basic\+\_\+string$<$ Elem, Traits, Allocator $>$ \&}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gafe609d07578ac226c777107fbe51eff5}


Create a new non-\/modifiable buffer that represents the given string. 

\begin{DoxyReturn}{Returns}
{\ttfamily \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1}(data.\+data(), \hyperlink{namespaceuva_1_1utils_1_1containers_aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791}{data.\+size()} $\ast$ sizeof(\+Elem))}.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The buffer is invalidated by any non-\/const operation called on the given string object. 
\end{DoxyNote}


Definition at line 1207 of file buffer.\+hpp.

\hypertarget{group__buffer_gaa04e7aa3e90adacebceb59007629e923}{}\index{asio\+::buffer@{asio\+::buffer}!buffer@{buffer}}
\index{buffer@{buffer}!asio\+::buffer@{asio\+::buffer}}
\subsubsection[{buffer(const std\+::basic\+\_\+string$<$ Elem, Traits, Allocator $>$ \&data, std\+::size\+\_\+t max\+\_\+size\+\_\+in\+\_\+bytes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Elem , typename Traits , typename Allocator $>$ const\+\_\+buffers\+\_\+1 asio\+::buffer (
\begin{DoxyParamCaption}
\item[{const std\+::basic\+\_\+string$<$ Elem, Traits, Allocator $>$ \&}]{data, }
\item[{std\+::size\+\_\+t}]{max\+\_\+size\+\_\+in\+\_\+bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__buffer_gaa04e7aa3e90adacebceb59007629e923}


Create a new non-\/modifiable buffer that represents the given string. 

\begin{DoxyReturn}{Returns}
A \hyperlink{classasio_1_1const__buffers__1}{const\+\_\+buffers\+\_\+1} value equivalent to\+: 
\begin{DoxyCode}
const\_buffers\_1(
   data.data(),
   min(data.size() * \textcolor{keyword}{sizeof}(Elem), max\_size\_in\_bytes)); 
\end{DoxyCode}

\end{DoxyReturn}
\begin{DoxyNote}{Note}
The buffer is invalidated by any non-\/const operation called on the given string object. 
\end{DoxyNote}


Definition at line 1230 of file buffer.\+hpp.

