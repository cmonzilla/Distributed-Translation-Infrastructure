\hypertarget{group__async__read}{}\section{asio\+:\+:async\+\_\+read}
\label{group__async__read}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}


Start an asynchronous operation to read a certain amount of data from a stream.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Async\+Read\+Stream , typename Mutable\+Buffer\+Sequence , typename Read\+Handler $>$ }\\\hyperlink{group__async__read_ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b}{asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E} (Read\+Handler, void(\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code}, std\+::size\+\_\+t)) async\+\_\+read(Async\+Read\+Stream \&s
\item 
const Mutable\+Buffer\+Sequence Completion\+Condition \hyperlink{group__async__read_gac41f6414b06e189a76689422b8e2db35}{asio\+::\+A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G} (Read\+Handler) handler)
\item 
{\footnotesize template$<$typename Async\+Read\+Stream , typename Mutable\+Buffer\+Sequence , typename Completion\+Condition , typename Read\+Handler $>$ }\\\hyperlink{group__async__read_gab321259782b3683c80f33eb1050a3251}{asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E} (Read\+Handler, void(\hyperlink{classasio_1_1error__code}{asio\+::error\+\_\+code}, std\+::size\+\_\+t)) async\+\_\+read(Async\+Read\+Stream \&s
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const Mutable\+Buffer\+Sequence \& \hyperlink{group__async__read_ga54dede45c3175148a77fe6635222c47d}{asio\+::buffers}
\item 
const Mutable\+Buffer\+Sequence Completion\+Condition \hyperlink{group__async__read_gae2e215d5013596cc2b385bb6c13fa518}{asio\+::completion\+\_\+condition}
\item 
\hyperlink{classasio_1_1basic__streambuf}{asio\+::basic\+\_\+streambuf}$<$ Allocator $>$ \& \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{asio\+::b}
\item 
\hyperlink{classasio_1_1basic__streambuf}{asio\+::basic\+\_\+streambuf}$<$ Allocator $>$ Completion\+Condition \hyperlink{group__async__read_ga6d72a97784dde9476c6d93b8904a4967}{asio\+::\+A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G} (Read\+Handler) handler)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Start an asynchronous operation to read a certain amount of data from a stream. 



\subsection{Function Documentation}
\hypertarget{group__async__read_gab321259782b3683c80f33eb1050a3251}{}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}!A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}}
\index{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}!asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}
\subsubsection[{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E(\+Read\+Handler, void(asio\+::error\+\_\+code, std\+::size\+\_\+t)) async\+\_\+read(\+Async\+Read\+Stream \&s}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Async\+Read\+Stream , typename Mutable\+Buffer\+Sequence , typename Completion\+Condition , typename Read\+Handler $>$ asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E (
\begin{DoxyParamCaption}
\item[{Read\+Handler}]{, }
\item[{void({\bf asio\+::error\+\_\+code}, std\+::size\+\_\+t)}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__async__read_gab321259782b3683c80f33eb1050a3251}
Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.\end{DoxyItemize}
\begin{DoxyItemize}
\item The completion\+\_\+condition function object returns 0.\end{DoxyItemize}

\begin{DoxyParams}{Parameters}
{\em s} & The stream from which the data is to be read. The type must support the Async\+Read\+Stream concept.\\
\hline
{\em buffers} & One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.\\
\hline
{\em completion\+\_\+condition} & The function object to be called to determine whether the read operation is complete. The signature of the function object must be\+: 
\begin{DoxyCode}
 std::size\_t \hyperlink{group__async__read_gae2e215d5013596cc2b385bb6c13fa518}{completion\_condition}(
  \textcolor{comment}{// Result of latest async\_read\_some operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes transferred so far.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 A return value of 0 indicates that the read operation is complete. A non-\/zero return value indicates the maximum number of bytes to be read on the next call to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error, \textcolor{comment}{// Result of operation.}

  std::size\_t bytes\_transferred           \textcolor{comment}{// Number of bytes copied into the}
                                          \textcolor{comment}{// buffers. If an error occurred,}
                                          \textcolor{comment}{// this will be the  number of}
                                          \textcolor{comment}{// bytes successfully transferred}
                                          \textcolor{comment}{// prior to the error.}
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyParagraph}{Example}
To read into a single data buffer use the \hyperlink{group__buffer}{asio\+::buffer} function as follows\+: 
\begin{DoxyCode}
asio::async\_read(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s},
   \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(data, \hyperlink{namespaceuva_1_1utils_1_1containers_aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791}{size}),
   \hyperlink{group__completion__condition_ga2b10af704afcd6c7ed7f0d3b740033ef}{asio::transfer\_at\_least}(32),
   handler); 
\end{DoxyCode}
 See the \hyperlink{group__buffer}{asio\+::buffer} documentation for information on reading into multiple buffers in one go, and how to use it with arrays, \hyperlink{classboost_1_1array}{boost\+::array} or std\+::vector.
\end{DoxyParagraph}
Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The supplied buffer is full (that is, it has reached maximum size).\end{DoxyItemize}
\begin{DoxyItemize}
\item The completion\+\_\+condition function object returns 0.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, and is known as a {\itshape composed operation}. The program must ensure that the stream performs no other read operations (such as async\+\_\+read, the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, or any other composed operations that perform reads) until this operation completes.


\begin{DoxyParams}{Parameters}
{\em s} & The stream from which the data is to be read. The type must support the Async\+Read\+Stream concept.\\
\hline
{\em b} & A \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.\\
\hline
{\em completion\+\_\+condition} & The function object to be called to determine whether the read operation is complete. The signature of the function object must be\+: 
\begin{DoxyCode}
 std::size\_t \hyperlink{group__async__read_gae2e215d5013596cc2b385bb6c13fa518}{completion\_condition}(
  \textcolor{comment}{// Result of latest async\_read\_some operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes transferred so far.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 A return value of 0 indicates that the read operation is complete. A non-\/zero return value indicates the maximum number of bytes to be read on the next call to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error, \textcolor{comment}{// Result of operation.}

  std::size\_t bytes\_transferred           \textcolor{comment}{// Number of bytes copied into the}
                                          \textcolor{comment}{// buffers. If an error occurred,}
                                          \textcolor{comment}{// this will be the  number of}
                                          \textcolor{comment}{// bytes successfully transferred}
                                          \textcolor{comment}{// prior to the error.}
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.\end{DoxyItemize}
\begin{DoxyItemize}
\item The completion\+\_\+condition function object returns 0.\end{DoxyItemize}

\begin{DoxyParams}{Parameters}
{\em d} & The device from which the data is to be read. The type must support the Async\+Random\+Access\+Read\+Device concept.\\
\hline
{\em offset} & The offset at which the data will be read.\\
\hline
{\em buffers} & One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.\\
\hline
{\em completion\+\_\+condition} & The function object to be called to determine whether the read operation is complete. The signature of the function object must be\+: 
\begin{DoxyCode}
 std::size\_t \hyperlink{group__async__read_gae2e215d5013596cc2b385bb6c13fa518}{completion\_condition}(
  \textcolor{comment}{// Result of latest async\_read\_some\_at operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes transferred so far.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 A return value of 0 indicates that the read operation is complete. A non-\/zero return value indicates the maximum number of bytes to be read on the next call to the device\textquotesingle{}s async\+\_\+read\+\_\+some\+\_\+at function.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes copied into the buffers. If an error}
  \textcolor{comment}{// occurred, this will be the number of bytes successfully}
  \textcolor{comment}{// transferred prior to the error.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyParagraph}{Example}
To read into a single data buffer use the \hyperlink{group__buffer}{asio\+::buffer} function as follows\+: 
\begin{DoxyCode}
asio::async\_read\_at(d, 42,
   \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(data, \hyperlink{namespaceuva_1_1utils_1_1containers_aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791}{size}),
   \hyperlink{group__completion__condition_ga2b10af704afcd6c7ed7f0d3b740033ef}{asio::transfer\_at\_least}(32),
   handler); 
\end{DoxyCode}
 See the \hyperlink{group__buffer}{asio\+::buffer} documentation for information on reading into multiple buffers in one go, and how to use it with arrays, \hyperlink{classboost_1_1array}{boost\+::array} or std\+::vector.
\end{DoxyParagraph}
Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The completion\+\_\+condition function object returns 0.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the device\textquotesingle{}s async\+\_\+read\+\_\+some\+\_\+at function.


\begin{DoxyParams}{Parameters}
{\em d} & The device from which the data is to be read. The type must support the Async\+Random\+Access\+Read\+Device concept.\\
\hline
{\em offset} & The offset at which the data will be read.\\
\hline
{\em b} & A \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.\\
\hline
{\em completion\+\_\+condition} & The function object to be called to determine whether the read operation is complete. The signature of the function object must be\+: 
\begin{DoxyCode}
 std::size\_t \hyperlink{group__async__read_gae2e215d5013596cc2b385bb6c13fa518}{completion\_condition}(
  \textcolor{comment}{// Result of latest async\_read\_some\_at operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes transferred so far.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 A return value of 0 indicates that the read operation is complete. A non-\/zero return value indicates the maximum number of bytes to be read on the next call to the device\textquotesingle{}s async\+\_\+read\+\_\+some\+\_\+at function.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes copied into the buffers. If an error}
  \textcolor{comment}{// occurred, this will be the number of bytes successfully}
  \textcolor{comment}{// transferred prior to the error.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
Start an asynchronous operation to read data into a streambuf until a function object indicates a match. This function is used to asynchronously read data into the specified streambuf until a user-\/defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The match condition function object returns a std\+::pair where the second element evaluates to true.\end{DoxyItemize}
\begin{DoxyItemize}
\item An error occurred.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, and is known as a {\itshape composed operation}. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\+\_\+read, async\+\_\+read\+\_\+until, the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, or any other composed operations that perform reads) until this operation completes.


\begin{DoxyParams}{Parameters}
{\em s} & The stream from which the data is to be read. The type must support the Async\+Read\+Stream concept.\\
\hline
{\em b} & A streambuf object into which the data will be read.\\
\hline
{\em match\+\_\+condition} & The function object to be called to determine whether a match exists. The signature of the function object must be\+: 
\begin{DoxyCode}
pair<iterator, bool> \hyperlink{group__async__read__until_ga950b81fb954e4a0f01e13a57e15721b4}{match\_condition}(iterator begin, iterator end);
\end{DoxyCode}
 where {\ttfamily iterator} represents the type\+: 
\begin{DoxyCode}
buffers\_iterator<basic\_streambuf<Allocator>::const\_buffers\_type>
\end{DoxyCode}
 The iterator parameters {\ttfamily begin} and {\ttfamily end} define the range of bytes to be scanned to determine whether there is a match. The {\ttfamily first} member of the return value is an iterator marking one-\/past-\/the-\/end of the bytes that have been consumed by the match function. This iterator is used to calculate the {\ttfamily begin} parameter for any subsequent invocation of the match condition. The {\ttfamily second} member of the return value is true if a match has been found, false otherwise.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// The number of bytes in the streambuf's get}
  \textcolor{comment}{// area that have been fully consumed by the}
  \textcolor{comment}{// match function. O if an error occurred.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
After a successful async\+\_\+read\+\_\+until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async\+\_\+read\+\_\+until operation to examine.

The default implementation of the {\ttfamily \hyperlink{structasio_1_1is__match__condition}{is\+\_\+match\+\_\+condition}} type trait evaluates to true for function pointers and function objects with a {\ttfamily result\+\_\+type} typedef. It must be specialised for other user-\/defined function objects.
\end{DoxyNote}
\begin{DoxyParagraph}{Examples}
To asynchronously read data into a streambuf until whitespace is encountered\+: 
\begin{DoxyCode}
 \textcolor{keyword}{typedef} \hyperlink{classasio_1_1buffers__iterator}{asio::buffers\_iterator}<
    \hyperlink{classasio_1_1const__buffers__1}{asio::streambuf::const\_buffers\_type}> iterator;

std::pair<iterator, bool>
match\_whitespace(iterator begin, iterator end)
\{
  iterator i = \hyperlink{group__async__connect_ga7055bca9225050c030c19c7dc926fa53}{begin};
  \textcolor{keywordflow}{while} (i != end)
    \textcolor{keywordflow}{if} (std::isspace(*i++))
      \textcolor{keywordflow}{return} std::make\_pair(i, \textcolor{keyword}{true});
  \textcolor{keywordflow}{return} std::make\_pair(i, \textcolor{keyword}{false});
\}
...
void handler(\textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& e, std::size\_t \hyperlink{namespaceuva_1_1utils_1_1containers_aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791}{size});
...
asio::streambuf \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b};
asio::async\_read\_until(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b}, match\_whitespace, handler);
\end{DoxyCode}

\end{DoxyParagraph}
To asynchronously read data into a streambuf until a matching character is found\+: 
\begin{DoxyCode}
 \textcolor{keyword}{class }match\_char
\{
\textcolor{keyword}{public}:
  \textcolor{keyword}{explicit} match\_char(\textcolor{keywordtype}{char} c) : c\_(c) \{\}

  \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>
  std::pair<Iterator, bool> operator()(
      Iterator begin, Iterator end)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
    Iterator i = \hyperlink{group__async__connect_ga7055bca9225050c030c19c7dc926fa53}{begin};
    \textcolor{keywordflow}{while} (i != end)
      \textcolor{keywordflow}{if} (c\_ == *i++)
        \textcolor{keywordflow}{return} std::make\_pair(i, \textcolor{keyword}{true});
    \textcolor{keywordflow}{return} std::make\_pair(i, \textcolor{keyword}{false});
  \}

\textcolor{keyword}{private}:
  \textcolor{keywordtype}{char} c\_;
\};

\textcolor{keyword}{namespace }\hyperlink{namespaceasio}{asio} \{
  \textcolor{keyword}{template} <> \textcolor{keyword}{struct }is\_match\_condition<match\_char>
    : \textcolor{keyword}{public} boost::true\_type \{\};
\} \textcolor{comment}{// namespace asio}
...
void handler(\textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& e, std::size\_t \hyperlink{namespaceuva_1_1utils_1_1containers_aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791}{size});
...
asio::streambuf \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b};
asio::async\_read\_until(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b}, match\_char(\textcolor{charliteral}{'a'}), handler);
\end{DoxyCode}
 \hypertarget{group__async__read_ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b}{}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}!A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}}
\index{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E@{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E}!asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}
\subsubsection[{A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E(\+Read\+Handler, void(asio\+::error\+\_\+code, std\+::size\+\_\+t)) async\+\_\+read(\+Async\+Read\+Stream \&s}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Async\+Read\+Stream , typename Mutable\+Buffer\+Sequence , typename Read\+Handler $>$ asio\+::\+A\+S\+I\+O\+\_\+\+I\+N\+I\+T\+F\+N\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+T\+Y\+P\+E (
\begin{DoxyParamCaption}
\item[{Read\+Handler}]{, }
\item[{void({\bf asio\+::error\+\_\+code}, std\+::size\+\_\+t)}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{group__async__read_ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b}
Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.\end{DoxyItemize}
\begin{DoxyItemize}
\item An error occurred.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, and is known as a {\itshape composed operation}. The program must ensure that the stream performs no other read operations (such as async\+\_\+read, the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, or any other composed operations that perform reads) until this operation completes.


\begin{DoxyParams}{Parameters}
{\em s} & The stream from which the data is to be read. The type must support the Async\+Read\+Stream concept.\\
\hline
{\em buffers} & One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error, \textcolor{comment}{// Result of operation.}

  std::size\_t bytes\_transferred           \textcolor{comment}{// Number of bytes copied into the}
                                          \textcolor{comment}{// buffers. If an error occurred,}
                                          \textcolor{comment}{// this will be the  number of}
                                          \textcolor{comment}{// bytes successfully transferred}
                                          \textcolor{comment}{// prior to the error.}
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyParagraph}{Example}
To read into a single data buffer use the \hyperlink{group__buffer}{asio\+::buffer} function as follows\+: 
\begin{DoxyCode}
asio::async\_read(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(data, size), handler);
\end{DoxyCode}
 See the \hyperlink{group__buffer}{asio\+::buffer} documentation for information on reading into multiple buffers in one go, and how to use it with arrays, \hyperlink{classboost_1_1array}{boost\+::array} or std\+::vector.
\end{DoxyParagraph}
\begin{DoxyNote}{Note}
This overload is equivalent to calling\+: 
\begin{DoxyCode}
asio::async\_read(
   \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, buffers,
   \hyperlink{group__completion__condition_ga4a82e92df79aa8401a8bc2117d4cf900}{asio::transfer\_all}(),
   handler); 
\end{DoxyCode}

\end{DoxyNote}
Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The supplied buffer is full (that is, it has reached maximum size).\end{DoxyItemize}
\begin{DoxyItemize}
\item An error occurred.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, and is known as a {\itshape composed operation}. The program must ensure that the stream performs no other read operations (such as async\+\_\+read, the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, or any other composed operations that perform reads) until this operation completes.


\begin{DoxyParams}{Parameters}
{\em s} & The stream from which the data is to be read. The type must support the Async\+Read\+Stream concept.\\
\hline
{\em b} & A \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error, \textcolor{comment}{// Result of operation.}

  std::size\_t bytes\_transferred           \textcolor{comment}{// Number of bytes copied into the}
                                          \textcolor{comment}{// buffers. If an error occurred,}
                                          \textcolor{comment}{// this will be the  number of}
                                          \textcolor{comment}{// bytes successfully transferred}
                                          \textcolor{comment}{// prior to the error.}
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This overload is equivalent to calling\+: 
\begin{DoxyCode}
asio::async\_read(
   \hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, b,
   \hyperlink{group__completion__condition_ga4a82e92df79aa8401a8bc2117d4cf900}{asio::transfer\_all}(),
   handler); 
\end{DoxyCode}

\end{DoxyNote}
Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.\end{DoxyItemize}
\begin{DoxyItemize}
\item An error occurred.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the device\textquotesingle{}s async\+\_\+read\+\_\+some\+\_\+at function.


\begin{DoxyParams}{Parameters}
{\em d} & The device from which the data is to be read. The type must support the Async\+Random\+Access\+Read\+Device concept.\\
\hline
{\em offset} & The offset at which the data will be read.\\
\hline
{\em buffers} & One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes copied into the buffers. If an error}
  \textcolor{comment}{// occurred, this will be the number of bytes successfully}
  \textcolor{comment}{// transferred prior to the error.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyParagraph}{Example}
To read into a single data buffer use the \hyperlink{group__buffer}{asio\+::buffer} function as follows\+: 
\begin{DoxyCode}
asio::async\_read\_at(d, 42, \hyperlink{group__buffer_ga1ed66e401559cbfd19595392f653b47c}{asio::buffer}(data, size), handler);
\end{DoxyCode}
 See the \hyperlink{group__buffer}{asio\+::buffer} documentation for information on reading into multiple buffers in one go, and how to use it with arrays, \hyperlink{classboost_1_1array}{boost\+::array} or std\+::vector.
\end{DoxyParagraph}
\begin{DoxyNote}{Note}
This overload is equivalent to calling\+: 
\begin{DoxyCode}
asio::async\_read\_at(
   d, 42, buffers,
   \hyperlink{group__completion__condition_ga4a82e92df79aa8401a8bc2117d4cf900}{asio::transfer\_all}(),
   handler); 
\end{DoxyCode}

\end{DoxyNote}
Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item An error occurred.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the device\textquotesingle{}s async\+\_\+read\+\_\+some\+\_\+at function.


\begin{DoxyParams}{Parameters}
{\em d} & The device from which the data is to be read. The type must support the Async\+Random\+Access\+Read\+Device concept.\\
\hline
{\em offset} & The offset at which the data will be read.\\
\hline
{\em b} & A \hyperlink{classasio_1_1basic__streambuf}{basic\+\_\+streambuf} object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// Number of bytes copied into the buffers. If an error}
  \textcolor{comment}{// occurred, this will be the number of bytes successfully}
  \textcolor{comment}{// transferred prior to the error.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This overload is equivalent to calling\+: 
\begin{DoxyCode}
asio::async\_read\_at(
   d, 42, b,
   \hyperlink{group__completion__condition_ga4a82e92df79aa8401a8bc2117d4cf900}{asio::transfer\_all}(),
   handler); 
\end{DoxyCode}

\end{DoxyNote}
Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf\textquotesingle{}s get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The get area of the streambuf contains the specified delimiter.\end{DoxyItemize}
\begin{DoxyItemize}
\item An error occurred.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, and is known as a {\itshape composed operation}. If the streambuf\textquotesingle{}s get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\+\_\+read, async\+\_\+read\+\_\+until, the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, or any other composed operations that perform reads) until this operation completes.


\begin{DoxyParams}{Parameters}
{\em s} & The stream from which the data is to be read. The type must support the Async\+Read\+Stream concept.\\
\hline
{\em b} & A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.\\
\hline
{\em delim} & The delimiter character.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// The number of bytes in the streambuf's get}
  \textcolor{comment}{// area up to and including the delimiter.}
  \textcolor{comment}{// 0 if an error occurred.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
After a successful async\+\_\+read\+\_\+until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async\+\_\+read\+\_\+until operation to examine.
\end{DoxyNote}
\begin{DoxyParagraph}{Example}
To asynchronously read data into a streambuf until a newline is encountered\+: 
\begin{DoxyCode}
 \hyperlink{classasio_1_1basic__streambuf}{asio::streambuf} \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b};
...
void handler(\textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& e, std::size\_t size)
\{
  \textcolor{keywordflow}{if} (!e)
  \{
    std::istream is(&b);
    std::string line;
    std::getline(is, line);
    ...
  \}
\}
...
asio::async\_read\_until(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, b, \textcolor{charliteral}{'\(\backslash\)n'}, handler); 
\end{DoxyCode}
 After the {\ttfamily async\+\_\+read\+\_\+until} operation completes successfully, the buffer {\ttfamily b} contains the delimiter\+: 
\begin{DoxyCode}
\{ \textcolor{charliteral}{'a'}, \textcolor{charliteral}{'b'}, ..., \textcolor{charliteral}{'c'}, \textcolor{charliteral}{'\(\backslash\)n'}, \textcolor{charliteral}{'d'}, \textcolor{charliteral}{'e'}, ... \} 
\end{DoxyCode}
 The call to {\ttfamily std\+::getline} then extracts the data up to and including the delimiter, so that the string {\ttfamily line} contains\+: 
\begin{DoxyCode}
\{ \textcolor{charliteral}{'a'}, \textcolor{charliteral}{'b'}, ..., \textcolor{charliteral}{'c'}, \textcolor{charliteral}{'\(\backslash\)n'} \} 
\end{DoxyCode}
 The remaining data is left in the buffer {\ttfamily b} as follows\+: 
\begin{DoxyCode}
\{ \textcolor{charliteral}{'d'}, \textcolor{charliteral}{'e'}, ... \} 
\end{DoxyCode}
 This data may be the start of a new line, to be extracted by a subsequent {\ttfamily async\+\_\+read\+\_\+until} operation.
\end{DoxyParagraph}
Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf\textquotesingle{}s get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true\+:

\begin{DoxyItemize}
\item The get area of the streambuf contains the specified delimiter.\end{DoxyItemize}
\begin{DoxyItemize}
\item An error occurred.\end{DoxyItemize}
This operation is implemented in terms of zero or more calls to the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, and is known as a {\itshape composed operation}. If the streambuf\textquotesingle{}s get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\+\_\+read, async\+\_\+read\+\_\+until, the stream\textquotesingle{}s async\+\_\+read\+\_\+some function, or any other composed operations that perform reads) until this operation completes.


\begin{DoxyParams}{Parameters}
{\em s} & The stream from which the data is to be read. The type must support the Async\+Read\+Stream concept.\\
\hline
{\em b} & A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.\\
\hline
{\em delim} & The delimiter string.\\
\hline
{\em handler} & The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be\+: 
\begin{DoxyCode}
 \textcolor{keywordtype}{void} handler(
  \textcolor{comment}{// Result of operation.}
  \textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& error,

  \textcolor{comment}{// The number of bytes in the streambuf's get}
  \textcolor{comment}{// area up to and including the delimiter.}
  \textcolor{comment}{// 0 if an error occurred.}
  std::size\_t bytes\_transferred
); 
\end{DoxyCode}
 Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using \hyperlink{classasio_1_1io__service_ae01f809800017295e39786f5bca6652e}{asio\+::io\+\_\+service\+::post()}.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
After a successful async\+\_\+read\+\_\+until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async\+\_\+read\+\_\+until operation to examine.
\end{DoxyNote}
\begin{DoxyParagraph}{Example}
To asynchronously read data into a streambuf until a newline is encountered\+: 
\begin{DoxyCode}
 \hyperlink{classasio_1_1basic__streambuf}{asio::streambuf} \hyperlink{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{b};
...
void handler(\textcolor{keyword}{const} \hyperlink{classasio_1_1error__code}{asio::error\_code}& e, std::size\_t size)
\{
  \textcolor{keywordflow}{if} (!e)
  \{
    std::istream is(&b);
    std::string line;
    std::getline(is, line);
    ...
  \}
\}
...
asio::async\_read\_until(\hyperlink{group__async__connect_ga31ab74b9ea6c77932dddd016cfc7920a}{s}, b, \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}, handler); 
\end{DoxyCode}
 After the {\ttfamily async\+\_\+read\+\_\+until} operation completes successfully, the buffer {\ttfamily b} contains the delimiter\+: 
\begin{DoxyCode}
\{ \textcolor{charliteral}{'a'}, \textcolor{charliteral}{'b'}, ..., \textcolor{charliteral}{'c'}, \textcolor{charliteral}{'\(\backslash\)r'}, \textcolor{charliteral}{'\(\backslash\)n'}, \textcolor{charliteral}{'d'}, \textcolor{charliteral}{'e'}, ... \} 
\end{DoxyCode}
 The call to {\ttfamily std\+::getline} then extracts the data up to and including the delimiter, so that the string {\ttfamily line} contains\+: 
\begin{DoxyCode}
\{ \textcolor{charliteral}{'a'}, \textcolor{charliteral}{'b'}, ..., \textcolor{charliteral}{'c'}, \textcolor{charliteral}{'\(\backslash\)r'}, \textcolor{charliteral}{'\(\backslash\)n'} \} 
\end{DoxyCode}
 The remaining data is left in the buffer {\ttfamily b} as follows\+: 
\begin{DoxyCode}
\{ \textcolor{charliteral}{'d'}, \textcolor{charliteral}{'e'}, ... \} 
\end{DoxyCode}
 This data may be the start of a new line, to be extracted by a subsequent {\ttfamily async\+\_\+read\+\_\+until} operation. 
\end{DoxyParagraph}
\hypertarget{group__async__read_gac41f6414b06e189a76689422b8e2db35}{}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}!A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G@{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}}
\index{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G@{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}!asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}
\subsubsection[{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G(\+Read\+Handler) handler)}]{\setlength{\rightskip}{0pt plus 5cm}const Mutable\+Buffer\+Sequence Completion\+Condition asio\+::\+A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G (
\begin{DoxyParamCaption}
\item[{Read\+Handler}]{}
\end{DoxyParamCaption}
)}\label{group__async__read_gac41f6414b06e189a76689422b8e2db35}


Definition at line 523 of file read.\+hpp.



\subsection{Variable Documentation}
\hypertarget{group__async__read_ga6d72a97784dde9476c6d93b8904a4967}{}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}!A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G@{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}}
\index{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G@{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}!asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}
\subsubsection[{A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t basic\+\_\+streambuf$<$ Allocator $>$ Completion\+Condition asio\+::\+A\+S\+I\+O\+\_\+\+M\+O\+V\+E\+\_\+\+A\+R\+G (
\begin{DoxyParamCaption}
\item[{Read\+Handler}]{}
\end{DoxyParamCaption}
)}\label{group__async__read_ga6d72a97784dde9476c6d93b8904a4967}


Definition at line 704 of file read.\+hpp.

\hypertarget{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}{}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}!b@{b}}
\index{b@{b}!asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}
\subsubsection[{b}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t basic\+\_\+streambuf$<$ Allocator $>$ \& asio\+::b}\label{group__async__read_ga945a5c18fa77a9e2eba420f8f44b2a4f}


Definition at line 702 of file read.\+hpp.

\hypertarget{group__async__read_ga54dede45c3175148a77fe6635222c47d}{}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}!buffers@{buffers}}
\index{buffers@{buffers}!asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}
\subsubsection[{buffers}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t const Const\+Buffer\+Sequence \& asio\+::buffers}\label{group__async__read_ga54dede45c3175148a77fe6635222c47d}


Definition at line 521 of file read.\+hpp.

\hypertarget{group__async__read_gae2e215d5013596cc2b385bb6c13fa518}{}\index{asio\+::async\+\_\+read@{asio\+::async\+\_\+read}!completion\+\_\+condition@{completion\+\_\+condition}}
\index{completion\+\_\+condition@{completion\+\_\+condition}!asio\+::async\+\_\+read@{asio\+::async\+\_\+read}}
\subsubsection[{completion\+\_\+condition}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t basic\+\_\+streambuf$<$ Allocator $>$ Completion\+Condition asio\+::completion\+\_\+condition}\label{group__async__read_gae2e215d5013596cc2b385bb6c13fa518}


Definition at line 521 of file read.\+hpp.

