\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils}{}\section{uva\+:\+:utils\+:\+:containers\+:\+:utils Namespace Reference}
\label{namespaceuva_1_1utils_1_1containers_1_1utils}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structuva_1_1utils_1_1containers_1_1utils_1_1_t___i_s___c_o_m_p_a_r_e___f_u_n_c}{T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_a72ccbd06b023cd715ed69cc75ee8054f}{my\+\_\+bsearch\+\_\+id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E\+::\+T\+Id\+Type key, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&found\+\_\+elem)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_a9b58dc54173e94211d0e5e3acd69702e}{my\+\_\+bsearch\+\_\+id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_af7ec60c27e50affde107ae926741b6d0}{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const uint32\+\_\+t key1, const uint32\+\_\+t key2, uint32\+\_\+t \&found\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_aa90a9b943e18d3d2f1f6ac58c4df713c}{my\+\_\+isearch\+\_\+id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&found\+\_\+elem)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_a5d93685adf3007ae50d20899e49b9f30}{my\+\_\+bsearch} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E l\+\_\+idx, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E \&mid\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_ae11ec719b7b1058f8072e77a5a68e0be}{my\+\_\+lsearch\+\_\+id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E\+::\+T\+Id\+Type key, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&found\+\_\+elem)
\item 
{\footnotesize template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ }\\void \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_acd01e6dc6a25f1501ddd95b0e22b2239}{my\+\_\+sort} (E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const uint32\+\_\+t array\+\_\+size, typename \hyperlink{structuva_1_1utils_1_1containers_1_1utils_1_1_t___i_s___c_o_m_p_a_r_e___f_u_n_c}{T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C}$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+type is\+\_\+less\+\_\+func)
\item 
{\footnotesize template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+ptr I\+S\+\_\+\+L\+E\+S\+S\+\_\+\+F\+U\+N\+C$>$ }\\void \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_ae19599c8e6a1b8495f99fe40c69db651}{my\+\_\+sort} (E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const uint32\+\_\+t array\+\_\+size)
\item 
{\footnotesize template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , bool I\+S\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S = true$>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1utils_a3e659cca602ac3b385cc910e3c2ee416}{is\+\_\+less} (const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&first, const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&second)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_a3e659cca602ac3b385cc910e3c2ee416}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!is\+\_\+less@{is\+\_\+less}}
\index{is\+\_\+less@{is\+\_\+less}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{is\+\_\+less(const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&first, const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&second)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , bool I\+S\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S = true$>$ bool uva\+::utils\+::containers\+::utils\+::is\+\_\+less (
\begin{DoxyParamCaption}
\item[{const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&}]{first, }
\item[{const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&}]{second}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1utils_1_1containers_1_1utils_a3e659cca602ac3b385cc910e3c2ee416}
The basic \char`\"{}is less\char`\"{} function for the sort algorithms that allows to update the progress bar. 
\begin{DoxyParams}{Parameters}
{\em first} & the first element to compare \\
\hline
{\em second} & the second element to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the first element is less then the second 
\end{DoxyReturn}


Definition at line 429 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_a5d93685adf3007ae50d20899e49b9f30}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+bsearch@{my\+\_\+bsearch}}
\index{my\+\_\+bsearch@{my\+\_\+bsearch}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+bsearch(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E l\+\_\+idx, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E \&mid\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::utils\+::containers\+::utils\+::my\+\_\+bsearch (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E}]{l\+\_\+idx, }
\item[{I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E}]{u\+\_\+idx, }
\item[{const K\+E\+Y\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E \&}]{mid\+\_\+pos}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1utils_a5d93685adf3007ae50d20899e49b9f30}
This is a search algorithm for some ordered array, here we use bsearch from $<$cstdlib$>$ 
\begin{DoxyParams}{Parameters}
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em mid\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}


Definition at line 295 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_a72ccbd06b023cd715ed69cc75ee8054f}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}}
\index{my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+bsearch\+\_\+id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E\+::\+T\+Id\+Type key, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&found\+\_\+elem)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::utils\+::containers\+::utils\+::my\+\_\+bsearch\+\_\+id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{int64\+\_\+t}]{l\+\_\+idx, }
\item[{int64\+\_\+t}]{u\+\_\+idx, }
\item[{const typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E\+::\+T\+Id\+Type}]{key, }
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&}]{found\+\_\+elem}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1utils_1_1containers_1_1utils_a72ccbd06b023cd715ed69cc75ee8054f}
This is a binary search algorithm for some ordered array 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have ctx\+\_\+id field as this method will specifically use it to compare elements. \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}


Definition at line 180 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_a9b58dc54173e94211d0e5e3acd69702e}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}}
\index{my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+bsearch\+\_\+id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::utils\+::containers\+::utils\+::my\+\_\+bsearch\+\_\+id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{int64\+\_\+t}]{l\+\_\+idx, }
\item[{int64\+\_\+t}]{u\+\_\+idx, }
\item[{const K\+E\+Y\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{I\+D\+X\+\_\+\+T\+Y\+P\+E \&}]{found\+\_\+pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1utils_1_1containers_1_1utils_a9b58dc54173e94211d0e5e3acd69702e}
This is a binary search algorithm for some ordered array 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have ctx\+\_\+id field as this method will specifically use it to compare elements. \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}


Definition at line 200 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_af7ec60c27e50affde107ae926741b6d0}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id@{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id}}
\index{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id@{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const uint32\+\_\+t key1, const uint32\+\_\+t key2, uint32\+\_\+t \&found\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::utils\+::containers\+::utils\+::my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{int64\+\_\+t}]{l\+\_\+idx, }
\item[{int64\+\_\+t}]{u\+\_\+idx, }
\item[{const uint32\+\_\+t}]{key1, }
\item[{const uint32\+\_\+t}]{key2, }
\item[{uint32\+\_\+t \&}]{found\+\_\+pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1utils_1_1containers_1_1utils_af7ec60c27e50affde107ae926741b6d0}
This is a binary search algorithm for some ordered array for two keys 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have word\+\_\+id field as this method will specifically use it to compare elements. \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}


Definition at line 216 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_aa90a9b943e18d3d2f1f6ac58c4df713c}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+isearch\+\_\+id@{my\+\_\+isearch\+\_\+id}}
\index{my\+\_\+isearch\+\_\+id@{my\+\_\+isearch\+\_\+id}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+isearch\+\_\+id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&found\+\_\+elem)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::utils\+::containers\+::utils\+::my\+\_\+isearch\+\_\+id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{int64\+\_\+t}]{l\+\_\+idx, }
\item[{int64\+\_\+t}]{u\+\_\+idx, }
\item[{const K\+E\+Y\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&}]{found\+\_\+elem}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1utils_aa90a9b943e18d3d2f1f6ac58c4df713c}
This is an interpolated search algorithm for some ordered array W\+A\+R\+N\+I\+N\+G\+: I\+S A\+C\+T\+U\+A\+L\+L\+Y V\+E\+R\+T S\+L\+O\+W at least in the current implementation and for the current application! 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have ctx\+\_\+id field as this method will specifically use it to compare elements. \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}


Definition at line 235 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_ae11ec719b7b1058f8072e77a5a68e0be}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+lsearch\+\_\+id@{my\+\_\+lsearch\+\_\+id}}
\index{my\+\_\+lsearch\+\_\+id@{my\+\_\+lsearch\+\_\+id}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+lsearch\+\_\+id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, int64\+\_\+t l\+\_\+idx, int64\+\_\+t u\+\_\+idx, const typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E\+::\+T\+Id\+Type key, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&found\+\_\+elem)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::utils\+::containers\+::utils\+::my\+\_\+lsearch\+\_\+id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{int64\+\_\+t}]{l\+\_\+idx, }
\item[{int64\+\_\+t}]{u\+\_\+idx, }
\item[{const typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E\+::\+T\+Id\+Type}]{key, }
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$\&}]{found\+\_\+elem}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1utils_1_1containers_1_1utils_ae11ec719b7b1058f8072e77a5a68e0be}
This is a linear search algorithm for some ordered array 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}


Definition at line 355 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_acd01e6dc6a25f1501ddd95b0e22b2239}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+sort@{my\+\_\+sort}}
\index{my\+\_\+sort@{my\+\_\+sort}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+sort(\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const uint32\+\_\+t array\+\_\+size, typename T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+type is\+\_\+less\+\_\+func)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ void uva\+::utils\+::containers\+::utils\+::my\+\_\+sort (
\begin{DoxyParamCaption}
\item[{E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array\+\_\+begin, }
\item[{const uint32\+\_\+t}]{array\+\_\+size, }
\item[{typename {\bf T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C}$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+type}]{is\+\_\+less\+\_\+func}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1utils_1_1containers_1_1utils_acd01e6dc6a25f1501ddd95b0e22b2239}
This methos is used to do $<$algorithm$>$ std\+::sort on an array of structures convertable to some simple comparable type. This method does the progress bar update, if needed 
\begin{DoxyParams}{Parameters}
{\em E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element type \\
\hline
{\em array\+\_\+begin} & the pointer to the array\textquotesingle{}s first element \\
\hline
{\em array\+\_\+size} & the size of the array \\
\hline
{\em is\+\_\+less\+\_\+func} & the is-\/less function \\
\hline
\end{DoxyParams}


Definition at line 395 of file array\+\_\+utils.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1utils_ae19599c8e6a1b8495f99fe40c69db651}{}\index{uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}!my\+\_\+sort@{my\+\_\+sort}}
\index{my\+\_\+sort@{my\+\_\+sort}!uva\+::utils\+::containers\+::utils@{uva\+::utils\+::containers\+::utils}}
\subsubsection[{my\+\_\+sort(\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const uint32\+\_\+t array\+\_\+size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+ptr I\+S\+\_\+\+L\+E\+S\+S\+\_\+\+F\+U\+N\+C$>$ void uva\+::utils\+::containers\+::utils\+::my\+\_\+sort (
\begin{DoxyParamCaption}
\item[{E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array\+\_\+begin, }
\item[{const uint32\+\_\+t}]{array\+\_\+size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1utils_1_1containers_1_1utils_ae19599c8e6a1b8495f99fe40c69db651}
This methos is used to do $<$algorithm$>$ std\+::sort on an array of structures convertable to some simple comparable type. This method does the progress bar update, if needed 
\begin{DoxyParams}{Parameters}
{\em E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element type \\
\hline
{\em I\+S\+\_\+\+L\+E\+S\+S\+\_\+\+F\+U\+N\+C} & the is-\/less function \\
\hline
{\em array\+\_\+begin} & the pointer to the array\textquotesingle{}s first element \\
\hline
{\em array\+\_\+size} & the size of the array\\
\hline
\end{DoxyParams}
This methos is used to do $<$algorithm$>$ std\+::sort on an array of structures convertable to some simple comparable type. This method does the progress bar update, if needed 
\begin{DoxyParams}{Parameters}
{\em E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element type \\
\hline
{\em I\+S\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S} & if true the progress bar will be updated, otherwise not, default is true \\
\hline
{\em array\+\_\+begin} & the pointer to the array\textquotesingle{}s first element \\
\hline
{\em array\+\_\+size} & the size of the array \\
\hline
\end{DoxyParams}


Definition at line 414 of file array\+\_\+utils.\+hpp.

