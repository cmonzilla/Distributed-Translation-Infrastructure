\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc}{}\section{uva\+:\+:utils\+:\+:containers\+:\+:alloc Namespace Reference}
\label{namespaceuva_1_1utils_1_1containers_1_1alloc}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T\+Contaner , typename T\+Allocator $>$ }\\void \hyperlink{namespaceuva_1_1utils_1_1containers_1_1alloc_ae65da467dfcf6c2ee5cc8dd2be1ca469}{allocate\+\_\+container} (T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor=U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)
\item 
{\footnotesize template$<$typename T\+Contaner , typename T\+Allocator $>$ }\\void \hyperlink{namespaceuva_1_1utils_1_1containers_1_1alloc_a59048810604739dc323f29e6a80d88e6}{reserve\+\_\+mem\+\_\+unordered\+\_\+map} (T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor=U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)
\item 
{\footnotesize template$<$typename T\+Contaner , typename T\+Allocator $>$ }\\void \hyperlink{namespaceuva_1_1utils_1_1containers_1_1alloc_a3da269005cf5338d84a04ea0ac42f673}{deallocate\+\_\+container} (T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator)
\item 
{\footnotesize template$<$typename T , typename U $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1alloc_a2a5f575f106184cf526da77a91dc523a}{operator==} (const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ U $>$ \&)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1alloc_a6334b250a6461e0534b46180d4889cf4}{operator==} (const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&)
\item 
{\footnotesize template$<$typename T , typename U $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1alloc_a62ecab8a4413ec64a95b0429377caeaa}{operator!=} (const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ U $>$ \&)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespaceuva_1_1utils_1_1containers_1_1alloc_a5df4b3401f1fc6363869d3d898cb2538}{operator!=} (const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1utils_1_1containers_1_1alloc_1_1greedy__memory__allocator}{greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc_ae65da467dfcf6c2ee5cc8dd2be1ca469}{}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}!allocate\+\_\+container@{allocate\+\_\+container}}
\index{allocate\+\_\+container@{allocate\+\_\+container}!uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsubsection[{allocate\+\_\+container(\+T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor=\+U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Contaner , typename T\+Allocator $>$ void uva\+::utils\+::containers\+::alloc\+::allocate\+\_\+container (
\begin{DoxyParamCaption}
\item[{T\+Contaner $\ast$$\ast$}]{pp\+Container, }
\item[{T\+Allocator $\ast$$\ast$}]{pp\+Allocator, }
\item[{const size\+\_\+t}]{num\+Entries, }
\item[{const string}]{ct\+Name, }
\item[{const float}]{factor = {\ttfamily UNORDERED\+\_\+MAP\+\_\+MEMORY\+\_\+FACTOR}}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1alloc_ae65da467dfcf6c2ee5cc8dd2be1ca469}
This is helper function that allows to allocate the container, allocator and the actual data storage Note that, this functions is meant to be used with the unordered\+\_\+map allocator 
\begin{DoxyParams}{Parameters}
{\em pp\+Container} & the pointer to the container pointer \\
\hline
{\em pp\+Allocator} & the pointer to the allocator pointer \\
\hline
{\em num\+Entries} & the number of entries to pre-\/allocate for \\
\hline
{\em ct\+Name} & the container name for logging purposes \\
\hline
{\em factor} & the memory multiplication factor, default is U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R. This is how many times memory we will allocate (than needed to store num\+Entries elems) \\
\hline
\end{DoxyParams}


Definition at line 65 of file greedy\+\_\+memory\+\_\+allocator.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc_a3da269005cf5338d84a04ea0ac42f673}{}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}!deallocate\+\_\+container@{deallocate\+\_\+container}}
\index{deallocate\+\_\+container@{deallocate\+\_\+container}!uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsubsection[{deallocate\+\_\+container(\+T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Contaner , typename T\+Allocator $>$ void uva\+::utils\+::containers\+::alloc\+::deallocate\+\_\+container (
\begin{DoxyParamCaption}
\item[{T\+Contaner $\ast$$\ast$}]{pp\+Container, }
\item[{T\+Allocator $\ast$$\ast$}]{pp\+Allocator}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1alloc_a3da269005cf5338d84a04ea0ac42f673}
This is helper function that allows to deallocate the container allocator and actual data storage 
\begin{DoxyParams}{Parameters}
{\em pp\+Container} & the pointer to the container pointer \\
\hline
{\em pp\+Allocator} & the pointer to the allocator pointer \\
\hline
{\em pp\+Storage} & the pointer to the storage pointer \\
\hline
\end{DoxyParams}


Definition at line 113 of file greedy\+\_\+memory\+\_\+allocator.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc_a62ecab8a4413ec64a95b0429377caeaa}{}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsubsection[{operator"!=(const greedy\+\_\+memory\+\_\+allocator$<$ T $>$ \&, const greedy\+\_\+memory\+\_\+allocator$<$ U $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename U $>$ bool uva\+::utils\+::containers\+::alloc\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ U $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1alloc_a62ecab8a4413ec64a95b0429377caeaa}


Definition at line 311 of file greedy\+\_\+memory\+\_\+allocator.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc_a5df4b3401f1fc6363869d3d898cb2538}{}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsubsection[{operator"!=(const greedy\+\_\+memory\+\_\+allocator$<$ T $>$ \&, const greedy\+\_\+memory\+\_\+allocator$<$ T $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool uva\+::utils\+::containers\+::alloc\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1alloc_a5df4b3401f1fc6363869d3d898cb2538}


Definition at line 316 of file greedy\+\_\+memory\+\_\+allocator.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc_a2a5f575f106184cf526da77a91dc523a}{}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}!operator==@{operator==}}
\index{operator==@{operator==}!uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsubsection[{operator==(const greedy\+\_\+memory\+\_\+allocator$<$ T $>$ \&, const greedy\+\_\+memory\+\_\+allocator$<$ U $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename U $>$ bool uva\+::utils\+::containers\+::alloc\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ U $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1alloc_a2a5f575f106184cf526da77a91dc523a}


Definition at line 301 of file greedy\+\_\+memory\+\_\+allocator.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc_a6334b250a6461e0534b46180d4889cf4}{}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}!operator==@{operator==}}
\index{operator==@{operator==}!uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsubsection[{operator==(const greedy\+\_\+memory\+\_\+allocator$<$ T $>$ \&, const greedy\+\_\+memory\+\_\+allocator$<$ T $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool uva\+::utils\+::containers\+::alloc\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf greedy\+\_\+memory\+\_\+allocator}$<$ T $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1alloc_a6334b250a6461e0534b46180d4889cf4}


Definition at line 306 of file greedy\+\_\+memory\+\_\+allocator.\+hpp.

\hypertarget{namespaceuva_1_1utils_1_1containers_1_1alloc_a59048810604739dc323f29e6a80d88e6}{}\index{uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}!reserve\+\_\+mem\+\_\+unordered\+\_\+map@{reserve\+\_\+mem\+\_\+unordered\+\_\+map}}
\index{reserve\+\_\+mem\+\_\+unordered\+\_\+map@{reserve\+\_\+mem\+\_\+unordered\+\_\+map}!uva\+::utils\+::containers\+::alloc@{uva\+::utils\+::containers\+::alloc}}
\subsubsection[{reserve\+\_\+mem\+\_\+unordered\+\_\+map(\+T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor=\+U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Contaner , typename T\+Allocator $>$ void uva\+::utils\+::containers\+::alloc\+::reserve\+\_\+mem\+\_\+unordered\+\_\+map (
\begin{DoxyParamCaption}
\item[{T\+Contaner $\ast$$\ast$}]{pp\+Container, }
\item[{T\+Allocator $\ast$$\ast$}]{pp\+Allocator, }
\item[{const size\+\_\+t}]{num\+Entries, }
\item[{const string}]{ct\+Name, }
\item[{const float}]{factor = {\ttfamily UNORDERED\+\_\+MAP\+\_\+MEMORY\+\_\+FACTOR}}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1utils_1_1containers_1_1alloc_a59048810604739dc323f29e6a80d88e6}
This is helper function that allows to allocate the container, allocator and the actual data storage Note that, this functions is meant to be used with the unordered\+\_\+map allocator 
\begin{DoxyParams}{Parameters}
{\em pp\+Container} & the pointer to the container pointer \\
\hline
{\em pp\+Allocator} & the pointer to the allocator pointer \\
\hline
{\em num\+Entries} & the number of entries to pre-\/allocate for \\
\hline
{\em ct\+Name} & the container name for logging purposes \\
\hline
{\em factor} & the memory multiplication factor, default is U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R. This is how many times memory we will allocate (than needed to store num\+Entries elems) \\
\hline
\end{DoxyParams}


Definition at line 95 of file greedy\+\_\+memory\+\_\+allocator.\+hpp.

