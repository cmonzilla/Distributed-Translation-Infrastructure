<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Basic Phrase Based Decoding: asio::buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="owl.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Basic Phrase Based Decoding
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ client/server language translation infrastructure</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::buffer</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1ed66e401559cbfd19595392f653b47c"><td class="memItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a> (const mutable_buffer &amp;b)</td></tr>
<tr class="memdesc:ga1ed66e401559cbfd19595392f653b47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">More...</a><br /></td></tr>
<tr class="separator:ga1ed66e401559cbfd19595392f653b47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93a06eac8bd6d1db394ba92e260b9fa"><td class="memItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf93a06eac8bd6d1db394ba92e260b9fa">asio::buffer</a> (const mutable_buffer &amp;b, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gaf93a06eac8bd6d1db394ba92e260b9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#gaf93a06eac8bd6d1db394ba92e260b9fa">More...</a><br /></td></tr>
<tr class="separator:gaf93a06eac8bd6d1db394ba92e260b9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00b079c860c589f80a312b975828780"><td class="memItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gac00b079c860c589f80a312b975828780">asio::buffer</a> (const const_buffer &amp;b)</td></tr>
<tr class="memdesc:gac00b079c860c589f80a312b975828780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#gac00b079c860c589f80a312b975828780">More...</a><br /></td></tr>
<tr class="separator:gac00b079c860c589f80a312b975828780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2a3b8cbb0e8aefbc870d5f43cf5872"><td class="memItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gafe2a3b8cbb0e8aefbc870d5f43cf5872">asio::buffer</a> (const const_buffer &amp;b, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gafe2a3b8cbb0e8aefbc870d5f43cf5872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#gafe2a3b8cbb0e8aefbc870d5f43cf5872">More...</a><br /></td></tr>
<tr class="separator:gafe2a3b8cbb0e8aefbc870d5f43cf5872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa066734007c417692255c8f515f0fb01"><td class="memItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa066734007c417692255c8f515f0fb01">asio::buffer</a> (void *data, std::size_t size_in_bytes)</td></tr>
<tr class="memdesc:gaa066734007c417692255c8f515f0fb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <a href="group__buffer.html#gaa066734007c417692255c8f515f0fb01">More...</a><br /></td></tr>
<tr class="separator:gaa066734007c417692255c8f515f0fb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b6109423e7efc76b46b8d1337a5b0f"><td class="memItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa6b6109423e7efc76b46b8d1337a5b0f">asio::buffer</a> (const void *data, std::size_t size_in_bytes)</td></tr>
<tr class="memdesc:gaa6b6109423e7efc76b46b8d1337a5b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <a href="group__buffer.html#gaa6b6109423e7efc76b46b8d1337a5b0f">More...</a><br /></td></tr>
<tr class="separator:gaa6b6109423e7efc76b46b8d1337a5b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a348932d9b7ffda26ff318191489fd8"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga9a348932d9b7ffda26ff318191489fd8"><td class="memTemplItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga9a348932d9b7ffda26ff318191489fd8">asio::buffer</a> (PodType(&amp;data)[N])</td></tr>
<tr class="memdesc:ga9a348932d9b7ffda26ff318191489fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga9a348932d9b7ffda26ff318191489fd8">More...</a><br /></td></tr>
<tr class="separator:ga9a348932d9b7ffda26ff318191489fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="memTemplItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga817f0fd9a7e1eebab155ccf5b62456f0">asio::buffer</a> (PodType(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga817f0fd9a7e1eebab155ccf5b62456f0">More...</a><br /></td></tr>
<tr class="separator:ga817f0fd9a7e1eebab155ccf5b62456f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73b5385bad9b7c92afce06d92c11f1e"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gae73b5385bad9b7c92afce06d92c11f1e"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gae73b5385bad9b7c92afce06d92c11f1e">asio::buffer</a> (const PodType(&amp;data)[N])</td></tr>
<tr class="memdesc:gae73b5385bad9b7c92afce06d92c11f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gae73b5385bad9b7c92afce06d92c11f1e">More...</a><br /></td></tr>
<tr class="separator:gae73b5385bad9b7c92afce06d92c11f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37e6d30503997261200b1c9a2492182"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gae37e6d30503997261200b1c9a2492182"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gae37e6d30503997261200b1c9a2492182">asio::buffer</a> (const PodType(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gae37e6d30503997261200b1c9a2492182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gae37e6d30503997261200b1c9a2492182">More...</a><br /></td></tr>
<tr class="separator:gae37e6d30503997261200b1c9a2492182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec66696edfddf306d7c91aba75b1723"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gafec66696edfddf306d7c91aba75b1723"><td class="memTemplItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gafec66696edfddf306d7c91aba75b1723">asio::buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data)</td></tr>
<tr class="memdesc:gafec66696edfddf306d7c91aba75b1723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gafec66696edfddf306d7c91aba75b1723">More...</a><br /></td></tr>
<tr class="separator:gafec66696edfddf306d7c91aba75b1723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="memTemplItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gabcdc30c4b4b6a28885f65e7c8fe08cc2">asio::buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gabcdc30c4b4b6a28885f65e7c8fe08cc2">More...</a><br /></td></tr>
<tr class="separator:gabcdc30c4b4b6a28885f65e7c8fe08cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b564725e9315afaad270e46161ac21c"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga7b564725e9315afaad270e46161ac21c"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga7b564725e9315afaad270e46161ac21c">asio::buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data)</td></tr>
<tr class="memdesc:ga7b564725e9315afaad270e46161ac21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga7b564725e9315afaad270e46161ac21c">More...</a><br /></td></tr>
<tr class="separator:ga7b564725e9315afaad270e46161ac21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf0529bedd017b4b01fd0920e35ed22cd">asio::buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf0529bedd017b4b01fd0920e35ed22cd">More...</a><br /></td></tr>
<tr class="separator:gaf0529bedd017b4b01fd0920e35ed22cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee4fc886d2abc070fbabc77ebeb508d"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gacee4fc886d2abc070fbabc77ebeb508d"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gacee4fc886d2abc070fbabc77ebeb508d">asio::buffer</a> (const <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data)</td></tr>
<tr class="memdesc:gacee4fc886d2abc070fbabc77ebeb508d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gacee4fc886d2abc070fbabc77ebeb508d">More...</a><br /></td></tr>
<tr class="separator:gacee4fc886d2abc070fbabc77ebeb508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e496b244e3999f2035c29043cd2ff9"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gac7e496b244e3999f2035c29043cd2ff9"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gac7e496b244e3999f2035c29043cd2ff9">asio::buffer</a> (const <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gac7e496b244e3999f2035c29043cd2ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gac7e496b244e3999f2035c29043cd2ff9">More...</a><br /></td></tr>
<tr class="separator:gac7e496b244e3999f2035c29043cd2ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382ee4d2d0dd90e88e374e4344302749"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga382ee4d2d0dd90e88e374e4344302749"><td class="memTemplItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga382ee4d2d0dd90e88e374e4344302749">asio::buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data)</td></tr>
<tr class="memdesc:ga382ee4d2d0dd90e88e374e4344302749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga382ee4d2d0dd90e88e374e4344302749">More...</a><br /></td></tr>
<tr class="separator:ga382ee4d2d0dd90e88e374e4344302749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="memTemplItemLeft" align="right" valign="top">mutable_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gad0a0b6813e25e7bcce7fcfe32a5cdab9">asio::buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#gad0a0b6813e25e7bcce7fcfe32a5cdab9">More...</a><br /></td></tr>
<tr class="separator:gad0a0b6813e25e7bcce7fcfe32a5cdab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa908d4c98b0745c8c51540e153627f44"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa908d4c98b0745c8c51540e153627f44"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa908d4c98b0745c8c51540e153627f44">asio::buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data)</td></tr>
<tr class="memdesc:gaa908d4c98b0745c8c51540e153627f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#gaa908d4c98b0745c8c51540e153627f44">More...</a><br /></td></tr>
<tr class="separator:gaa908d4c98b0745c8c51540e153627f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad172ef969f244d265d3cfcfea727b904"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:gad172ef969f244d265d3cfcfea727b904"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gad172ef969f244d265d3cfcfea727b904">asio::buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gad172ef969f244d265d3cfcfea727b904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#gad172ef969f244d265d3cfcfea727b904">More...</a><br /></td></tr>
<tr class="separator:gad172ef969f244d265d3cfcfea727b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe609d07578ac226c777107fbe51eff5"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:gafe609d07578ac226c777107fbe51eff5"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gafe609d07578ac226c777107fbe51eff5">asio::buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data)</td></tr>
<tr class="memdesc:gafe609d07578ac226c777107fbe51eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#gafe609d07578ac226c777107fbe51eff5">More...</a><br /></td></tr>
<tr class="separator:gafe609d07578ac226c777107fbe51eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04e7aa3e90adacebceb59007629e923"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa04e7aa3e90adacebceb59007629e923"><td class="memTemplItemLeft" align="right" valign="top">const_buffers_1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa04e7aa3e90adacebceb59007629e923">asio::buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>
<tr class="memdesc:gaa04e7aa3e90adacebceb59007629e923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#gaa04e7aa3e90adacebceb59007629e923">More...</a><br /></td></tr>
<tr class="separator:gaa04e7aa3e90adacebceb59007629e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. </p>
<p>A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. A tuple of the form <code>{void*, size_t}</code> specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form <code>{const void*, size_t}</code> specifies a const (non-modifiable) region of memory. These two forms correspond to the classes <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> and <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a>, respectively. To mirror C++'s conversion rules, a <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> is implicitly convertible to a <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a>, and the opposite conversion is not permitted.</p>
<p>The simplest use case involves reading or writing a single buffer of a specified size:</p>
<div class="fragment"><div class="line">sock.send(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>)); </div>
</div><!-- fragment --><p>In the above example, the return value of <a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.</p>
<p>An individual buffer may be created from a builtin array, std::vector, std::array or <a class="el" href="classboost_1_1array.html">boost::array</a> of POD elements. This helps prevent buffer overruns by automatically determining the size of the buffer:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">char</span> d1[128];</div>
<div class="line"><span class="keywordtype">size_t</span> bytes_transferred = sock.receive(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d1));</div>
<div class="line"></div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line">bytes_transferred = sock.receive(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d2));</div>
<div class="line"></div>
<div class="line">std::array&lt;char, 128&gt; d3;</div>
<div class="line">bytes_transferred = sock.receive(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d3));</div>
<div class="line"></div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d4;</div>
<div class="line">bytes_transferred = sock.receive(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d4)); </div>
</div><!-- fragment --><p>In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is <em>never</em> automatically resized when creating or using a buffer. The buffer size is determined using the vector's <code><a class="el" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size()</a></code> member function, and not its capacity.</p>
<dl class="section user"><dt>Accessing Buffer Contents</dt><dd></dd></dl>
<p>The contents of a buffer may be accessed using the <a class="el" href="group__buffer__size.html">asio::buffer_size</a> and <a class="el" href="group__buffer__cast.html">asio::buffer_cast</a> functions:</p>
<div class="fragment"><div class="line"> <a class="code" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> b1 = ...;</div>
<div class="line">std::size_t s1 = <a class="code" href="group__buffer__size.html#gabe8b5f116fbb66004b6d0ba8ee39c3d5">asio::buffer_size</a>(b1);</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* p1 = <a class="code" href="group__buffer__cast.html#ga6faa5f9daa2512cc9c3cefa8b5ab0704">asio::buffer_cast</a>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*&gt;(b1);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b2 = ...;</div>
<div class="line">std::size_t s2 = <a class="code" href="group__buffer__size.html#gabe8b5f116fbb66004b6d0ba8ee39c3d5">asio::buffer_size</a>(b2);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>* p2 = <a class="code" href="group__buffer__cast.html#ga6faa5f9daa2512cc9c3cefa8b5ab0704">asio::buffer_cast</a>&lt;<span class="keyword">const</span> <span class="keywordtype">void</span>*&gt;(b2); </div>
</div><!-- fragment --><p>The <a class="el" href="group__buffer__cast.html#ga6faa5f9daa2512cc9c3cefa8b5ab0704" title="Cast a non-modifiable buffer to a specified pointer to POD type. ">asio::buffer_cast</a> function permits violations of type safety, so uses of it in application code should be carefully considered.</p>
<p>For convenience, the <a class="el" href="group__buffer__size.html">asio::buffer_size</a> function also works on buffer sequences (that is, types meeting the ConstBufferSequence or MutableBufferSequence type requirements). In this case, the function returns the total size of all buffers in the sequence.</p>
<dl class="section user"><dt>Buffer Copying</dt><dd></dd></dl>
<p>The <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function may be used to copy raw bytes between individual buffers and buffer sequences.</p>
<p>In particular, when used with the <a class="el" href="group__buffer__size.html">asio::buffer_size</a>, the <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function can be used to linearise a sequence of buffers. For example:</p>
<div class="fragment"><div class="line"> vector&lt;const_buffer&gt; <a class="code" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">buffers</a> = ...;</div>
<div class="line"></div>
<div class="line">vector&lt;unsigned char&gt; data(<a class="code" href="group__buffer__size.html#gabe8b5f116fbb66004b6d0ba8ee39c3d5">asio::buffer_size</a>(buffers));</div>
<div class="line"><a class="code" href="group__buffer__copy.html#ga8bc8cbf49a91e58205de746721d614d8">asio::buffer_copy</a>(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data), buffers); </div>
</div><!-- fragment --><p>Note that <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions.</p>
<dl class="section user"><dt>Buffer Invalidation</dt><dd></dd></dl>
<p>A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/O operation. When the memory is no longer available, the buffer is said to have been invalidated.</p>
<p>For the <a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)</p>
<p>For the <a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> overloads that accept an argument of type std::basic_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).</p>
<dl class="section user"><dt>Buffer Arithmetic</dt><dd></dd></dl>
<p>Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 6&gt;</a> a = { <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span> }; </div>
</div><!-- fragment --><p>A buffer object <code>b1</code> created using:</p>
<div class="fragment"><div class="line">b1 = <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(a); </div>
</div><!-- fragment --><p>represents the entire array, <code>{ 'a', 'b', 'c', 'd', 'e' }</code>. An optional second argument to the <a class="el" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> function may be used to limit the size, in bytes, of the buffer:</p>
<div class="fragment"><div class="line">b2 = <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(a, 3); </div>
</div><!-- fragment --><p>such that <code>b2</code> represents the data <code>{ 'a', 'b', 'c' }</code>. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.</p>
<p>An offset may be applied to an existing buffer to create a new one:</p>
<div class="fragment"><div class="line">b3 = b1 + 2; </div>
</div><!-- fragment --><p>where <code>b3</code> will set to represent <code>{ 'c', 'd', 'e' }</code>. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.</p>
<p>Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer:</p>
<div class="fragment"><div class="line">b4 = <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(b1 + 1, 3); </div>
</div><!-- fragment --><p>so that <code>b4</code> will refer to the bytes <code>{ 'b', 'c', 'd' }</code>.</p>
<dl class="section user"><dt>Buffers and Scatter-Gather I/O</dt><dd></dd></dl>
<p>To read or write using multiple buffers (i.e. scatter-gather I/O), multiple buffer objects may be assigned into a container that supports the MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> d1[128];</div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d3;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;mutable_buffer, 3&gt;</a> bufs1 = {</div>
<div class="line">  <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d1),</div>
<div class="line">  <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d2),</div>
<div class="line">  <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d3) };</div>
<div class="line">bytes_transferred = sock.receive(bufs1);</div>
<div class="line"></div>
<div class="line">std::vector&lt;const_buffer&gt; bufs2;</div>
<div class="line">bufs2.push_back(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d1));</div>
<div class="line">bufs2.push_back(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d2));</div>
<div class="line">bufs2.push_back(<a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(d3));</div>
<div class="line">bytes_transferred = sock.send(bufs2); </div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1ed66e401559cbfd19595392f653b47c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>mutable_buffers_1(b)</code>. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00706">706</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf93a06eac8bd6d1db394ba92e260b9fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffers_1(</div>
<div class="line">   buffer_cast&lt;void*&gt;(<a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>),</div>
<div class="line">   min(<a class="code" href="group__buffer__size.html#gabe8b5f116fbb66004b6d0ba8ee39c3d5">buffer_size</a>(<a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00718">718</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac00b079c860c589f80a312b975828780"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>const_buffers_1(b)</code>. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00735">735</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafe2a3b8cbb0e8aefbc870d5f43cf5872"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   buffer_cast&lt;const void*&gt;(<a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>),</div>
<div class="line">   min(<a class="code" href="group__buffer__size.html#gabe8b5f116fbb66004b6d0ba8ee39c3d5">buffer_size</a>(<a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00747">747</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa066734007c417692255c8f515f0fb01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>mutable_buffers_1(data, size_in_bytes)</code>. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00764">764</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa6b6109423e7efc76b46b8d1337a5b0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>const_buffers_1(data, size_in_bytes)</code>. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00773">773</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a348932d9b7ffda26ff318191489fd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffers_1(</div>
<div class="line">   static_cast&lt;void*&gt;(data),</div>
<div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00787">787</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga817f0fd9a7e1eebab155ccf5b62456f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffers_1(</div>
<div class="line">   static_cast&lt;void*&gt;(data),</div>
<div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00800">800</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae73b5385bad9b7c92afce06d92c11f1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   static_cast&lt;const void*&gt;(data),</div>
<div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00817">817</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae37e6d30503997261200b1c9a2492182"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   static_cast&lt;const void*&gt;(data),</div>
<div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00830">830</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafec66696edfddf306d7c91aba75b1723"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffers_1(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00916">916</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gabcdc30c4b4b6a28885f65e7c8fe08cc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffers_1(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00930">930</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7b564725e9315afaad270e46161ac21c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00947">947</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0529bedd017b4b01fd0920e35ed22cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00961">961</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacee4fc886d2abc070fbabc77ebeb508d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   data.data(),</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00980">980</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac7e496b244e3999f2035c29043cd2ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00994">994</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga382ee4d2d0dd90e88e374e4344302749"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffers_1(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l01111">1111</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad0a0b6813e25e7bcce7fcfe32a5cdab9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffers_1(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l01134">1134</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa908d4c98b0745c8c51540e153627f44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l01160">1160</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gad172ef969f244d265d3cfcfea727b904"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   data.size() ? &amp;data[0] : 0,</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l01184">1184</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafe609d07578ac226c777107fbe51eff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a>(data.data(), <a class="el" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">data.size()</a> * sizeof(Elem))</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l01207">1207</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaa04e7aa3e90adacebceb59007629e923"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_buffers_1 asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a> value equivalent to: <div class="fragment"><div class="line">const_buffers_1(</div>
<div class="line">   data.data(),</div>
<div class="line">   min(data.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l01230">1230</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
