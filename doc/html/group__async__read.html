<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Basic Phrase Based Decoding: asio::async_read</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="owl.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Basic Phrase Based Decoding
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ client/server language translation infrastructure</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__async__read.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">asio::async_read</div>  </div>
</div><!--header-->
<div class="contents">

<p>Start an asynchronous operation to read a certain amount of data from a stream.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b">asio::ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;s</td></tr>
<tr class="separator:ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41f6414b06e189a76689422b8e2db35"><td class="memItemLeft" align="right" valign="top">const MutableBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#gac41f6414b06e189a76689422b8e2db35">asio::ASIO_MOVE_ARG</a> (ReadHandler) handler)</td></tr>
<tr class="separator:gac41f6414b06e189a76689422b8e2db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab321259782b3683c80f33eb1050a3251"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gab321259782b3683c80f33eb1050a3251"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gab321259782b3683c80f33eb1050a3251">asio::ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;s</td></tr>
<tr class="separator:gab321259782b3683c80f33eb1050a3251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga54dede45c3175148a77fe6635222c47d"><td class="memItemLeft" align="right" valign="top">const MutableBufferSequence &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga54dede45c3175148a77fe6635222c47d">asio::buffers</a></td></tr>
<tr class="separator:ga54dede45c3175148a77fe6635222c47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e215d5013596cc2b385bb6c13fa518"><td class="memItemLeft" align="right" valign="top">const MutableBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">asio::completion_condition</a></td></tr>
<tr class="separator:gae2e215d5013596cc2b385bb6c13fa518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945a5c18fa77a9e2eba420f8f44b2a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">asio::b</a></td></tr>
<tr class="separator:ga945a5c18fa77a9e2eba420f8f44b2a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d72a97784dde9476c6d93b8904a4967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga6d72a97784dde9476c6d93b8904a4967">asio::ASIO_MOVE_ARG</a> (ReadHandler) handler)</td></tr>
<tr class="separator:ga6d72a97784dde9476c6d93b8904a4967"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab321259782b3683c80f33eb1050a3251"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line"></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>,</div>
<div class="line">   <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>),</div>
<div class="line">   <a class="code" href="group__completion__condition.html#ga2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line"></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read_at(d, 42,</div>
<div class="line">   <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>),</div>
<div class="line">   <a class="code" href="group__completion__condition.html#ga2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code" href="group__async__read.html#gae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Start an asynchronous operation to read data into a streambuf until a function object indicates a match. This function is used to asynchronously read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code" href="group__async__read__until.html#ga950b81fb954e4a0f01e13a57e15721b4">match_condition</a>(iterator <a class="code" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, iterator <a class="code" href="group__async__connect.html#gadb6ad0193229ae84828688e812cd325c">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area that have been fully consumed by the</span></div>
<div class="line">  <span class="comment">// match function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"></div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator <a class="code" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>, iterator <a class="code" href="group__async__connect.html#gadb6ad0193229ae84828688e812cd325c">end</a>)</div>
<div class="line">{</div>
<div class="line">  iterator i = <a class="code" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (i != end)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>);</div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line">asio::async_read_until(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, match_whitespace, handler);</div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> c) : c_(c) {}</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator i = <a class="code" href="group__async__connect.html#ga7055bca9225050c030c19c7dc926fa53">begin</a>;</div>
<div class="line">    <span class="keywordflow">while</span> (i != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>);</div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line">asio::async_read_until(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, match_char(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line"></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read(</div>
<div class="line">   <a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, buffers,</div>
<div class="line">   <a class="code" href="group__completion__condition.html#ga4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line"></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read(</div>
<div class="line">   <a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code" href="group__completion__condition.html#ga4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read_at(d, 42, <a class="code" href="group__buffer.html#ga1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read_at(</div>
<div class="line">   d, 42, buffers,</div>
<div class="line">   <a class="code" href="group__completion__condition.html#ga4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read_at(</div>
<div class="line">   d, 42, <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code" href="group__completion__condition.html#ga4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t <a class="code" href="namespaceuva_1_1utils_1_1containers.html#aea6a0a858974dd7edb4227dcbcbc1eb6a0be5bdf7cf8c7c58d0bc5678caa07791">size</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;b);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, b, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__service.html#ae01f809800017295e39786f5bca6652e" title="Request the io_service to invoke the given handler and return immediately. ">asio::io_service::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> <a class="code" href="group__async__read.html#ga945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;b);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code" href="group__async__connect.html#ga31ab74b9ea6c77932dddd016cfc7920a">s</a>, b, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac41f6414b06e189a76689422b8e2db35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const MutableBufferSequence CompletionCondition asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2read_8hpp_source.html#l00523">523</a> of file <a class="el" href="impl_2read_8hpp_source.html">read.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga6d72a97784dde9476c6d93b8904a4967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t basic_streambuf&lt; Allocator &gt; CompletionCondition asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2read_8hpp_source.html#l00704">704</a> of file <a class="el" href="impl_2read_8hpp_source.html">read.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga945a5c18fa77a9e2eba420f8f44b2a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t basic_streambuf&lt; Allocator &gt; &amp; asio::b</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2read_8hpp_source.html#l00702">702</a> of file <a class="el" href="impl_2read_8hpp_source.html">read.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga54dede45c3175148a77fe6635222c47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t const ConstBufferSequence &amp; asio::buffers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2read_8hpp_source.html#l00521">521</a> of file <a class="el" href="impl_2read_8hpp_source.html">read.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae2e215d5013596cc2b385bb6c13fa518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t basic_streambuf&lt; Allocator &gt; CompletionCondition asio::completion_condition</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="impl_2read_8hpp_source.html#l00521">521</a> of file <a class="el" href="impl_2read_8hpp_source.html">read.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
