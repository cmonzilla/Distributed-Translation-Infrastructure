<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>My Project: uva::smt::tries::AHashMapTrie&lt; N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuva.html">uva</a></li><li class="navelem"><a class="el" href="namespaceuva_1_1smt.html">smt</a></li><li class="navelem"><a class="el" href="namespaceuva_1_1smt_1_1tries.html">tries</a></li><li class="navelem"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">AHashMapTrie</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uva::smt::tries::AHashMapTrie&lt; N &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_a_hash_map_trie_8hpp_source.html">AHashMapTrie.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uva::smt::tries::AHashMapTrie&lt; N &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.png" usemap="#uva::smt::tries::AHashMapTrie&lt; N &gt;_map" alt=""/>
  <map id="uva::smt::tries::AHashMapTrie&lt; N &gt;_map" name="uva::smt::tries::AHashMapTrie&lt; N &gt;_map">
<area href="classuva_1_1smt_1_1tries_1_1_a_trie.html" alt="uva::smt::tries::ATrie&lt; N &gt;" shape="rect" coords="281,0,552,24"/>
<area href="classuva_1_1smt_1_1tries_1_1_context_multi_hash_map_trie.html" alt="uva::smt::tries::ContextMultiHashMapTrie&lt; N &gt;" shape="rect" coords="0,112,271,136"/>
<area href="classuva_1_1smt_1_1tries_1_1_multi_hash_map_trie.html" alt="uva::smt::tries::MultiHashMapTrie&lt; N &gt;" shape="rect" coords="281,112,552,136"/>
<area href="classuva_1_1smt_1_1tries_1_1_single_hash_map_trie.html" alt="uva::smt::tries::SingleHashMapTrie&lt; N &gt;" shape="rect" coords="562,112,833,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a97fbb7a95590096e7416f82b2016998e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a97fbb7a95590096e7416f82b2016998e">AHashMapTrie</a> (const float wordIndexMemFactor)</td></tr>
<tr class="separator:a97fbb7a95590096e7416f82b2016998e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867b72350326f464b563fba6727ba5f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#ad867b72350326f464b563fba6727ba5f">preAllocate</a> (const size_t counts[N])</td></tr>
<tr class="separator:ad867b72350326f464b563fba6727ba5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5118f2f3566fd37b41998ef405ca6df1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a5118f2f3566fd37b41998ef405ca6df1">~AHashMapTrie</a> ()</td></tr>
<tr class="separator:a5118f2f3566fd37b41998ef405ca6df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_trie.html">uva::smt::tries::ATrie&lt; N &gt;</a></td></tr>
<tr class="memitem:af184dbb0b095d24c76f79c7da6479eda inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_trie.html#af184dbb0b095d24c76f79c7da6479eda">add1Gram</a> (const <a class="el" href="structuva_1_1smt_1_1tries_1_1_s_back_off_n_gram.html">SBackOffNGram</a> &amp;oGram)=0</td></tr>
<tr class="separator:af184dbb0b095d24c76f79c7da6479eda inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf62fc322ece5ec01ca00e96e17eb9ef inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_trie.html#acf62fc322ece5ec01ca00e96e17eb9ef">addMGram</a> (const <a class="el" href="structuva_1_1smt_1_1tries_1_1_s_back_off_n_gram.html">SBackOffNGram</a> &amp;mGram)=0</td></tr>
<tr class="separator:acf62fc322ece5ec01ca00e96e17eb9ef inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c090a5651e74304cf37b131ca9741 inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_trie.html#a240c090a5651e74304cf37b131ca9741">addNGram</a> (const <a class="el" href="structuva_1_1smt_1_1tries_1_1_s_back_off_n_gram.html">SBackOffNGram</a> &amp;nGram)=0</td></tr>
<tr class="separator:a240c090a5651e74304cf37b131ca9741 inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2fa839686009a777f4ffbd12f1284f inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuva_1_1smt_1_1tries.html#a26064146e98856c7c4185efab0e61a36">TModelLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_trie.html#a3b2fa839686009a777f4ffbd12f1284f">getNGramLevel</a> () const </td></tr>
<tr class="separator:a3b2fa839686009a777f4ffbd12f1284f inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f8301bb7a9e7a232f16bcd000062b2 inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_trie.html#a86f8301bb7a9e7a232f16bcd000062b2">queryNGram</a> (const vector&lt; string &gt; &amp;ngram, <a class="el" href="structuva_1_1smt_1_1tries_1_1_s_prob_result.html">SProbResult</a> &amp;result)=0</td></tr>
<tr class="separator:a86f8301bb7a9e7a232f16bcd000062b2 inherit pub_methods_classuva_1_1smt_1_1tries_1_1_a_trie"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a42ba762f7a711f22111b3fefa46d418a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a42ba762f7a711f22111b3fefa46d418a">AHashMapTrie</a> (const <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">AHashMapTrie</a> &amp;orig)</td></tr>
<tr class="separator:a42ba762f7a711f22111b3fefa46d418a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59ec4b6c4f0cb7eb4f1f4140bf9b9de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#aa59ec4b6c4f0cb7eb4f1f4140bf9b9de">getBackOffNGramEndWordHash</a> ()</td></tr>
<tr class="separator:aa59ec4b6c4f0cb7eb4f1f4140bf9b9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c44c85dd64be9c9238d7313eb4dfcc9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a0c44c85dd64be9c9238d7313eb4dfcc9">getNGramEndWordHash</a> ()</td></tr>
<tr class="separator:a0c44c85dd64be9c9238d7313eb4dfcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98254f0f1271f1651b3c70acbce8fcb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a98254f0f1271f1651b3c70acbce8fcb3">tokensToHashes</a> (const vector&lt; string &gt; &amp;tokens, <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> wordHashes[N])</td></tr>
<tr class="separator:a98254f0f1271f1651b3c70acbce8fcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababc583f0e22e3be69345bb43211fef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#ababc583f0e22e3be69345bb43211fef6">storeNGramHashes</a> (const vector&lt; string &gt; &amp;ngram)</td></tr>
<tr class="separator:ababc583f0e22e3be69345bb43211fef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb2b99ca8211bd45a343922b64cc96f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a1fb2b99ca8211bd45a343922b64cc96f">computeHashContext</a> (const <a class="el" href="namespaceuva_1_1smt_1_1tries.html#a26064146e98856c7c4185efab0e61a36">TModelLevel</a> contextLength, bool isBackOff)</td></tr>
<tr class="separator:a1fb2b99ca8211bd45a343922b64cc96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a340430c87c0fb0725004689e8b47a0"><td class="memTemplParams" colspan="2">template&lt;Logger::DebugLevel logLevel&gt; </td></tr>
<tr class="memitem:a9a340430c87c0fb0725004689e8b47a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a9a340430c87c0fb0725004689e8b47a0">computeHashContext</a> (const vector&lt; string &gt; &amp;tokens)</td></tr>
<tr class="separator:a9a340430c87c0fb0725004689e8b47a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae50ef05783fc3ca8367610475fe9b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#aae50ef05783fc3ca8367610475fe9b40">getUniqueIdHash</a> (const string &amp;str)</td></tr>
<tr class="separator:aae50ef05783fc3ca8367610475fe9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23c5ad2dea14220aa3a61edcbd5346a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#ad23c5ad2dea14220aa3a61edcbd5346a">createUniqueIdHash</a> (const string &amp;str)</td></tr>
<tr class="separator:ad23c5ad2dea14220aa3a61edcbd5346a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f7c7d7f0c8dddd5fc2ea5318e58109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#af3f7c7d7f0c8dddd5fc2ea5318e58109">recordAndCheck</a> (const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> wordHash, const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> contextHash, const <a class="el" href="structuva_1_1smt_1_1tries_1_1_s_back_off_n_gram.html">SBackOffNGram</a> &amp;gram) const </td></tr>
<tr class="separator:af3f7c7d7f0c8dddd5fc2ea5318e58109"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af4aac18ab4f9db12bae8ba0ee8f63d92"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#af4aac18ab4f9db12bae8ba0ee8f63d92">createContext</a> (<a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> hash, <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> context)</td></tr>
<tr class="separator:af4aac18ab4f9db12bae8ba0ee8f63d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a35a764c83eafb369f7b858fa9b826e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html#a9a35a764c83eafb369f7b858fa9b826e">dessolveContext</a> (const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> context, <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> &amp;subWord, <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> &amp;subContext)</td></tr>
<tr class="separator:a9a35a764c83eafb369f7b858fa9b826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;TModelLevel N&gt;<br />
class uva::smt::tries::AHashMapTrie&lt; N &gt;</h3>

<p>This is a base abstract class for the Trie implementation using hash tables. The class only contains a few basic features, such as hashing functions and methods for working with the queued M-gram. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97fbb7a95590096e7416f82b2016998e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::<a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">AHashMapTrie</a> </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>wordIndexMemFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The basic class constructor, accepts memory factor(s) that are the coefficients used when pre-allocating memory for unordered maps.</p>
<p>If a factor is equal to 0.0 then no memory is pre-allocated. If the factor is equal to 1.0 then there is only as much preallocated as needed to store the gram entries. The latter is typically not enough as unordered_map needs more memory for internal administration. If there is not enough memory pre-allocated then additional allocations will take place but it does not alway lead to more efficient memory usage. The observed behavior is that it is better to pre-allocate a bit more memory beforehand, than needed. This leads to less memory consumption. Depending on the type of unordered_map key/value pair types the advised factor values are from 2.0 to 2.6. Because it can not be optimally determined beforehand, these are made constructor parameters so that they can be configured by the used. This breaks encapsulation a bit, exposing the internals, but there is no other better way, for fine tuning the memory usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wordIndexMemFactor</td><td>the assigned memory factor for storage allocation in the unordered_map used for the word index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5118f2f3566fd37b41998ef405ca6df1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::~<a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">AHashMapTrie</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The basic class destructor </p>

</div>
</div>
<a class="anchor" id="a42ba762f7a711f22111b3fefa46d418a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::<a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">AHashMapTrie</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">AHashMapTrie</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy constructor, is made private as we do not intend to copy this class objects </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig</td><td>the object to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1fb2b99ca8211bd45a343922b64cc96f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::computeHashContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceuva_1_1smt_1_1tries.html#a26064146e98856c7c4185efab0e61a36">TModelLevel</a>&#160;</td>
          <td class="paramname"><em>contextLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the context hash for the M-Gram prefix, example:</p>
<p>N = 5</p>
<p>0 1 2 3 4 w1 w2 w3 w4 w5</p>
<p>contextLength = 2</p>
<p>0 1 2 3 4 w1 w2 w3 w4 w5 ^ ^ Hash will be computed for the 3-gram prefix w3 w4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contextLength</td><td>the length of the context to compute </td></tr>
    <tr><td class="paramname">isBackOff</td><td>is the boolean flag that determines whether we compute the context for the entire M-Gram or for the back-off sub-M-gram. For the latter we consider w1 w2 w3 w4 only </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the computed hash context </dd></dl>

</div>
</div>
<a class="anchor" id="a9a340430c87c0fb0725004689e8b47a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<div class="memtemplate">
template&lt;Logger::DebugLevel logLevel&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::computeHashContext </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tokens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes the hash context of the N-gram given by the tokens, e.g. [w1 w2 w3 w4] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tokens</td><td>the N-gram tokens </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting hash of the context(w1 w2 w3) or UNDEFINED_WORD_HASH for any M-Gram with M &lt;= 1 </dd></dl>

</div>
</div>
<a class="anchor" id="af4aac18ab4f9db12bae8ba0ee8f63d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::createContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the N-Gram context using the previous context and the current word hash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>the current word hash </td></tr>
    <tr><td class="paramname">context</td><td>the previous context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting context </dd></dl>

</div>
</div>
<a class="anchor" id="ad23c5ad2dea14220aa3a61edcbd5346a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::createUniqueIdHash </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function creates/gets a hash for the given word. Note: The hash id will be unique! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the word to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting hash </dd></dl>

</div>
</div>
<a class="anchor" id="a9a35a764c83eafb369f7b858fa9b826e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::dessolveContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> &amp;&#160;</td>
          <td class="paramname"><em>subWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a> &amp;&#160;</td>
          <td class="paramname"><em>subContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function dissolves the given Ngram context (for N&gt;=2) into a sub-word hash and a sub-context: c(w_n) is defined by hash(w_n) and c(w_(n-1)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the given context to dissolve </td></tr>
    <tr><td class="paramname">subWord</td><td>the sub-work </td></tr>
    <tr><td class="paramname">subContext</td><td>the sub-context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa59ec4b6c4f0cb7eb4f1f4140bf9b9de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a>&amp; <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::getBackOffNGramEndWordHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the word hash for the end word of the back-off N-Gram </p><dl class="section return"><dt>Returns</dt><dd>the word hash for the end word of the back-off N-Gram </dd></dl>

</div>
</div>
<a class="anchor" id="a0c44c85dd64be9c9238d7313eb4dfcc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a>&amp; <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::getNGramEndWordHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the word hash for the last word in the N-gram </p><dl class="section return"><dt>Returns</dt><dd>the word hash for the last word in the N-gram </dd></dl>

</div>
</div>
<a class="anchor" id="aae50ef05783fc3ca8367610475fe9b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a> <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::getUniqueIdHash </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets a hash for the given word word based no the stored 1-Grams. If the word is not known then an unknown word ID is returned: UNKNOWN_WORD_HASH </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the word to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting hash </dd></dl>

</div>
</div>
<a class="anchor" id="ad867b72350326f464b563fba6727ba5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::preAllocate </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>counts</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The defaul implementation that pre-allocates the wordIndex </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counts</td><td>the number of ngrams </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_trie.html#a642f48565e195a41a768b2cfa247735a">uva::smt::tries::ATrie&lt; N &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classuva_1_1smt_1_1tries_1_1_context_multi_hash_map_trie.html#ac744e6f6e63317d1f955ac96d504f724">uva::smt::tries::ContextMultiHashMapTrie&lt; N &gt;</a>, <a class="el" href="classuva_1_1smt_1_1tries_1_1_multi_hash_map_trie.html#ac7d916356f0ad36d33c0c4722e6459b9">uva::smt::tries::MultiHashMapTrie&lt; N &gt;</a>, and <a class="el" href="classuva_1_1smt_1_1tries_1_1_single_hash_map_trie.html#a6a40f4047280dedc7f402d6502547b2c">uva::smt::tries::SingleHashMapTrie&lt; N &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af3f7c7d7f0c8dddd5fc2ea5318e58109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::recordAndCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a>&#160;</td>
          <td class="paramname"><em>wordHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceuva_1_1smt_1_1hashing.html#a6cc10b288b11b76c718a898b022fbdd1">TReferenceHashSize</a>&#160;</td>
          <td class="paramname"><em>contextHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structuva_1_1smt_1_1tries_1_1_s_back_off_n_gram.html">SBackOffNGram</a> &amp;&#160;</td>
          <td class="paramname"><em>gram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ababc583f0e22e3be69345bb43211fef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::storeNGramHashes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ngram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the given tokens to hashes and stores it in mGramWordHashes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ngram</td><td>the n-gram tokens to convert to hashes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98254f0f1271f1651b3c70acbce8fcb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TModelLevel N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuva_1_1smt_1_1tries_1_1_a_hash_map_trie.html">uva::smt::tries::AHashMapTrie</a>&lt; N &gt;::tokensToHashes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tokens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceuva_1_1smt_1_1hashing.html#acdc1f2765e669283f8e9c1ed42705314">TWordHashSize</a>&#160;</td>
          <td class="paramname"><em>wordHashes</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method converts the M-Gram tokens into hashes and stores them in an array. Note that, M is the size of the tokens array. It is not checked, for the sake of performance but is assumed that M is &lt;= N! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tokens</td><td>the tokens to be transformed into word hashes must have size &lt;=N </td></tr>
    <tr><td class="paramname">wordHashes</td><td>the out array parameter to store the hashes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>inc/<a class="el" href="_a_hash_map_trie_8hpp_source.html">AHashMapTrie.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
