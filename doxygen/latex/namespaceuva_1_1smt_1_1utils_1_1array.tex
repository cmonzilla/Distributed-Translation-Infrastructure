\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array}{}\section{uva\+:\+:smt\+:\+:utils\+:\+:array Namespace Reference}
\label{namespaceuva_1_1smt_1_1utils_1_1array}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structuva_1_1smt_1_1utils_1_1array_1_1_t___i_s___c_o_m_p_a_r_e___f_u_n_c}{T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C}
\item 
struct \hyperlink{structuva_1_1smt_1_1utils_1_1array_1_1_t___i_s___e_x_t___c_o_m_p_a_r_e___f_u_n_c}{T\+\_\+\+I\+S\+\_\+\+E\+X\+T\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E , typename T\+\_\+\+I\+S\+\_\+\+E\+X\+T\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+ptr C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_affeb6f6d61ece2d0624f00766eb46758}{my\+\_\+bsearch\+\_\+id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_a0920891dd342be4161a27c64f923fb14}{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const T\+Short\+Id key1, const T\+Short\+Id key2, T\+Short\+Id \&found\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_a0cbe9d57fad5df035d7ea732d5d8e897}{my\+\_\+bsearch\+\_\+id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_a6076438d9e556212f17764269292e28a}{my\+\_\+isearch\+\_\+id} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_a8521db16ea82bce46a07bbdb3708a5a9}{my\+\_\+lsearch} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)
\item 
{\footnotesize template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_af6085b8042d506eda2b2591614b43746}{my\+\_\+bsearch} (const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E l\+\_\+idx, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E \&mid\+\_\+pos)
\item 
{\footnotesize template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ }\\void \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_a0134027046c3e661f065c4366fc0e7d1}{my\+\_\+sort} (E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const T\+Short\+Id array\+\_\+size, typename \hyperlink{structuva_1_1smt_1_1utils_1_1array_1_1_t___i_s___c_o_m_p_a_r_e___f_u_n_c}{T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C}$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+type is\+\_\+less\+\_\+func)
\item 
{\footnotesize template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+ptr I\+S\+\_\+\+L\+E\+S\+S\+\_\+\+F\+U\+N\+C$>$ }\\void \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_ae4bb9605bac91686c73ea21648799154}{my\+\_\+sort} (E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const T\+Short\+Id array\+\_\+size)
\item 
{\footnotesize template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , bool I\+S\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S = true$>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1utils_1_1array_ad3369b36af8318c28e9dabc5bfae99f9}{is\+\_\+less} (const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&first, const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&second)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_ad3369b36af8318c28e9dabc5bfae99f9}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!is\+\_\+less@{is\+\_\+less}}
\index{is\+\_\+less@{is\+\_\+less}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{is\+\_\+less(const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&first, const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&second)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , bool I\+S\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S = true$>$ bool uva\+::smt\+::utils\+::array\+::is\+\_\+less (
\begin{DoxyParamCaption}
\item[{const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&}]{first, }
\item[{const E\+L\+E\+M\+\_\+\+T\+Y\+P\+E \&}]{second}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1smt_1_1utils_1_1array_ad3369b36af8318c28e9dabc5bfae99f9}
The basic \char`\"{}is less\char`\"{} function for the sort algorithms that allows to update the progress bar. 
\begin{DoxyParams}{Parameters}
{\em first} & the first element to compare \\
\hline
{\em second} & the second element to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the first element is less then the second 
\end{DoxyReturn}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_af6085b8042d506eda2b2591614b43746}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+bsearch@{my\+\_\+bsearch}}
\index{my\+\_\+bsearch@{my\+\_\+bsearch}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+bsearch(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E l\+\_\+idx, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E \&mid\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::smt\+::utils\+::array\+::my\+\_\+bsearch (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E}]{l\+\_\+idx, }
\item[{I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E}]{u\+\_\+idx, }
\item[{const K\+E\+Y\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E \&}]{mid\+\_\+pos}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1utils_1_1array_af6085b8042d506eda2b2591614b43746}
This is a search algorithm for some ordered array, here we use bsearch from $<$cstdlib$>$ 
\begin{DoxyParams}{Parameters}
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em mid\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_affeb6f6d61ece2d0624f00766eb46758}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}}
\index{my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+bsearch\+\_\+id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E , typename T\+\_\+\+I\+S\+\_\+\+E\+X\+T\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+ptr C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$>$ bool uva\+::smt\+::utils\+::array\+::my\+\_\+bsearch\+\_\+id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{T\+S\+Long\+Id}]{l\+\_\+idx, }
\item[{T\+S\+Long\+Id}]{u\+\_\+idx, }
\item[{const K\+E\+Y\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{I\+D\+X\+\_\+\+T\+Y\+P\+E \&}]{found\+\_\+pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1smt_1_1utils_1_1array_affeb6f6d61ece2d0624f00766eb46758}
This is a binary search algorithm for some ordered array 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have id field as this method will specifically use it to compare elements. \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em C\+O\+M\+P\+A\+R\+E} & the compare function template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_a0cbe9d57fad5df035d7ea732d5d8e897}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}}
\index{my\+\_\+bsearch\+\_\+id@{my\+\_\+bsearch\+\_\+id}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+bsearch\+\_\+id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::smt\+::utils\+::array\+::my\+\_\+bsearch\+\_\+id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{T\+S\+Long\+Id}]{l\+\_\+idx, }
\item[{T\+S\+Long\+Id}]{u\+\_\+idx, }
\item[{const K\+E\+Y\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{I\+D\+X\+\_\+\+T\+Y\+P\+E \&}]{found\+\_\+pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1smt_1_1utils_1_1array_a0cbe9d57fad5df035d7ea732d5d8e897}
This is a binary search algorithm for some ordered array 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have ctx\+Id field as this method will specifically use it to compare elements. \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_a0920891dd342be4161a27c64f923fb14}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id@{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id}}
\index{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id@{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const T\+Short\+Id key1, const T\+Short\+Id key2, T\+Short\+Id \&found\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::smt\+::utils\+::array\+::my\+\_\+bsearch\+\_\+word\+Id\+\_\+ctx\+Id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{T\+S\+Long\+Id}]{l\+\_\+idx, }
\item[{T\+S\+Long\+Id}]{u\+\_\+idx, }
\item[{const T\+Short\+Id}]{key1, }
\item[{const T\+Short\+Id}]{key2, }
\item[{T\+Short\+Id \&}]{found\+\_\+pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1smt_1_1utils_1_1array_a0920891dd342be4161a27c64f923fb14}
This is a binary search algorithm for some ordered array for two keys 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have word\+Id field as this method will specifically use it to compare elements. \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_a6076438d9e556212f17764269292e28a}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+isearch\+\_\+id@{my\+\_\+isearch\+\_\+id}}
\index{my\+\_\+isearch\+\_\+id@{my\+\_\+isearch\+\_\+id}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+isearch\+\_\+id(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const K\+E\+Y\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E , typename K\+E\+Y\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::smt\+::utils\+::array\+::my\+\_\+isearch\+\_\+id (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{T\+S\+Long\+Id}]{l\+\_\+idx, }
\item[{T\+S\+Long\+Id}]{u\+\_\+idx, }
\item[{const K\+E\+Y\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{I\+D\+X\+\_\+\+T\+Y\+P\+E \&}]{found\+\_\+pos}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1utils_1_1array_a6076438d9e556212f17764269292e28a}
This is an interpolated search algorithm for some ordered array W\+A\+R\+N\+I\+N\+G\+: I\+S A\+C\+T\+U\+A\+L\+L\+Y V\+E\+R\+T S\+L\+O\+W at least in the current implementation and for the current application! 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure, must have ctx\+Id field as this method will specifically use it to compare elements. \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_a8521db16ea82bce46a07bbdb3708a5a9}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+lsearch@{my\+\_\+lsearch}}
\index{my\+\_\+lsearch@{my\+\_\+lsearch}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+lsearch(const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array, T\+S\+Long\+Id l\+\_\+idx, T\+S\+Long\+Id u\+\_\+idx, const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E key, I\+D\+X\+\_\+\+T\+Y\+P\+E \&found\+\_\+pos)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename I\+D\+X\+\_\+\+T\+Y\+P\+E $>$ bool uva\+::smt\+::utils\+::array\+::my\+\_\+lsearch (
\begin{DoxyParamCaption}
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array, }
\item[{T\+S\+Long\+Id}]{l\+\_\+idx, }
\item[{T\+S\+Long\+Id}]{u\+\_\+idx, }
\item[{const A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E}]{key, }
\item[{I\+D\+X\+\_\+\+T\+Y\+P\+E \&}]{found\+\_\+pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1smt_1_1utils_1_1array_a8521db16ea82bce46a07bbdb3708a5a9}
This is a linear search algorithm for some ordered array 
\begin{DoxyParams}{Parameters}
{\em A\+R\+R\+\_\+\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element structure \\
\hline
{\em I\+D\+X\+\_\+\+T\+Y\+P\+E} & the index type \\
\hline
{\em K\+E\+Y\+\_\+\+T\+Y\+P\+E} & the key type template parameter \\
\hline
{\em array} & the pointer to the first array element \\
\hline
{\em l\+\_\+idx} & the initial left border index for searching \\
\hline
{\em u\+\_\+idx} & the initial right border index for searching \\
\hline
{\em key} & the key we are searching for \\
\hline
{\em found\+\_\+pos} & the out parameter that stores the found element index, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the element was found, otherwise false 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Exception} & in case (l\+\_\+idx $<$ 0) $\vert$$\vert$ (l\+\_\+idx $>$ u\+\_\+idx), with sanity checks on \\
\hline
\end{DoxyExceptions}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_a0134027046c3e661f065c4366fc0e7d1}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+sort@{my\+\_\+sort}}
\index{my\+\_\+sort@{my\+\_\+sort}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+sort(\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const T\+Short\+Id array\+\_\+size, typename T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+type is\+\_\+less\+\_\+func)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$ void uva\+::smt\+::utils\+::array\+::my\+\_\+sort (
\begin{DoxyParamCaption}
\item[{E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array\+\_\+begin, }
\item[{const T\+Short\+Id}]{array\+\_\+size, }
\item[{typename {\bf T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C}$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+type}]{is\+\_\+less\+\_\+func}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1smt_1_1utils_1_1array_a0134027046c3e661f065c4366fc0e7d1}
This methos is used to do $<$algorithm$>$ std\+::sort on an array of structures convertable to some simple comparable type. This method does the progress bar update, if needed 
\begin{DoxyParams}{Parameters}
{\em E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element type \\
\hline
{\em array\+\_\+begin} & the pointer to the array\textquotesingle{}s first element \\
\hline
{\em array\+\_\+size} & the size of the array \\
\hline
{\em is\+\_\+less\+\_\+func} & the is-\/less function \\
\hline
\end{DoxyParams}
\hypertarget{namespaceuva_1_1smt_1_1utils_1_1array_ae4bb9605bac91686c73ea21648799154}{}\index{uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}!my\+\_\+sort@{my\+\_\+sort}}
\index{my\+\_\+sort@{my\+\_\+sort}!uva\+::smt\+::utils\+::array@{uva\+::smt\+::utils\+::array}}
\subsubsection[{my\+\_\+sort(\+E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$array\+\_\+begin, const T\+Short\+Id array\+\_\+size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename E\+L\+E\+M\+\_\+\+T\+Y\+P\+E , typename T\+\_\+\+I\+S\+\_\+\+C\+O\+M\+P\+A\+R\+E\+\_\+\+F\+U\+N\+C$<$ E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $>$\+::func\+\_\+ptr I\+S\+\_\+\+L\+E\+S\+S\+\_\+\+F\+U\+N\+C$>$ void uva\+::smt\+::utils\+::array\+::my\+\_\+sort (
\begin{DoxyParamCaption}
\item[{E\+L\+E\+M\+\_\+\+T\+Y\+P\+E $\ast$}]{array\+\_\+begin, }
\item[{const T\+Short\+Id}]{array\+\_\+size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceuva_1_1smt_1_1utils_1_1array_ae4bb9605bac91686c73ea21648799154}
This methos is used to do $<$algorithm$>$ std\+::sort on an array of structures convertable to some simple comparable type. This method does the progress bar update, if needed 
\begin{DoxyParams}{Parameters}
{\em E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element type \\
\hline
{\em I\+S\+\_\+\+L\+E\+S\+S\+\_\+\+F\+U\+N\+C} & the is-\/less function \\
\hline
{\em array\+\_\+begin} & the pointer to the array\textquotesingle{}s first element \\
\hline
{\em array\+\_\+size} & the size of the array\\
\hline
\end{DoxyParams}
This methos is used to do $<$algorithm$>$ std\+::sort on an array of structures convertable to some simple comparable type. This method does the progress bar update, if needed 
\begin{DoxyParams}{Parameters}
{\em E\+L\+E\+M\+\_\+\+T\+Y\+P\+E} & the array element type \\
\hline
{\em I\+S\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S} & if true the progress bar will be updated, otherwise not, default is true \\
\hline
{\em array\+\_\+begin} & the pointer to the array\textquotesingle{}s first element \\
\hline
{\em array\+\_\+size} & the size of the array \\
\hline
\end{DoxyParams}
