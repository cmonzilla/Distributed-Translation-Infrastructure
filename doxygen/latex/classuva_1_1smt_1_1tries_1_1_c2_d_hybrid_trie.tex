\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie}{}\section{uva\+:\+:smt\+:\+:tries\+:\+:C2\+D\+Hybrid\+Trie$<$ N, Word\+Index\+Type $>$ Class Template Reference}
\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie$<$ N, Word\+Index\+Type $>$@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie$<$ N, Word\+Index\+Type $>$}}


{\ttfamily \#include $<$C2\+D\+Map\+Array\+Trie.\+hpp$>$}

Inheritance diagram for uva\+:\+:smt\+:\+:tries\+:\+:C2\+D\+Hybrid\+Trie$<$ N, Word\+Index\+Type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4.000000cm]{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{classuva_1_1smt_1_1tries_1_1_layered_trie_base}{Layered\+Trie\+Base}$<$ N, \hyperlink{classuva_1_1smt_1_1tries_1_1_word_index_trie_base_a30c4fffe3a3423c87b229b66340dd2f8}{Word\+Index\+Type} $>$ \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a33ce4730ea0896a4ea7995c9e80688f7}{B\+A\+S\+E}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a390e38bc6e12db2878af63bacabf2e05}{C2\+D\+Hybrid\+Trie} (\hyperlink{classuva_1_1smt_1_1tries_1_1_word_index_trie_base_a30c4fffe3a3423c87b229b66340dd2f8}{Word\+Index\+Type} \&word\+\_\+index, const float mram\+\_\+mem\+\_\+factor=\+\_\+\+\_\+\+C2\+D\+Hybrid\+Trie\+::\+U\+M\+\_\+\+M\+\_\+\+G\+R\+A\+M\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R, const float ngram\+\_\+mem\+\_\+factor=\+\_\+\+\_\+\+C2\+D\+Hybrid\+Trie\+::\+U\+M\+\_\+\+N\+\_\+\+G\+R\+A\+M\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)
\item 
bool \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a074cc2aa4c9a9732a420d54b1f27eb9e}{is\+\_\+bitmap\+\_\+hash\+\_\+cache} ()
\item 
bool \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a499cc5205dd62389c416c22e4f23c1f5}{get\+\_\+ctx\+\_\+id} (const \hyperlink{namespaceuva_1_1smt_1_1hashing_adcf22e1982ad09d3a63494c006267469}{T\+Short\+Id} word\+Id, \hyperlink{namespaceuva_1_1smt_1_1hashing_a5992ac0dea0fb3226fb403ede09fad55}{T\+Long\+Id} \&ctx\+Id, const \hyperlink{namespaceuva_1_1smt_1_1tries_a20577a44b3a42d26524250634379b7cb}{T\+Model\+Level} level)
\item 
virtual void \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a05c3ebcd01018812d3b149cc2ecdccad}{log\+\_\+trie\+\_\+type\+\_\+usage\+\_\+info} ()
\item 
virtual void \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a792b513cbb0a298b3de40198fdd8e091}{pre\+\_\+allocate} (const size\+\_\+t counts\mbox{[}N\mbox{]})
\item 
\hyperlink{structuva_1_1smt_1_1tries_1_1_t_prob_back_off_entry}{T\+Prob\+Back\+Off\+Entry} \& \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a7f4253f810c679bdcddabcfa360ed0e1}{make\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref} (const \hyperlink{namespaceuva_1_1smt_1_1hashing_adcf22e1982ad09d3a63494c006267469}{T\+Short\+Id} word\+Id)
\item 
bool \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_afa55e767c01f1b1536a99bd07d259af1}{get\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref} (const \hyperlink{namespaceuva_1_1smt_1_1hashing_adcf22e1982ad09d3a63494c006267469}{T\+Short\+Id} word\+Id, const \hyperlink{structuva_1_1smt_1_1tries_1_1_t_prob_back_off_entry}{T\+Prob\+Back\+Off\+Entry} $\ast$$\ast$pp\+Data)
\item 
\hyperlink{structuva_1_1smt_1_1tries_1_1_t_prob_back_off_entry}{T\+Prob\+Back\+Off\+Entry} \& \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a29145443200bce608bda823f941c12c3}{make\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref} (const \hyperlink{namespaceuva_1_1smt_1_1tries_a20577a44b3a42d26524250634379b7cb}{T\+Model\+Level} level, const \hyperlink{namespaceuva_1_1smt_1_1hashing_adcf22e1982ad09d3a63494c006267469}{T\+Short\+Id} word\+Id, \hyperlink{namespaceuva_1_1smt_1_1hashing_a5992ac0dea0fb3226fb403ede09fad55}{T\+Long\+Id} ctx\+Id)
\item 
bool \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_ad69ca939c10f52a05db3df58aa69ca0c}{get\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref} (const \hyperlink{namespaceuva_1_1smt_1_1tries_a20577a44b3a42d26524250634379b7cb}{T\+Model\+Level} level, const \hyperlink{namespaceuva_1_1smt_1_1hashing_adcf22e1982ad09d3a63494c006267469}{T\+Short\+Id} word\+Id, \hyperlink{namespaceuva_1_1smt_1_1hashing_a5992ac0dea0fb3226fb403ede09fad55}{T\+Long\+Id} ctx\+Id, const \hyperlink{structuva_1_1smt_1_1tries_1_1_t_prob_back_off_entry}{T\+Prob\+Back\+Off\+Entry} $\ast$$\ast$pp\+Data)
\item 
\hyperlink{namespaceuva_1_1smt_1_1tries_acd0660255dd9ef5d644f01de49102750}{T\+Log\+Prob\+Back\+Off} \& \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_aa792980f3aa7340d8e4160a11870e7fd}{make\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref} (const \hyperlink{namespaceuva_1_1smt_1_1hashing_adcf22e1982ad09d3a63494c006267469}{T\+Short\+Id} word\+Id, \hyperlink{namespaceuva_1_1smt_1_1hashing_a5992ac0dea0fb3226fb403ede09fad55}{T\+Long\+Id} ctx\+Id)
\item 
bool \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a4595585ccbdc02ec39ea087d400312d8}{get\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref} (const \hyperlink{namespaceuva_1_1smt_1_1hashing_adcf22e1982ad09d3a63494c006267469}{T\+Short\+Id} word\+Id, \hyperlink{namespaceuva_1_1smt_1_1hashing_a5992ac0dea0fb3226fb403ede09fad55}{T\+Long\+Id} ctx\+Id, \hyperlink{namespaceuva_1_1smt_1_1tries_acd0660255dd9ef5d644f01de49102750}{T\+Log\+Prob\+Back\+Off} \&prob)
\item 
virtual \hyperlink{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a2d08a95b4ce574a430d6f7f2481c1f9d}{$\sim$\+C2\+D\+Hybrid\+Trie} ()
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\subsubsection*{template$<$T\+Model\+Level N, typename Word\+Index\+Type$>$class uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie$<$ N, Word\+Index\+Type $>$}

This is a hybrid trie implementation inspired by the four other ones\+:

W2\+C\+Ordered\+Array\+Trie, C2\+W\+Ordered\+Array\+Trie, Ctx\+Multi\+Hash\+Map\+Trie, and W2\+C\+Hybrid\+Memory\+Trie

It tries to be as much memory efficient as speed efficient. More specifically we store as much data as possible in an array form in order to get optimal memory consumption and having short and easily definable context index. Yet, we use unordered maps for the sake of speeding up queries, as they allow us to realize (word\+Id, ctx\+Id) to ctx\+Id in the most efficient manner. The lookup should be just O(1) whereas in the lookup is O(log(n)), as we need to use binary searches there. 

\subsection{Member Typedef Documentation}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a33ce4730ea0896a4ea7995c9e80688f7}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!B\+A\+S\+E@{B\+A\+S\+E}}
\index{B\+A\+S\+E@{B\+A\+S\+E}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{B\+A\+S\+E}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ typedef {\bf Layered\+Trie\+Base}$<$N, {\bf Word\+Index\+Type}$>$ {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::{\bf B\+A\+S\+E}}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a33ce4730ea0896a4ea7995c9e80688f7}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a390e38bc6e12db2878af63bacabf2e05}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!C2\+D\+Hybrid\+Trie@{C2\+D\+Hybrid\+Trie}}
\index{C2\+D\+Hybrid\+Trie@{C2\+D\+Hybrid\+Trie}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{C2\+D\+Hybrid\+Trie(\+Word\+Index\+Type \&word\+\_\+index, const float mram\+\_\+mem\+\_\+factor=\+\_\+\+\_\+\+C2\+D\+Hybrid\+Trie\+::\+U\+M\+\_\+\+M\+\_\+\+G\+R\+A\+M\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R, const float ngram\+\_\+mem\+\_\+factor=\+\_\+\+\_\+\+C2\+D\+Hybrid\+Trie\+::\+U\+M\+\_\+\+N\+\_\+\+G\+R\+A\+M\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::{\bf C2\+D\+Hybrid\+Trie} (
\begin{DoxyParamCaption}
\item[{{\bf Word\+Index\+Type} \&}]{word\+\_\+index, }
\item[{const float}]{mram\+\_\+mem\+\_\+factor = {\ttfamily \+\_\+\+\_\+C2DHybridTrie$<$~N,~{\bf Word\+Index\+Type}~$>$\+:\+:UM\+\_\+M\+\_\+GRAM\+\_\+MEMORY\+\_\+FACTOR}, }
\item[{const float}]{ngram\+\_\+mem\+\_\+factor = {\ttfamily \+\_\+\+\_\+C2DHybridTrie$<$~N,~{\bf Word\+Index\+Type}~$>$\+:\+:UM\+\_\+N\+\_\+GRAM\+\_\+MEMORY\+\_\+FACTOR}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a390e38bc6e12db2878af63bacabf2e05}
The basic class constructor, accepts memory factors that are the coefficients used when pre-\/allocating memory for unordered maps.

If a factor is equal to 0.\+0 then no memory is pre-\/allocated. If the factor is equal to 1.\+0 then there is only as much preallocated as needed to store the gram entries. The latter is typically not enough as unordered\+\_\+map needs more memory for internal administration. If there is not enough memory pre-\/allocated then additional allocations will take place but it does not alway lead to more efficient memory usage. The observed behavior is that it is better to pre-\/allocate a bit more memory beforehand, than needed. This leads to less memory consumption. Depending on the type of unordered\+\_\+map key/value pair types the advised factor values are from 2.\+0 to 2.\+6. Because it can not be optimally determined beforehand, these are made constructor parameters so that they can be configured by the used. This breaks encapsulation a bit, exposing the internals, but there is no other better way, for fine tuning the memory usage.


\begin{DoxyParams}{Parameters}
{\em \+\_\+p\+Word\+Index} & the word index to be used \\
\hline
{\em \+\_\+o\+Gram\+Mem\+Factor} & The One-\/\+Gram memory factor needed for the greedy allocator for the unordered\+\_\+map \\
\hline
{\em \+\_\+m\+Gram\+Mem\+Factor} & The M-\/\+Gram memory factor needed for the greedy allocator for the unordered\+\_\+map \\
\hline
{\em \+\_\+n\+Gram\+Mem\+Factor} & The N-\/\+Gram memory factor needed for the greedy allocator for the unordered\+\_\+map \\
\hline
\end{DoxyParams}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a2d08a95b4ce574a430d6f7f2481c1f9d}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!````~C2\+D\+Hybrid\+Trie@{$\sim$\+C2\+D\+Hybrid\+Trie}}
\index{````~C2\+D\+Hybrid\+Trie@{$\sim$\+C2\+D\+Hybrid\+Trie}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{$\sim$\+C2\+D\+Hybrid\+Trie()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::$\sim${\bf C2\+D\+Hybrid\+Trie} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a2d08a95b4ce574a430d6f7f2481c1f9d}
The basic destructor 

\subsection{Member Function Documentation}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_afa55e767c01f1b1536a99bd07d259af1}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!get\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref@{get\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref}}
\index{get\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref@{get\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{get\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref(const T\+Short\+Id word\+Id, const T\+Prob\+Back\+Off\+Entry $\ast$$\ast$pp\+Data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ bool {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::get\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref (
\begin{DoxyParamCaption}
\item[{const {\bf T\+Short\+Id}}]{word\+Id, }
\item[{const {\bf T\+Prob\+Back\+Off\+Entry} $\ast$$\ast$}]{pp\+Data}
\end{DoxyParamCaption}
)}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_afa55e767c01f1b1536a99bd07d259af1}
Allows to retrieve the data storage structure for the One gram with the given Id. If the storage structure does not exist, throws an exception. For more details \begin{DoxySeeAlso}{See also}
A\+Trie 
\end{DoxySeeAlso}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a499cc5205dd62389c416c22e4f23c1f5}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!get\+\_\+ctx\+\_\+id@{get\+\_\+ctx\+\_\+id}}
\index{get\+\_\+ctx\+\_\+id@{get\+\_\+ctx\+\_\+id}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{get\+\_\+ctx\+\_\+id(const T\+Short\+Id word\+Id, T\+Long\+Id \&ctx\+Id, const T\+Model\+Level level)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ bool {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::get\+\_\+ctx\+\_\+id (
\begin{DoxyParamCaption}
\item[{const {\bf T\+Short\+Id}}]{word\+Id, }
\item[{{\bf T\+Long\+Id} \&}]{ctx\+Id, }
\item[{const {\bf T\+Model\+Level}}]{level}
\end{DoxyParamCaption}
)}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a499cc5205dd62389c416c22e4f23c1f5}
Computes the N-\/\+Gram context using the previous context and the current word id

W\+A\+R\+N\+I\+N\+G\+: Must only be called for the M-\/gram level 1 $<$ M $<$ N! \begin{DoxySeeAlso}{See also}
\hyperlink{classuva_1_1smt_1_1tries_1_1_layered_trie_base}{Layered\+Trie\+Base}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em word\+Id} & the current word id \\
\hline
{\em ctx\+Id} & \mbox{[}in\mbox{]} -\/ the previous context id, \mbox{[}out\mbox{]} -\/ the next context id \\
\hline
{\em level} & the M-\/gram level we are working with M, default U\+N\+D\+E\+F\+\_\+\+N\+G\+R\+A\+M\+\_\+\+L\+E\+V\+E\+L \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the resulting context 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em nothing} & \\
\hline
\end{DoxyExceptions}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_ad69ca939c10f52a05db3df58aa69ca0c}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!get\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref@{get\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref}}
\index{get\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref@{get\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{get\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref(const T\+Model\+Level level, const T\+Short\+Id word\+Id, T\+Long\+Id ctx\+Id, const T\+Prob\+Back\+Off\+Entry $\ast$$\ast$pp\+Data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ bool {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::get\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref (
\begin{DoxyParamCaption}
\item[{const {\bf T\+Model\+Level}}]{level, }
\item[{const {\bf T\+Short\+Id}}]{word\+Id, }
\item[{{\bf T\+Long\+Id}}]{ctx\+Id, }
\item[{const {\bf T\+Prob\+Back\+Off\+Entry} $\ast$$\ast$}]{pp\+Data}
\end{DoxyParamCaption}
)}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_ad69ca939c10f52a05db3df58aa69ca0c}
Allows to retrieve the data storage structure for the M gram with the given M-\/gram level Id. M-\/gram context and last word Id. If the storage structure does not exist, throws an exception. For more details \begin{DoxySeeAlso}{See also}
A\+Trie 
\end{DoxySeeAlso}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a4595585ccbdc02ec39ea087d400312d8}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!get\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref@{get\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref}}
\index{get\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref@{get\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{get\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref(const T\+Short\+Id word\+Id, T\+Long\+Id ctx\+Id, T\+Log\+Prob\+Back\+Off \&prob)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ bool {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::get\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref (
\begin{DoxyParamCaption}
\item[{const {\bf T\+Short\+Id}}]{word\+Id, }
\item[{{\bf T\+Long\+Id}}]{ctx\+Id, }
\item[{{\bf T\+Log\+Prob\+Back\+Off} \&}]{prob}
\end{DoxyParamCaption}
)}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a4595585ccbdc02ec39ea087d400312d8}
Allows to retrieve the probability value for the N gram defined by the end word\+Id and ctx\+Id. For more details \begin{DoxySeeAlso}{See also}
A\+Trie 
\end{DoxySeeAlso}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a074cc2aa4c9a9732a420d54b1f27eb9e}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!is\+\_\+bitmap\+\_\+hash\+\_\+cache@{is\+\_\+bitmap\+\_\+hash\+\_\+cache}}
\index{is\+\_\+bitmap\+\_\+hash\+\_\+cache@{is\+\_\+bitmap\+\_\+hash\+\_\+cache}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{is\+\_\+bitmap\+\_\+hash\+\_\+cache()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ bool {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::is\+\_\+bitmap\+\_\+hash\+\_\+cache (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a074cc2aa4c9a9732a420d54b1f27eb9e}
\begin{DoxySeeAlso}{See also}
\hyperlink{classuva_1_1smt_1_1tries_1_1_layered_trie_base}{Layered\+Trie\+Base} 
\end{DoxySeeAlso}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a05c3ebcd01018812d3b149cc2ecdccad}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!log\+\_\+trie\+\_\+type\+\_\+usage\+\_\+info@{log\+\_\+trie\+\_\+type\+\_\+usage\+\_\+info}}
\index{log\+\_\+trie\+\_\+type\+\_\+usage\+\_\+info@{log\+\_\+trie\+\_\+type\+\_\+usage\+\_\+info}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{log\+\_\+trie\+\_\+type\+\_\+usage\+\_\+info()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ virtual void {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::log\+\_\+trie\+\_\+type\+\_\+usage\+\_\+info (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a05c3ebcd01018812d3b149cc2ecdccad}
Allows to log the information about the instantiated trie type \hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a7f4253f810c679bdcddabcfa360ed0e1}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!make\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref@{make\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref}}
\index{make\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref@{make\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{make\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref(const T\+Short\+Id word\+Id)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ {\bf T\+Prob\+Back\+Off\+Entry} \& {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::make\+\_\+1\+\_\+gram\+\_\+data\+\_\+ref (
\begin{DoxyParamCaption}
\item[{const {\bf T\+Short\+Id}}]{word\+Id}
\end{DoxyParamCaption}
)}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a7f4253f810c679bdcddabcfa360ed0e1}
Allows to retrieve the data storage structure for the One gram with the given Id. If the storage structure does not exist, return a new one. For more details \begin{DoxySeeAlso}{See also}
A\+Trie 
\end{DoxySeeAlso}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a29145443200bce608bda823f941c12c3}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!make\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref@{make\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref}}
\index{make\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref@{make\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{make\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref(const T\+Model\+Level level, const T\+Short\+Id word\+Id, T\+Long\+Id ctx\+Id)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ {\bf T\+Prob\+Back\+Off\+Entry} \& {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::make\+\_\+m\+\_\+gram\+\_\+data\+\_\+ref (
\begin{DoxyParamCaption}
\item[{const {\bf T\+Model\+Level}}]{level, }
\item[{const {\bf T\+Short\+Id}}]{word\+Id, }
\item[{{\bf T\+Long\+Id}}]{ctx\+Id}
\end{DoxyParamCaption}
)}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a29145443200bce608bda823f941c12c3}
Allows to retrieve the data storage structure for the M gram with the given M-\/gram level Id. M-\/gram context and last word Id. If the storage structure does not exist, return a new one. For more details \begin{DoxySeeAlso}{See also}
A\+Trie 
\end{DoxySeeAlso}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_aa792980f3aa7340d8e4160a11870e7fd}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!make\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref@{make\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref}}
\index{make\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref@{make\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{make\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref(const T\+Short\+Id word\+Id, T\+Long\+Id ctx\+Id)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ {\bf T\+Log\+Prob\+Back\+Off} \& {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::make\+\_\+n\+\_\+gram\+\_\+data\+\_\+ref (
\begin{DoxyParamCaption}
\item[{const {\bf T\+Short\+Id}}]{word\+Id, }
\item[{{\bf T\+Long\+Id}}]{ctx\+Id}
\end{DoxyParamCaption}
)}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_aa792980f3aa7340d8e4160a11870e7fd}
Allows to retrieve the data storage structure for the N gram. Given the N-\/gram context and last word Id. If the storage structure does not exist, return a new one. For more details \begin{DoxySeeAlso}{See also}
A\+Trie 
\end{DoxySeeAlso}
\hypertarget{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a792b513cbb0a298b3de40198fdd8e091}{}\index{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}!pre\+\_\+allocate@{pre\+\_\+allocate}}
\index{pre\+\_\+allocate@{pre\+\_\+allocate}!uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie@{uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}}
\subsubsection[{pre\+\_\+allocate(const size\+\_\+t counts[N])}]{\setlength{\rightskip}{0pt plus 5cm}template$<$T\+Model\+Level N, typename Word\+Index\+Type $>$ void {\bf uva\+::smt\+::tries\+::\+C2\+D\+Hybrid\+Trie}$<$ N, {\bf Word\+Index\+Type} $>$\+::pre\+\_\+allocate (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{counts\mbox{[}\+N\mbox{]}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classuva_1_1smt_1_1tries_1_1_c2_d_hybrid_trie_a792b513cbb0a298b3de40198fdd8e091}
This method can be used to provide the N-\/gram count information That should allow for pre-\/allocation of the memory For more details \begin{DoxySeeAlso}{See also}
A\+Trie 
\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
inc/\hyperlink{_c2_d_map_array_trie_8hpp}{C2\+D\+Map\+Array\+Trie.\+hpp}\item 
src/\hyperlink{_c2_d_map_array_trie_8cpp}{C2\+D\+Map\+Array\+Trie.\+cpp}\end{DoxyCompactItemize}
