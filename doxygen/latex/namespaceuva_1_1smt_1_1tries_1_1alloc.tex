\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc}{}\section{uva\+:\+:smt\+:\+:tries\+:\+:alloc Namespace Reference}
\label{namespaceuva_1_1smt_1_1tries_1_1alloc}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}
\item 
class \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_storage}{Greedy\+Memory\+Storage}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T\+Contaner , typename T\+Allocator $>$ }\\void \hyperlink{namespaceuva_1_1smt_1_1tries_1_1alloc_a06a0b287f69168d8f3eaa4eafd7a8513}{allocate\+\_\+container} (T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor)
\item 
{\footnotesize template$<$typename T\+Contaner , typename T\+Allocator $>$ }\\void \hyperlink{namespaceuva_1_1smt_1_1tries_1_1alloc_a2c181932d57f2889db12f245097d3b96}{reserve\+\_\+mem\+\_\+unordered\+\_\+map} (T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor=U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)
\item 
{\footnotesize template$<$typename T\+Contaner , typename T\+Allocator $>$ }\\void \hyperlink{namespaceuva_1_1smt_1_1tries_1_1alloc_a8f63d24e724796c5c4daa555ee1f3bc7}{deallocate\+\_\+container} (T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator)
\item 
{\footnotesize template$<$typename T , typename U $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1tries_1_1alloc_a9e2fd05ee524012c1fd4398fe457e5dc}{operator==} (const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ U $>$ \&)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1tries_1_1alloc_a4148e630799431da09b14782fea4cc96}{operator==} (const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ T $>$ \&)
\item 
{\footnotesize template$<$typename T , typename U $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1tries_1_1alloc_a49f57a5b2c27ce6e2b8da7f15d1d44ad}{operator!=} (const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ U $>$ \&)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \hyperlink{namespaceuva_1_1smt_1_1tries_1_1alloc_ad691046a976d11527099d8792bb93e21}{operator!=} (const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ T $>$ \&, const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ T $>$ \&)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc_a06a0b287f69168d8f3eaa4eafd7a8513}{}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}!allocate\+\_\+container@{allocate\+\_\+container}}
\index{allocate\+\_\+container@{allocate\+\_\+container}!uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsubsection[{allocate\+\_\+container(\+T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Contaner , typename T\+Allocator $>$ void uva\+::smt\+::tries\+::alloc\+::allocate\+\_\+container (
\begin{DoxyParamCaption}
\item[{T\+Contaner $\ast$$\ast$}]{pp\+Container, }
\item[{T\+Allocator $\ast$$\ast$}]{pp\+Allocator, }
\item[{const size\+\_\+t}]{num\+Entries, }
\item[{const string}]{ct\+Name, }
\item[{const float}]{factor}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1tries_1_1alloc_a06a0b287f69168d8f3eaa4eafd7a8513}
This is helper function that allows to allocate the container, allocator and the actual data storage Note that, this functions is meant to be used with the unordered\+\_\+map allocator 
\begin{DoxyParams}{Parameters}
{\em pp\+Container} & the pointer to the container pointer \\
\hline
{\em pp\+Allocator} & the pointer to the allocator pointer \\
\hline
\end{DoxyParams}
\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc_a8f63d24e724796c5c4daa555ee1f3bc7}{}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}!deallocate\+\_\+container@{deallocate\+\_\+container}}
\index{deallocate\+\_\+container@{deallocate\+\_\+container}!uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsubsection[{deallocate\+\_\+container(\+T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Contaner , typename T\+Allocator $>$ void uva\+::smt\+::tries\+::alloc\+::deallocate\+\_\+container (
\begin{DoxyParamCaption}
\item[{T\+Contaner $\ast$$\ast$}]{pp\+Container, }
\item[{T\+Allocator $\ast$$\ast$}]{pp\+Allocator}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1tries_1_1alloc_a8f63d24e724796c5c4daa555ee1f3bc7}
This is helper function that allows to deallocate the container allocator and actual data storage 
\begin{DoxyParams}{Parameters}
{\em pp\+Container} & the pointer to the container pointer \\
\hline
{\em pp\+Allocator} & the pointer to the allocator pointer \\
\hline
{\em pp\+Storage} & the pointer to the storage pointer \\
\hline
\end{DoxyParams}
\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc_a49f57a5b2c27ce6e2b8da7f15d1d44ad}{}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsubsection[{operator"!=(const Greedy\+Memory\+Allocator$<$ T $>$ \&, const Greedy\+Memory\+Allocator$<$ U $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename U $>$ bool uva\+::smt\+::tries\+::alloc\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ U $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1tries_1_1alloc_a49f57a5b2c27ce6e2b8da7f15d1d44ad}
\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc_ad691046a976d11527099d8792bb93e21}{}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsubsection[{operator"!=(const Greedy\+Memory\+Allocator$<$ T $>$ \&, const Greedy\+Memory\+Allocator$<$ T $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool uva\+::smt\+::tries\+::alloc\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ T $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1tries_1_1alloc_ad691046a976d11527099d8792bb93e21}
\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc_a9e2fd05ee524012c1fd4398fe457e5dc}{}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}!operator==@{operator==}}
\index{operator==@{operator==}!uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsubsection[{operator==(const Greedy\+Memory\+Allocator$<$ T $>$ \&, const Greedy\+Memory\+Allocator$<$ U $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename U $>$ bool uva\+::smt\+::tries\+::alloc\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ U $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1tries_1_1alloc_a9e2fd05ee524012c1fd4398fe457e5dc}
\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc_a4148e630799431da09b14782fea4cc96}{}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}!operator==@{operator==}}
\index{operator==@{operator==}!uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsubsection[{operator==(const Greedy\+Memory\+Allocator$<$ T $>$ \&, const Greedy\+Memory\+Allocator$<$ T $>$ \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool uva\+::smt\+::tries\+::alloc\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ T $>$ \&}]{, }
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ T $>$ \&}]{}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1tries_1_1alloc_a4148e630799431da09b14782fea4cc96}
\hypertarget{namespaceuva_1_1smt_1_1tries_1_1alloc_a2c181932d57f2889db12f245097d3b96}{}\index{uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}!reserve\+\_\+mem\+\_\+unordered\+\_\+map@{reserve\+\_\+mem\+\_\+unordered\+\_\+map}}
\index{reserve\+\_\+mem\+\_\+unordered\+\_\+map@{reserve\+\_\+mem\+\_\+unordered\+\_\+map}!uva\+::smt\+::tries\+::alloc@{uva\+::smt\+::tries\+::alloc}}
\subsubsection[{reserve\+\_\+mem\+\_\+unordered\+\_\+map(\+T\+Contaner $\ast$$\ast$pp\+Container, T\+Allocator $\ast$$\ast$pp\+Allocator, const size\+\_\+t num\+Entries, const string ct\+Name, const float factor=\+U\+N\+O\+R\+D\+E\+R\+E\+D\+\_\+\+M\+A\+P\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+F\+A\+C\+T\+O\+R)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Contaner , typename T\+Allocator $>$ void uva\+::smt\+::tries\+::alloc\+::reserve\+\_\+mem\+\_\+unordered\+\_\+map (
\begin{DoxyParamCaption}
\item[{T\+Contaner $\ast$$\ast$}]{pp\+Container, }
\item[{T\+Allocator $\ast$$\ast$}]{pp\+Allocator, }
\item[{const size\+\_\+t}]{num\+Entries, }
\item[{const string}]{ct\+Name, }
\item[{const float}]{factor = {\ttfamily UNORDERED\+\_\+MAP\+\_\+MEMORY\+\_\+FACTOR}}
\end{DoxyParamCaption}
)}\label{namespaceuva_1_1smt_1_1tries_1_1alloc_a2c181932d57f2889db12f245097d3b96}
This is helper function that allows to allocate the container, allocator and the actual data storage Note that, this functions is meant to be used with the unordered\+\_\+map allocator 
\begin{DoxyParams}{Parameters}
{\em pp\+Container} & the pointer to the container pointer \\
\hline
{\em pp\+Allocator} & the pointer to the allocator pointer \\
\hline
\end{DoxyParams}
