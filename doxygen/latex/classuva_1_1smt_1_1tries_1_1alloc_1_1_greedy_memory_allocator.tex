\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{}\section{uva\+:\+:smt\+:\+:tries\+:\+:alloc\+:\+:Greedy\+Memory\+Allocator$<$ T $>$ Class Template Reference}
\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator$<$ T $>$@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator$<$ T $>$}}


{\ttfamily \#include $<$Greedy\+Memory\+Allocator.\+hpp$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_1_1rebind}{rebind}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef T \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a11ff94e5a9e23e3db57976661f6d06f8}{value\+\_\+type}
\item 
typedef \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_storage_a15b9139bffa854a165a11131725fa903}{Greedy\+Memory\+Storage\+::size\+\_\+type} \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}{size\+\_\+type}
\item 
typedef std\+::ptrdiff\+\_\+t \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a14467f640838b0667457750468f433cc}{difference\+\_\+type}
\item 
typedef T $\ast$ \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}{pointer}
\item 
typedef const T $\ast$ \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_aaa55b155c72c0817936b86c9c11a6ab2}{const\+\_\+pointer}
\item 
typedef T \& \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a62f7001b75a49f4711f5b06900642f8b}{reference}
\item 
typedef const T \& \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a1f74969c0895bf669864b2b28e675386}{const\+\_\+reference}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ae87e1efb69523a746d42c2bdff324b6a}{Greedy\+Memory\+Allocator} (\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}{size\+\_\+type} num\+Elems)  throw ()
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a3c3e41759b86df79ce3321386b8dafcd}{Greedy\+Memory\+Allocator} (const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator} \&other)  throw ()
\item 
{\footnotesize template$<$typename U $>$ }\\\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_afce20e748e6ecdb3890b2bb373bb755c}{Greedy\+Memory\+Allocator} (const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator}{Greedy\+Memory\+Allocator}$<$ U $>$ \&other)  throw ()
\item 
virtual \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad14d50375a544eb20ef5d232ab56ba85}{$\sim$\+Greedy\+Memory\+Allocator} ()  throw ()
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}{pointer} \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a13768ffe7599dc80f0f75bf55ddf4dbf}{address} (\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a62f7001b75a49f4711f5b06900642f8b}{reference} obj) const 
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_aaa55b155c72c0817936b86c9c11a6ab2}{const\+\_\+pointer} \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a84868724dd7024e8a52e23bf248dfdab}{address} (\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a1f74969c0895bf669864b2b28e675386}{const\+\_\+reference} obj) const 
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}{pointer} \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a4b1061b120ca17a9ada79050c9960134}{allocate} (\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}{size\+\_\+type} num, \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_aaa55b155c72c0817936b86c9c11a6ab2}{const\+\_\+pointer} cp=0)
\item 
void \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a57550de709555d5378d86e318da7c36d}{deallocate} (\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}{pointer} ptr, \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}{size\+\_\+type} num)
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}{size\+\_\+type} \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a2ad3d828734f577bfbb8d85df657f15b}{available} () const   throw ()
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}{size\+\_\+type} \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ac749bcedee3cc0a29834feeafeca1b6a}{max\+\_\+size} () const   throw ()
\item 
void \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ab734ed08724d82553b8b4a73b2d48e82}{construct} (\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}{pointer} ptr, const \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a11ff94e5a9e23e3db57976661f6d06f8}{value\+\_\+type} \&value)
\item 
void \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ac5efe3db6641f4fd16dc6d795615b86b}{destroy} (\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}{pointer} ptr)
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_storage}{Greedy\+Memory\+Storage} \& \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a84636e616956f0eec410d7f5034dbdfb}{get\+Storage\+Ref} () const 
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_storage}{Greedy\+Memory\+Storage} \& \hyperlink{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a43f47988468fe19dee3d5adae8574321}{\+\_\+manager}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T$>$class uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator$<$ T $>$}

This is the fixed memory allocator class for using in the tries. Here we pre-\/allocate some fixed size memory and then just give it out when needed. Since the Trie is build once and then is not changed, we do no do any memory deallocation here! 

\subsection{Member Typedef Documentation}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_aaa55b155c72c0817936b86c9c11a6ab2}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!const\+\_\+pointer@{const\+\_\+pointer}}
\index{const\+\_\+pointer@{const\+\_\+pointer}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{const\+\_\+pointer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ typedef const T$\ast$ {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf const\+\_\+pointer}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_aaa55b155c72c0817936b86c9c11a6ab2}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a1f74969c0895bf669864b2b28e675386}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!const\+\_\+reference@{const\+\_\+reference}}
\index{const\+\_\+reference@{const\+\_\+reference}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{const\+\_\+reference}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ typedef const T\& {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf const\+\_\+reference}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a1f74969c0895bf669864b2b28e675386}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a14467f640838b0667457750468f433cc}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!difference\+\_\+type@{difference\+\_\+type}}
\index{difference\+\_\+type@{difference\+\_\+type}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{difference\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ typedef std\+::ptrdiff\+\_\+t {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf difference\+\_\+type}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a14467f640838b0667457750468f433cc}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!pointer@{pointer}}
\index{pointer@{pointer}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{pointer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ typedef T$\ast$ {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf pointer}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad82be226faea1278f210654317249483}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a62f7001b75a49f4711f5b06900642f8b}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!reference@{reference}}
\index{reference@{reference}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{reference}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ typedef T\& {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf reference}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a62f7001b75a49f4711f5b06900642f8b}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!size\+\_\+type@{size\+\_\+type}}
\index{size\+\_\+type@{size\+\_\+type}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{size\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ typedef {\bf Greedy\+Memory\+Storage\+::size\+\_\+type} {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf size\+\_\+type}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a76d81ff5df20ef0404bb2027016b8b2d}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a11ff94e5a9e23e3db57976661f6d06f8}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!value\+\_\+type@{value\+\_\+type}}
\index{value\+\_\+type@{value\+\_\+type}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{value\+\_\+type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ typedef T {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf value\+\_\+type}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a11ff94e5a9e23e3db57976661f6d06f8}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ae87e1efb69523a746d42c2bdff324b6a}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!Greedy\+Memory\+Allocator@{Greedy\+Memory\+Allocator}}
\index{Greedy\+Memory\+Allocator@{Greedy\+Memory\+Allocator}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{Greedy\+Memory\+Allocator(size\+\_\+type num\+Elems)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf Greedy\+Memory\+Allocator} (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{num\+Elems}
\end{DoxyParamCaption}
) throw  ) \hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ae87e1efb69523a746d42c2bdff324b6a}
The basic constructor. 
\begin{DoxyParams}{Parameters}
{\em num\+Elems} & the number of elements of template type T to pre-\/allocate memory for. \\
\hline
\end{DoxyParams}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a3c3e41759b86df79ce3321386b8dafcd}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!Greedy\+Memory\+Allocator@{Greedy\+Memory\+Allocator}}
\index{Greedy\+Memory\+Allocator@{Greedy\+Memory\+Allocator}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{Greedy\+Memory\+Allocator(const Greedy\+Memory\+Allocator \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf Greedy\+Memory\+Allocator} (
\begin{DoxyParamCaption}
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ T $>$ \&}]{other}
\end{DoxyParamCaption}
) throw  ) \hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a3c3e41759b86df79ce3321386b8dafcd}
The basic copy constructor. \hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_afce20e748e6ecdb3890b2bb373bb755c}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!Greedy\+Memory\+Allocator@{Greedy\+Memory\+Allocator}}
\index{Greedy\+Memory\+Allocator@{Greedy\+Memory\+Allocator}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{Greedy\+Memory\+Allocator(const Greedy\+Memory\+Allocator$<$ U $>$ \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ template$<$typename U $>$ {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::{\bf Greedy\+Memory\+Allocator} (
\begin{DoxyParamCaption}
\item[{const {\bf Greedy\+Memory\+Allocator}$<$ U $>$ \&}]{other}
\end{DoxyParamCaption}
) throw  ) \hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_afce20e748e6ecdb3890b2bb373bb755c}
The basic re-\/bind constructor. It is used internally by the container in case it needs to allocate other sort data than the stored container elements. \hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad14d50375a544eb20ef5d232ab56ba85}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!````~Greedy\+Memory\+Allocator@{$\sim$\+Greedy\+Memory\+Allocator}}
\index{````~Greedy\+Memory\+Allocator@{$\sim$\+Greedy\+Memory\+Allocator}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{$\sim$\+Greedy\+Memory\+Allocator()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ virtual {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::$\sim${\bf Greedy\+Memory\+Allocator} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) throw  ) \hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ad14d50375a544eb20ef5d232ab56ba85}
The standard destructor 

\subsection{Member Function Documentation}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a13768ffe7599dc80f0f75bf55ddf4dbf}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!address@{address}}
\index{address@{address}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{address(reference obj) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf pointer} {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::address (
\begin{DoxyParamCaption}
\item[{{\bf reference}}]{obj}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a13768ffe7599dc80f0f75bf55ddf4dbf}
Computes the address of the given object 
\begin{DoxyParams}{Parameters}
{\em obj} & the object to compute the pointer of \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the computed pointer 
\end{DoxyReturn}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a84868724dd7024e8a52e23bf248dfdab}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!address@{address}}
\index{address@{address}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{address(const\+\_\+reference obj) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf const\+\_\+pointer} {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::address (
\begin{DoxyParamCaption}
\item[{{\bf const\+\_\+reference}}]{obj}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a84868724dd7024e8a52e23bf248dfdab}
Computes the address of the given object 
\begin{DoxyParams}{Parameters}
{\em obj} & the object to compute the pointer of \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the computed pointer 
\end{DoxyReturn}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a4b1061b120ca17a9ada79050c9960134}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!allocate@{allocate}}
\index{allocate@{allocate}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{allocate(size\+\_\+type num, const\+\_\+pointer cp=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf pointer} {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::allocate (
\begin{DoxyParamCaption}
\item[{{\bf size\+\_\+type}}]{num, }
\item[{{\bf const\+\_\+pointer}}]{cp = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a4b1061b120ca17a9ada79050c9960134}
Allocates memory for the given number of objects 
\begin{DoxyParams}{Parameters}
{\em num} & the number of objects to allocate \\
\hline
{\em cp} & N\+O\+T U\+S\+E\+D \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pointer to the first allocated object 
\end{DoxyReturn}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a2ad3d828734f577bfbb8d85df657f15b}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!available@{available}}
\index{available@{available}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{available() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf size\+\_\+type} {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::available (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const throw  ) \hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a2ad3d828734f577bfbb8d85df657f15b}
Returns the available number of free elements we can store \begin{DoxyReturn}{Returns}
the available number of free elements we can store 
\end{DoxyReturn}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ab734ed08724d82553b8b4a73b2d48e82}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!construct@{construct}}
\index{construct@{construct}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{construct(pointer ptr, const value\+\_\+type \&value)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ void {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::construct (
\begin{DoxyParamCaption}
\item[{{\bf pointer}}]{ptr, }
\item[{const {\bf value\+\_\+type} \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ab734ed08724d82553b8b4a73b2d48e82}
Calling the constructor on the given pointer 
\begin{DoxyParams}{Parameters}
{\em ptr} & the pointer to work with \\
\hline
{\em value} & the type value to work with \\
\hline
\end{DoxyParams}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a57550de709555d5378d86e318da7c36d}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{deallocate(pointer ptr, size\+\_\+type num)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ void {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::deallocate (
\begin{DoxyParamCaption}
\item[{{\bf pointer}}]{ptr, }
\item[{{\bf size\+\_\+type}}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a57550de709555d5378d86e318da7c36d}
This function is supposed to deallocate the memory. We do not do that as this is fixed memory allocator 
\begin{DoxyParams}{Parameters}
{\em ptr} & the pointer to free memory from \\
\hline
{\em num} & the number of objects to deallocate \\
\hline
\end{DoxyParams}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ac5efe3db6641f4fd16dc6d795615b86b}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!destroy@{destroy}}
\index{destroy@{destroy}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{destroy(pointer ptr)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ void {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::destroy (
\begin{DoxyParamCaption}
\item[{{\bf pointer}}]{ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ac5efe3db6641f4fd16dc6d795615b86b}
Calling the destructor on the given pointer 
\begin{DoxyParams}{Parameters}
{\em ptr} & the pointer to work with \\
\hline
\end{DoxyParams}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a84636e616956f0eec410d7f5034dbdfb}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!get\+Storage\+Ref@{get\+Storage\+Ref}}
\index{get\+Storage\+Ref@{get\+Storage\+Ref}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{get\+Storage\+Ref() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf Greedy\+Memory\+Storage}\& {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::get\+Storage\+Ref (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a84636e616956f0eec410d7f5034dbdfb}
Returns the reference to the buffer manager \begin{DoxyReturn}{Returns}
the reference to the buffer manager 
\end{DoxyReturn}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ac749bcedee3cc0a29834feeafeca1b6a}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!max\+\_\+size@{max\+\_\+size}}
\index{max\+\_\+size@{max\+\_\+size}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{max\+\_\+size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf size\+\_\+type} {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::max\+\_\+size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const throw  ) \hspace{0.3cm}{\ttfamily [inline]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_ac749bcedee3cc0a29834feeafeca1b6a}
Returns the maximum number of elements we can store \begin{DoxyReturn}{Returns}
the maximum number of elements we can store 
\end{DoxyReturn}


\subsection{Member Data Documentation}
\hypertarget{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a43f47988468fe19dee3d5adae8574321}{}\index{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}!\+\_\+manager@{\+\_\+manager}}
\index{\+\_\+manager@{\+\_\+manager}!uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator@{uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}}
\subsubsection[{\+\_\+manager}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf Greedy\+Memory\+Storage}\& {\bf uva\+::smt\+::tries\+::alloc\+::\+Greedy\+Memory\+Allocator}$<$ T $>$\+::\+\_\+manager\hspace{0.3cm}{\ttfamily [protected]}}\label{classuva_1_1smt_1_1tries_1_1alloc_1_1_greedy_memory_allocator_a43f47988468fe19dee3d5adae8574321}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
inc/\hyperlink{_greedy_memory_allocator_8hpp}{Greedy\+Memory\+Allocator.\+hpp}\end{DoxyCompactItemize}
